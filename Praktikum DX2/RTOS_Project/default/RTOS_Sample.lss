
RTOS_Sample.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000066d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000006a  00800060  000066d0  00006764  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000698  008000ca  008000ca  000067ce  2**0
                  ALLOC
  3 .stab         00000ed0  00000000  00000000  000067d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000403  00000000  00000000  000076a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000178  00000000  00000000  00007aa3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000006f5  00000000  00000000  00007c1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002c0f  00000000  00000000  00008310  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ecc  00000000  00000000  0000af1f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002c1a  00000000  00000000  0000bdeb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000005b0  00000000  00000000  0000ea08  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001207  00000000  00000000  0000efb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001c76  00000000  00000000  000101bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000465  00000000  00000000  00011e35  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000a0  00000000  00000000  0001229a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 21 	jmp	0x4254	; 0x4254 <__ctors_end>
       4:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       8:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      10:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      14:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      18:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      1c:	0c 94 20 2f 	jmp	0x5e40	; 0x5e40 <__vector_7>
      20:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      24:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      28:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      2c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      30:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      34:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      38:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      3c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      40:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      44:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      48:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      4c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      50:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>

00000054 <sample_data>:
      54:	85 85 85 83 81 81 83 85 87 8a 8b 89 88 87 85 84     ................
      64:	85 84 84 85 82 82 84 86 8a 8d 91 91 91 90 90 8f     ................
      74:	8d 8c 8b 8b 8c 8b 8a 89 89 89 87 84 82 7f 7a 76     ..............zv
      84:	75 75 77 77 78 7d 82 85 86 88 88 87 84 81 7f 7e     uuwwx}.........~
      94:	7d 7f 7f 81 85 85 87 89 8c 8d 8e 91 90 90 90 8e     }...............
      a4:	8c 8a 88 86 83 83 82 84 86 88 8b 8f 94 94 95 96     ................
      b4:	97 97 98 98 98 99 97 95 91 8d 89 84 81 80 80 80     ................
      c4:	7f 7f 80 80 7f 7f 80 82 83 85 86 8a 8e 91 93 93     ................
      d4:	93 91 90 8f 8e 8f 90 91 93 92 91 91 8e 8b 87 7f     ................
      e4:	77 70 6b 67 68 6a 6f 72 75 7a 7f 84 8a 8d 91 95     wpkghjoruz......
      f4:	97 97 98 99 99 96 90 8a 85 82 80 7e 7e 7d 79 75     ...........~~}yu
     104:	71 6f 6f 6e 6d 6e 73 79 80 87 8d 91 93 94 94 91     qoonmnsy........
     114:	89 81 78 71 6d 6b 6c 70 76 7c 82 88 8b 8c 8f 8f     ..xqmklpv|......
     124:	8d 8a 88 88 8a 89 87 86 85 87 87 87 87 8a 8b 8b     ................
     134:	88 86 85 83 81 80 7e 7e 80 81 84 88 8c 8d 8d 8d     ......~~........
     144:	8c 8a 88 86 85 85 83 82 81 80 7f 80 80 81 81 83     ................
     154:	85 86 88 8a 8a 89 89 88 85 83 82 82 84 86 8a 8d     ................
     164:	90 91 92 93 92 90 8c 88 85 82 7f 7e 7e 7e 7f 81     ...........~~~..
     174:	85 88 8b 8d 8d 8c 8c 8a 88 86 84 83 85 88 8b 8e     ................
     184:	8f 8f 8d 89 84 80 7c 7a 79 78 78 7b 7d 7f 82 83     ......|zyxx{}...
     194:	85 87 87 88 8a 8d 90 93 96 9a 9b 9b 9b 9a 9a 99     ................
     1a4:	98 96 93 91 8e 8c 8a 87 84 82 80 80 80 80 80 81     ................
     1b4:	82 83 85 84 86 88 89 87 86 86 87 86 86 86 88 8a     ................
     1c4:	8c 8d 8e 8f 8f 8d 8a 88 86 85 82 80 7f 7f 81 84     ................
     1d4:	88 8a 8e 91 93 94 95 95 93 90 8d 8c 8b 8b 8c 90     ................
     1e4:	93 96 98 99 9b 9b 96 91 8c 86 83 80 7d 7b 7c 7c     ............}{||
     1f4:	7e 81 84 88 8a 8d 8f 90 92 90 8c 8a 86 81 7c 7a     ~.............|z
     204:	78 77 76 73 73 73 75 79 7c 7f 80 82 83 83 83 81     xwvsssuy|.......
     214:	7d 79 76 74 72 73 75 77 7a 7c 7f 80 82 85 88 8b     }yvtrsuwz|......
     224:	8d 8e 8f 91 92 93 93 93 92 90 8f 8c 8b 8c 8a 8a     ................
     234:	8a 88 86 82 7c 79 76 74 74 73 73 75 79 7e 82 85     ....|yvttssuy~..
     244:	86 88 89 89 87 85 85 84 83 82 7f 7d 7b 77 75 75     ...........}{wuu
     254:	76 75 75 73 74 76 79 7c 7d 7f 81 83 84 86 86 84     vuustvy|}.......
     264:	80 7e 7d 7d 7d 7e 81 86 8b 8c 8d 8e 8e 8c 89 85     .~}}}~..........
     274:	81 7e 7b 79 77 77 78 77 7a 7e 80 84 85 85 86 86     .~{ywwxwz~......
     284:	86 86 86 84 81 80 7f 7d 7b 7b 7a 7a 7c 7d 7f 81     .......}{{zz|}..
     294:	81 80 7f 81 81 81 81 81 83 84 85 85 85 84 82 81     ................
     2a4:	81 7f 7e 7f 7e 7d 80 80 80 7f 7d 7c 7a 79 77 75     ..~.~}....}|zywu
     2b4:	76 75 76 77 79 7c 7f 83 83 82 82 82 83 81 82 83     vuvwy|..........
     2c4:	84 84 84 87 8b 8d 90 92 97 9a 9b 9b 9b 9a 95 8e     ................
     2d4:	86 81 7d 7a 75 72 70 71 71 70 71 74 77 7a 7e 81     ..}zurpqqpqtwz~.
     2e4:	84 85 86 86 85 85 85 85 86 89 8e 91 91 8f 8d 8c     ................
     2f4:	87 7f 77 6e 68 63 5f 5f 61 64 67 6b 6f 74 7b 84     ..wnhc__adgkot{.
     304:	88 87 84 81 81 83 85 85 85 85 85 86 87 88 87 85     ................
     314:	83 7f 7d 78 77 75 73 71 71 72 72 75 77 7b 80 82     ..}xwusqqrruw{..
     324:	84 85 87 87 84 81 7f 7e 80 83 86 8a 8b 8c 8d 8d     .......~........
     334:	8e 90 92 91 8c 87 84 84 82 7c 77 73 71 6f 6f 71     .........|wsqooq
     344:	75 77 74 71 70 72 75 75 77 7b 82 87 89 8c 8f 93     uwtqpruuw{......
     354:	94 91 8f 8c 87 82 7d 77 71 6c 68 64 62 62 62 66     ......}wqlhdbbbf
     364:	6c 72 77 78 7c 7f 7f 80 80 7f 7e 7f 80 81 7f 7d     lrwx|.....~....}
     374:	7b 7b 7a 77 76 77 78 79 7d 82 85 85 85 84 84 83     {{zwvwxy}.......
     384:	80 7c 78 77 77 75 72 6d 6c 6e 71 74 73 76 7c 83     .|xwwurmlnqtsv|.
     394:	8c 92 95 96 94 90 8b 87 82 7d 77 72 70 6f 6e 6e     .........}wrponn
     3a4:	6f 70 71 73 77 7c 7e 7f 80 80 7e 7d 7f 81 81 7d     opqsw|~...~}...}
     3b4:	79 78 78 79 79 7a 79 7b 80 83 84 80 7d 7c 7b 7b     yxxyyzy{....}|{{
     3c4:	7b 7d 7f 81 83 86 88 89 8a 88 88 8a 8c 8f 8f 8e     {}..............
     3d4:	8f 8e 8e 8d 8b 88 85 86 89 8a 8a 8b 8a 86 83 82     ................
     3e4:	82 81 7e 7b 79 78 7a 79 78 78 7b 7d 7e 81 85 8c     ..~{yxzyxx{}~...
     3f4:	8e 8c 8f 8f 8d 84 7d 7b 79 76 73 6f 6d 71 74 74     ......}{yvsomqtt
     404:	74 77 7b 7e 7d 7a 7e 82 82 81 80 83 84 84 84 87     tw{~}z~.........
     414:	8b 8f 90 8e 8b 89 86 82 7d 79 77 75 75 76 77 79     ........}ywuuvwy
     424:	7a 7b 7f 84 88 89 8a 8d 8f 91 94 97 99 98 98 99     z{..............
     434:	9a 98 92 8f 8d 8a 87 86 87 87 8a 88 86 85 86 89     ................
     444:	8a 8e 8f 8d 8b 8a 8b 8d 8e 8f 8f 92 95 96 94 8e     ................
     454:	89 84 7f 7c 7b 7b 7b 7b 79 78 7b 7d 7a 77 76 77     ...|{{{{yx{}zwvw
     464:	7a 7c 7d 80 86 89 89 89 88 87 85 80 7b 79 7b 7f     z|}.........{y{.
     474:	82 83 87 8a 8b 88 83 80 7e 7a 75 76 7b 80 85 8a     ........~zuv{...
     484:	90 95 96 94 90 8d 88 83 80 7e 7d 7f 7f 80 80 80     .........~}.....
     494:	81 80 80 82 83 86 8a 90 95 9b a0 a4 a3 a1 9d 99     ................
     4a4:	95 8e 85 7e 7b 7a 77 75 74 76 78 79 77 75 75 7a     ...~{zwutvxywuuz
     4b4:	80 82 84 8a 92 95 92 90 91 94 92 8e 88 83 80 7b     ...............{
     4c4:	76 73 71 6c 69 6a 6e 74 77 79 7e 87 8e 92 94 92     vsqlijntwy~.....
     4d4:	8f 8a 86 83 81 82 84 86 87 88 88 89 89 84 7d 78     ..............}x
     4e4:	77 79 77 73 6e 6c 6c 6d 70 78 82 8d 93 95 96 98     wywsnllmpx......
     4f4:	98 92 88 7e 7c 7d 7d 7c 7c 81 87 8a 88 85 84 85     ...~|}}||.......
     504:	82 7a 74 76 79 7a 7d 7f 82 88 8b 8d 8e 8f 8c 87     .ztvyz}.........
     514:	83 82 87 8a 87 81 7e 7e 80 81 81 81 83 86 8a 8c     ......~~........
     524:	8b 8a 87 83 7f 7c 76 73 72 76 7a 7a 7b 7e 85 89     .....|vsrvzz{~..
     534:	87 85 83 82 81 83 88 8b 89 86 87 89 8c 8d 8b 87     ................
     544:	87 8a 8c 8a 87 86 87 86 83 7f 7f 81 83 84 83 80     ................
     554:	7b 7b 7f 82 81 79 77 7e 85 84 80 7e 82 89 8d 90     {{...yw~...~....
     564:	90 8f 8d 8b 87 83 7e 78 72 71 70 6f 70 77 7d 7c     ......~xrqpopw}|
     574:	78 79 80 87 88 83 81 82 84 85 8a 8f 93 91 8d 8e     xy..............
     584:	92 92 89 7e 7a 7b 7b 7b 7b 79 77 77 7d 86 89 8d     ...~z{{{{yww}...
     594:	90 94 97 96 92 90 90 8c 86 80 80 86 8c 8e 8b 8b     ................
     5a4:	8e 8f 8e 8f 90 8e 89 86 89 90 92 90 8d 8b 90 8d     ................
     5b4:	85 83 81 88 7f 77 7e 87 91 8a 86 86 8a 8f 91 97     .....w~.........
     5c4:	97 95 91 8c 90 92 8c 7c 6d 6c 70 72 6d 67 65 67     .......|mlprmgeg
     5d4:	6a 6e 76 7b 7c 7d 7f 86 8b 87 80 79 78 79 72 6a     jnv{|}.....yxyrj
     5e4:	67 6a 6c 67 63 61 66 6c 6a 66 68 6d 74 77 77 7b     gjlgcafljfhmtww{
     5f4:	80 84 84 84 83 80 7d 7b 7c 7e 82 83 84 84 86 86     ......}{|~......
     604:	82 7d 7b 80 87 8e 91 93 9a a0 a3 a1 9c 97 93 90     .}{.............
     614:	8c 8a 8b 90 8e 87 82 83 88 83 79 73 77 80 87 8c     ..........ysw...
     624:	91 97 9e a2 a2 a5 a6 9f 93 8a 86 80 78 6d 65 65     ............xmee
     634:	6c 71 70 6d 6f 7a 86 8c 8f 94 99 9b 9c 9f a5 a4     lqpmoz..........
     644:	98 8c 8a 91 94 8e 82 7a 78 79 7b 7d 7e 78 71 71     .......zxy{}~xqq
     654:	7c 88 8d 85 7b 77 7c 81 7f 7b 77 76 77 77 75 78     |...{w|..{wvwwux
     664:	7f 84 85 83 84 8d 96 99 99 95 90 8d 8d 90 90 88     ................
     674:	7f 79 77 76 75 72 6d 6d 71 76 76 77 7f 8a 8e 87     .ywvurmmqvvw....
     684:	81 87 91 96 97 93 8f 8f 94 9c a0 9c 92 88 8a 94     ................
     694:	9c 9a 8f 84 80 82 84 81 7c 78 75 75 77 7a 7c 7b     ........|xuuwz|{
     6a4:	79 78 79 7f 86 88 89 8d 8f 8c 86 84 87 84 7d 75     yxy...........}u
     6b4:	72 75 78 7a 7c 7f 7f 7c 76 78 83 8c 8d 85 7f 82     ruxz|..|vx......
     6c4:	8b 8e 87 7f 7b 79 7b 7a 78 78 75 74 75 78 7d 7f     ....{y{zxxutux}.
     6d4:	7e 7d 7e 7e 7c 7c 7f 84 8a 8b 89 87 89 8b 8a 85     ~}~~||..........
     6e4:	7e 7a 79 7a 82 87 86 87 89 8c 8a 86 88 8e 91 8a     ~zyz............
     6f4:	82 81 83 86 87 85 7f 77 72 77 85 8c 88 84 85 91     .......wrw......
     704:	a0 a5 9d 8d 82 80 83 84 7d 79 7d 86 8a 89 87 88     ........}y}.....
     714:	8b 88 83 7f 80 83 84 88 90 96 98 95 92 93 93 91     ................
     724:	8f 8f 8d 87 83 84 8b 8f 89 80 7c 83 8f 97 93 88     ..........|.....
     734:	82 84 8c 92 8f 85 7a 7c 84 88 87 84 84 83 7f 82     ......z|........
     744:	89 8f 8a 82 7d 81 8a 8d 87 83 87 8d 8d 87 81 83     ....}...........
     754:	86 87 85 82 80 83 89 90 93 8e 85 85 8b 8e 8b 86     ................
     764:	84 86 88 87 87 87 84 80 82 88 8e 92 93 95 98 9a     ................
     774:	98 92 8c 85 7f 7b 7a 7a 79 79 7a 80 86 88 87 87     .....{zzyyz.....
     784:	88 90 98 99 91 88 87 8d 8e 89 87 88 89 88 8a 93     ................
     794:	9a 96 8b 83 85 8f 91 86 7a 7a 84 8a 82 7d 83 8b     ........zz...}..
     7a4:	8e 8c 8e 94 99 99 95 92 91 8c 86 80 80 84 8b 8f     ................
     7b4:	8d 8c 90 98 a0 a1 99 8e 90 97 97 8f 84 82 85 87     ................
     7c4:	85 80 80 83 86 81 74 73 81 8d 8a 7c 76 7f 88 87     ......ts...|v...
     7d4:	7d 76 76 79 7a 7d 81 83 7c 73 71 7a 81 7e 76 74     }vvyz}..|sqz.~vt
     7e4:	7c 80 80 84 8f 97 92 8a 8f 9c a2 9a 90 93 9e a4     |...............
     7f4:	9d 91 91 99 9b 8a 78 77 7e 83 81 7b 78 7a 82 8b     ......xw~..{xz..
     804:	8d 89 8c 95 97 92 8b 8d 91 8e 85 80 85 8c 8f 8c     ................
     814:	89 8d 94 95 92 8e 91 91 89 81 84 88 82 77 73 79     .............wsy
     824:	80 80 7e 81 85 85 85 8c 8d 80 7a 84 91 8c 7c 7b     ..~.......z...|{
     834:	8f a1 9f 91 8b 97 a5 9e 87 75 76 83 83 74 66 63     .........uv..tfc
     844:	6c 74 77 78 7b 7e 7c 7b 7d 88 90 8a 7b 71 73 7c     ltwx{~|{}...{qs|
     854:	7d 76 70 70 76 77 75 75 7a 7e 79 73 71 76 7a 79     }vppvwuuz~ysqvzy
     864:	7c 7e 78 6c 68 76 86 84 73 6c 78 8b 92 8e 8c 8f     |~xlhv..slx.....
     874:	94 93 8b 84 86 87 80 79 73 72 76 7b 81 85 7d 6e     .......ysrv{..}n
     884:	67 6c 79 83 7e 76 77 7d 85 8d 96 9a 8c 74 6a 7a     gly.~vw}.....tjz
     894:	93 97 89 7a 7a 85 92 9b 9a 94 8b 81 7e 7f 84 83     ...zz.......~...
     8a4:	79 6d 61 5b 60 6d 77 74 66 5d 6a 82 8c 85 7f 7f     yma[`mwtf]j.....
     8b4:	7b 78 7c 84 88 81 76 6e 72 7d 87 86 7a 71 6e 70     {x|...vnr}..zqnp
     8c4:	71 73 77 76 6f 6b 6f 74 7c 8b 98 98 8a 7f 88 9d     qswvokot|.......
     8d4:	a7 96 7e 71 70 77 81 8d 8f 83 75 72 82 99 a5 96     ..~qpw....ur....
     8e4:	79 65 6a 81 92 91 7f 6c 66 73 88 92 8e 86 81 7d     yej....lfs.....}
     8f4:	7f 8b a0 ad a1 88 79 82 95 9f 9a 89 76 70 7b 8f     ......y.....vp{.
     904:	9a 96 85 71 6a 7c 95 a0 97 84 78 78 87 9b a0 8f     ...qj|....xx....
     914:	76 6e 77 82 88 8a 8c 8a 88 8c 97 a4 ad aa 99 86     vnw.............
     924:	81 88 94 9b 92 7f 70 73 82 90 94 8a 81 7a 79 85     ......ps.....zy.
     934:	97 9a 81 62 58 6d 88 8d 7d 69 65 74 87 90 90 8c     ...bXm..}iet....
     944:	82 79 7c 8b 92 8a 81 7e 7a 70 6c 77 83 7c 65 55     .y|....~zplw.|eU
     954:	5c 74 84 7c 6b 66 6d 74 79 84 8f 89 75 6d 81 9f     \t.|kfmty...um..
     964:	a8 92 79 6f 7c 91 94 88 7b 73 74 7f 8b 8e 88 7e     ..yo|...{st....~
     974:	79 7c 7f 85 8f 92 84 6f 6f 89 a0 9d 88 7f 8a 95     y|.....oo.......
     984:	98 9b 9f 99 8a 7c 7d 91 a1 99 7d 63 63 7e 97 94     .....|}...}cc~..
     994:	7a 63 63 7b 97 9b 86 71 72 83 8f 93 95 95 91 81     zcc{...qr.......
     9a4:	76 85 9a 9d 87 66 57 60 76 86 81 6f 5c 5d 6d 7c     v....fW`v..o\]m|
     9b4:	84 87 81 6e 63 70 8c 9a 91 7a 6a 6f 87 9e 9c 8a     ...ncp...zjo....
     9c4:	75 6c 6d 7a 8e 91 78 5b 5a 77 8d 85 72 6a 6e 79     ulmz..x[Zw..rjny
     9d4:	81 84 8e 93 8b 79 72 87 9c 98 7f 6a 72 90 a1 96     .....yr....jr...
     9e4:	82 7d 8c 9d 9a 86 79 7c 83 7f 74 6a 70 7d 83 79     .}....y|..tjp}.y
     9f4:	6f 7e 96 9b 88 72 7a 97 a0 90 80 7f 88 8f 91 90     o~...rz.........
     a04:	8a 85 88 8f 90 8c 8b 8d 88 76 70 81 97 96 7c 66     .........vp...|f
     a14:	73 9a ae 9c 7c 71 86 a4 aa 95 7e 7b 89 8f 89 83     s...|q....~{....
     a24:	7f 7a 77 7d 87 85 76 6f 7b 88 87 73 5c 5d 75 8a     .zw}..vo{..s\]u.
     a34:	88 74 64 6d 86 93 88 7a 7d 85 82 78 7b 88 8a 7d     .tdm...z}..x{..}
     a44:	77 83 8f 91 8c 87 88 8d 8d 86 7e 80 88 7f 64 55     w.........~...dU
     a54:	67 82 84 6c 5f 6e 87 99 9a 90 8c 90 95 99 9f a9     g..l_n..........
     a64:	aa 9b 8b 92 a1 a0 8f 7e 7e 83 7e 73 6f 74 7d 83     .......~~.~sot}.
     a74:	7f 78 7a 83 85 83 80 7d 77 71 76 84 87 79 6d 71     .xz....}wqv..ymq
     a84:	84 96 99 8a 7a 7f 94 a0 95 84 81 86 84 7a 76 79     ....z........zvy
     a94:	79 74 72 71 6f 72 7d 85 82 79 7f 8d 8a 7d 7d 86     ytrqor}..y...}}.
     aa4:	89 7e 70 78 8e 98 8c 82 8b 97 94 8b 85 83 82 7e     .~px...........~
     ab4:	7a 75 6f 6c 71 78 79 77 75 73 79 88 92 8c 80 7d     zuolqxywusy....}
     ac4:	83 88 82 78 6b 64 6b 77 7c 76 6f 73 7c 7e 7d 85     ...xkdkw|vos|~}.
     ad4:	8c 83 71 70 80 8e 8a 80 77 73 72 73 77 7a 77 73     ..qp....wsrswzws
     ae4:	6f 6f 7b 8e 9b 98 8d 85 8e a9 bd b2 92 7c 82 9c     oo{..........|..
     af4:	ab 9c 80 6f 74 86 8b 83 7f 80 7d 73 6e 78 82 7c     ...ot.....}snx.|
     b04:	6f 67 69 71 7b 80 80 83 8c 90 8c 8c 98 a2 96 7b     ogiq{..........{
     b14:	74 87 96 8e 7a 6e 74 7f 7b 6b 63 6b 75 6f 60 68     t...znt.{kckuo`h
     b24:	81 8b 7b 69 6b 79 83 89 8e 8c 7f 7b 85 92 96 8a     ..{iky.....{....
     b34:	7d 77 77 7e 83 7f 71 66 6c 7e 8b 85 76 73 80 8d     }ww~..qfl~..vs..
     b44:	8d 83 79 78 81 85 7e 79 83 90 89 78 74 83 98 99     ..yx..~y...xt...
     b54:	8a 84 92 a2 9e 92 91 9b a1 95 85 82 86 87 7e 74     ..............~t
     b64:	71 77 81 85 7e 78 83 91 91 87 86 92 99 93 86 83     qw..~x..........
     b74:	8c 94 8c 78 6d 74 82 87 85 89 8b 86 7f 81 93 a5     ...xmt..........
     b84:	a4 94 8a 92 a1 a6 9a 86 7b 84 93 98 8f 81 80 8c     ........{.......
     b94:	94 8f 82 7c 7c 78 73 73 7a 7e 81 85 85 7f 7b 7f     ...||xssz~....{.
     ba4:	8b 98 96 88 7e 83 8f 95 91 8e 94 92 87 81 89 97     ....~...........
     bb4:	95 84 7e 87 90 90 83 72 71 82 90 8c 7b 6f 73 82     ..~....rq...{os.
     bc4:	93 9b 95 88 7b 77 81 8a 87 7c 6f 6c 77 88 90 8c     ....{w...|olw...
     bd4:	83 7e 87 99 a7 a7 9a 8e 95 a6 af a5 93 8c 8c 8f     .~..............
     be4:	93 95 8b 75 65 6a 7f 8b 82 72 70 80 93 93 89 87     ...uej...rp.....
     bf4:	8f 91 88 85 88 7e 71 6d 77 85 86 78 6d 6d 78 85     .....~qmw..xmmx.
     c04:	87 7d 75 7b 88 92 94 8d 84 83 8a 8a 80 70 6e 82     .}u{.........pn.
     c14:	91 87 72 6f 7f 88 83 80 84 86 7e 72 6e 72 7c 7b     ..ro......~rnr|{
     c24:	73 6b 68 6e 77 7c 80 82 81 7e 81 86 81 79 7a 81     skhnw|...~...yz.
     c34:	83 7b 76 79 7f 7f 7a 7e 89 8c 84 79 77 7d 82 82     .{vy..z~...yw}..
     c44:	7a 74 71 6e 73 7e 88 82 71 6d 77 7c 78 76 79 7e     ztqns~..qmw|xvy~
     c54:	80 82 83 82 8a 95 95 8a 82 87 8f 8b 83 84 8c 8f     ................
     c64:	85 77 73 75 7d 7d 73 6b 70 7a 81 88 8b 87 7f 7c     .wsu}}skpz.....|
     c74:	87 94 8e 7f 7d 8e 9e 98 85 77 73 79 7f 81 7d 74     ....}....wsy..}t
     c84:	72 7a 8b 9a 9c 93 88 85 87 89 88 86 7d 69 63 79     rz..........}icy
     c94:	91 89 6c 63 77 87 86 7a 73 79 81 85 87 88 8d 92     ..lcw..zsy......
     ca4:	8b 7f 7f 88 8d 87 77 77 87 8f 8f 84 81 87 8b 8a     ......ww........
     cb4:	81 74 70 83 9d a2 91 84 91 a5 a8 9a 8d 87 7f 71     .tp............q
     cc4:	6e 7c 89 87 75 6b 80 a3 af 99 86 8f a7 ae 9a 83     n|..uk..........
     cd4:	81 91 9c 94 7e 6e 70 80 90 8c 7a 6d 6e 7e 8c 8a     ....~np...zmn~..
     ce4:	7f 77 7c 88 93 95 90 8a 86 89 94 96 8a 7f 7a 80     .w|...........z.
     cf4:	90 9a 92 7d 69 6f 87 93 88 70 69 7c 92 8d 76 6c     ...}io...pi|..vl
     d04:	7c 92 8e 78 72 83 96 97 88 7b 80 8c 91 86 7d 7f     |..xr....{....}.
     d14:	80 80 7f 7d 7b 78 71 6c 69 6e 7b 7f 73 6d 7a 8d     ...}{xqlin{.smz.
     d24:	92 8a 7f 80 8c 93 8f 84 7e 8c 98 8b 6e 63 75 95     ........~...ncu.
     d34:	9b 7f 6a 6e 82 8f 83 72 71 7d 86 7c 76 85 97 93     ..jn...rq}.|v...
     d44:	7e 72 79 85 84 74 6b 6e 76 79 7a 80 85 8a 89 80     ~ry..tknvyz.....
     d54:	79 7b 88 89 7c 6f 73 85 95 98 92 8f 8f 95 a2 a6     y{..|os.........
     d64:	9b 8d 8d 93 8e 85 8a 91 89 74 69 73 83 88 80 74     .........tis...t
     d74:	72 79 88 8e 89 86 88 88 8b 95 98 87 7b 85 96 97     ry..........{...
     d84:	83 74 73 79 81 85 7a 64 58 69 88 8e 75 56 53 6f     .tsy..zdXi..uVSo
     d94:	85 81 71 6e 76 7f 88 93 96 8a 7a 76 84 98 9f 92     ..qnv.....zv....
     da4:	80 80 93 9f 91 7d 7d 8b 8f 7b 65 6c 83 8a 7c 6d     .....}}..{el..|m
     db4:	6f 76 78 7e 8f 99 8c 77 79 97 b2 b0 9c 8a 8e a3     ovx~...wy.......
     dc4:	ab a0 96 92 93 8e 82 82 91 9b 92 81 76 73 77 7d     ............vsw}
     dd4:	7c 75 6d 67 6b 75 80 89 8e 8a 87 98 ad b1 a1 8f     |umgku..........
     de4:	8b 8d 87 7c 79 7e 81 75 5c 4e 5f 7f 83 63 49 5e     ...|y~.u\N_..cI^
     df4:	84 8b 7e 80 94 9c 88 76 8b ab a8 82 64 66 80 90     ..~....v....df..
     e04:	86 7c 80 89 86 7f 80 8e 93 83 6a 5d 64 77 83 77     .|........j]dw.w
     e14:	5c 50 61 7a 85 82 7a 71 6a 6e 83 98 98 86 77 78     \Paz..zqjn....wx
     e24:	8c 9a 97 91 92 95 8c 78 70 80 98 94 77 56 52 80     .......xp...wVR.
     e34:	b5 be 8b 4e 4b 7f a3 96 74 5f 65 6c 75 8d ad ac     ...NK...t_elu...
     e44:	81 58 64 a2 cc b2 72 50 69 94 a0 8c 74 71 7e 86     .Xd...rPi...tq~.
     e54:	8d 9d a1 8f 77 78 90 9f 8d 77 71 75 79 79 85 8a     ....wx...wquyy..
     e64:	7f 73 81 a0 a6 96 84 86 95 9d 96 86 75 6c 7e 8f     .s..........ul~.
     e74:	88 70 5f 61 72 7f 7b 78 78 7b 7d 85 91 9e 9d 87     .p_ar.{xx{}.....
     e84:	73 7a 9e b5 a9 85 71 7b 92 a1 93 75 63 76 99 a9     sz....q{...ucv..
     e94:	90 72 73 8a 94 88 7e 86 93 8a 77 73 8c a1 95 75     .rs...~...ws...u
     ea4:	68 85 a7 ae 93 7b 87 aa b4 9e 8a 8f a3 a3 92 89     h....{..........
     eb4:	90 92 89 7b 7a 86 8e 8d 7d 73 72 7c 84 8a 8a 85     ...{z...}sr|....
     ec4:	82 82 88 8c 8b 94 9d 9a 93 93 9d a6 9d 82 6c 72     ..............lr
     ed4:	7d 7c 72 6a 72 80 7e 7c 88 9f ad a3 8d 87 95 a1     }|rjr.~|........
     ee4:	9d 8d 85 89 88 87 8f 9f 9f 8b 75 75 8c a3 9d 79     ..........uu...y
     ef4:	5c 5b 77 91 90 77 67 71 85 95 9b 9c 92 7f 70 71     \[w..wgq......pq
     f04:	88 a0 9d 7c 66 73 93 a3 98 8e 8d 89 82 84 8f 8e     ...|fs..........
     f14:	7c 6b 65 65 6d 7e 83 6e 53 55 71 85 82 74 68 64     |keem~.nSUq..thd
     f24:	68 6f 75 7a 7a 7a 7c 7e 8d a4 ac 96 76 73 88 90     houzzz|~....vs..
     f34:	81 6e 6c 70 70 73 7c 7f 76 70 7c 8c 8a 82 88 95     .nlpps|.vp|.....
     f44:	96 88 7c 89 9c a0 97 8e 93 a2 a4 96 8e 8f 92 8d     ..|.............
     f54:	85 84 87 81 70 68 70 76 75 72 6f 70 6f 72 86 95     ....phpvuropor..
     f64:	8e 84 88 9b a9 a1 91 8f 9d a4 9f 95 91 90 8e 8f     ................
     f74:	96 95 86 75 70 77 7a 73 70 75 7f 86 82 7c 7e 85     ...upwzspu...|~.
     f84:	8a 84 7e 88 95 95 88 81 8b 97 96 88 82 87 86 82     ..~.............
     f94:	84 8c 92 8e 84 7c 7a 82 8b 8c 7a 6a 6f 85 9f a4     .....|z...zjo...
     fa4:	8e 7e 86 9c a5 95 83 80 81 82 87 94 9a 94 88 81     .~..............
     fb4:	8b 97 9c 97 86 7a 80 88 85 77 66 63 6d 78 7c 7c     .....z...wfcmx||
     fc4:	7e 81 86 8a 89 8b 89 88 8d 92 9a a3 9f 91 84 84     ~...............
     fd4:	97 a3 96 7f 74 7b 88 86 75 68 68 75 82 7e 78 7a     ....t{..uhhu.~xz
     fe4:	84 8d 8c 88 83 85 8f 97 90 8a 90 95 93 8a 80 82     ................
     ff4:	85 82 84 8a 82 70 69 72 7d 7a 6a 5c 58 63 75 7f     .....pir}zj\Xcu.
    1004:	7e 76 70 71 72 77 81 83 75 69 71 81 88 7c 70 75     ~vpqrw..uiq..|pu
    1014:	80 83 80 85 89 81 74 71 75 7b 75 6c 6f 75 82 8f     ......tqu{ulou..
    1024:	95 92 8e 8e 8c 8d 8e 8e 8c 84 84 84 7c 7c 87 97     ............||..
    1034:	9b 8f 8b 99 a5 9f 8d 86 93 9a 8b 7a 74 85 98 92     ...........zt...
    1044:	80 7a 88 9c a0 95 8e 91 93 8c 85 86 88 7c 6e 71     .z...........|nq
    1054:	7e 88 87 7c 77 77 7b 87 8b 82 76 78 86 8c 86 79     ~..|ww{...vx...y
    1064:	74 7b 80 81 7a 76 7c 84 84 7a 71 75 80 86 87 7c     t{..zv|..zqu...|
    1074:	75 79 7f 85 81 7f 84 89 89 84 80 83 88 8c 84 7d     uy.............}
    1084:	81 8d 91 8a 88 8e 99 92 82 7e 88 8d 83 71 6b 79     .........~...qky
    1094:	86 83 7a 74 7c 8a 92 90 8b 90 9c a3 9d 93 90 8f     ..zt|...........
    10a4:	90 8e 83 82 88 8b 8b 8b 8c 8b 88 84 86 8c 88 7e     ...............~
    10b4:	78 7d 8a 95 90 88 8e 97 99 95 90 91 94 94 94 93     x}..............
    10c4:	8f 89 86 85 81 76 69 63 6b 78 7b 79 7a 85 90 94     .....vickx{yz...
    10d4:	91 8a 86 81 83 86 88 87 82 81 8a 8e 85 7c 78 7d     .............|x}
    10e4:	8a 96 98 93 92 9a a2 a0 97 88 7e 7a 74 6c 65 62     ..........~ztleb
    10f4:	62 62 5f 61 69 6f 6e 6d 6b 6d 6d 65 5d 5d 63 64     bb_aionmkmme]]cd
    1104:	5d 5a 60 68 64 59 53 59 64 6a 6a 68 69 71 79 7d     ]Z`hdYSYdjjhiqy}
    1114:	80 83 86 86 88 8a 8d 8f 8d 8d 8e 8e 8e 8d 8b 87     ................
    1124:	82 7c 79 77 74 72 77 7e 86 88 85 88 93 9a 9a 94     .|ywtrw~........
    1134:	8f 8f 8e 87 7e 79 79 7c 7b 76 72 72 72 6e 6a 6a     ....~yy|{vrrrnjj
    1144:	6b 67 61 60 66 6d 70 71 73 77 7f 85 8d 8e 86 80     kga`fmpqsw......
    1154:	7f 7e 7a 73 6a 67 69 6f 73 72 71 75 7b 7d 7c 7d     .~zsjgiosrqu{}|}
    1164:	81 80 7a 74 76 7d 80 7e 7b 7a 7e 84 88 8a 8d 92     ..ztv}.~{z~.....
    1174:	99 9d 9e 9f a1 a1 9c 9a 9b 9a 97 91 8c 89 85 80     ................
    1184:	7c 79 74 70 70 70 6d 6e 72 78 7d 80 84 8c 97 9b     |ytpppmnrx}.....
    1194:	9a 99 98 98 98 95 93 8f 8a 8a 8d 90 92 90 8a 85     ................
    11a4:	84 85 80 78 71 70 70 70 77 79 78 78 7e 85 87 85     ...xqpppwyxx~...
    11b4:	82 83 83 84 83 81 85 86 87 8a 8c 90 91 92 93 95     ................
    11c4:	93 8e 8d 91 96 91 84 7a 79 7f 7e 78 75 74 75 77     .......zy.~xutuw
    11d4:	7a 7e 81 83 84 83 85 86 85 82 81 82 82 7f 7d 7d     z~............}}
    11e4:	7e 7c 76 73 72 71 6d 68 64 5e 5b 5e 63 67 69 6c     ~|vsrqmhd^[^cgil
    11f4:	70 76 7e 84 86 88 8a 8b 8d 8c 8c 87 82 7d 76 70     pv~..........}vp
    1204:	6c 6a 68 65 62 5e 5d 61 65 69 6c 6e 6d 6d 6e 70     ljheb^]aeilnmmnp
    1214:	72 70 6e 70 74 7c 83 85 88 8b 8f 90 90 90 90 8f     rpnpt|..........
    1224:	8c 88 86 82 7d 7a 78 76 74 72 73 74 75 76 76 76     ....}zxvtrstuvvv
    1234:	77 79 79 7a 7c 7f 7f 7f 7c 79 79 7b 7d 7f 81 84     wyyz|...|yy{}...
    1244:	87 88 8a 8b 8a 86 7c 75 72 70 6f 6e 6b 6c 6d 6e     ......|urponklmn
    1254:	71 73 73 76 79 7b 7d 7f 7f 7f 7f 7e 7d 7e 81 82     qssvy{}....~}~..
    1264:	85 88 8a 89 87 83 82 80 7f 7c 77 74 73 74 71 6e     .........|wtstqn
    1274:	6c 6d 6e 71 76 7b 80 85 8a 8d 8d 8d 8c 89 86 81     lmnqv{..........
    1284:	7e 7b 79 78 7a 7e 81 82 82 81 7f 7c 77 75 74 73     ~{yxz~.....|wuts
    1294:	72 75 78 7e 82 86 8e 96 9d a1 a3 a3 a2 a0 9c 97     rux~............
    12a4:	94 91 8d 87 84 85 87 8a 8a 8b 8c 8c 8b 8c 8e 90     ................
    12b4:	93 93 91 91 91 8f 8f 92 93 95 97 9d a2 a3 a3 a4     ................
    12c4:	a3 9f 98 91 8a 83 7d 7a 77 74 75 7a 7f 83 83 84     ......}zwtuz....
    12d4:	85 85 84 85 89 8e 95 9a 9f a3 a2 a0 99 8f 88 82     ................
    12e4:	7c 76 73 74 79 7f 83 88 8d 8f 90 90 8e 8d 89 83     |vsty...........
    12f4:	7e 78 76 73 6f 6f 71 74 76 79 7d 7e 7f 7f 7d 7b     ~xvsooqtvy}~..}{
    1304:	76 72 71 70 6f 6e 72 77 7b 7d 79 78 78 76 73 6f     vrqponrw{}yxxvso
    1314:	6c 6c 6c 6a 66 62 61 5f 5e 61 67 6d 72 77 7c 82     llljfba_^agmrw|.
    1324:	83 81 7f 7c 7a 79 79 77 74 74 73 72 71 6d 6b 69     ...|zyywttsrqmki
    1334:	67 66 65 66 68 65 64 65 68 69 68 69 6b 6d 6d 6d     gfefhedehihikmmm
    1344:	70 73 74 72 70 70 70 6c 69 6b 6e 6f 6b 68 69 6b     pstrpppliknokhik
    1354:	6b 68 66 63 65 65 61 60 63 66 6a 6c 6e 76 81 87     khfceea`cfjlnv..
    1364:	89 88 88 8b 8b 8a 8a 8c 90 94 98 9c a3 a8 aa ac     ................
    1374:	ac ad ae ae ae b3 b8 be c3 c6 c9 cd d0 cf cc c8     ................
    1384:	c4 c2 c3 c2 c2 c2 c4 c7 c8 cb ce d3 d3 d3 d5 d4     ................
    1394:	d3 cf cb ca c9 c7 c5 c5 c4 c3 c0 bc b9 b5 b2 af     ................
    13a4:	aa a8 a6 a4 a3 a3 a7 aa ac af b4 b9 bb b9 b6 b4     ................
    13b4:	b1 ab a7 a3 9f 9a 96 90 8d 8b 8a 87 86 86 85 84     ................
    13c4:	83 83 86 89 89 8a 8d 8f 8f 8d 8b 8a 87 82 7c 76     ..............|v
    13d4:	71 6b 63 5e 59 53 4e 4d 4b 4a 45 41 41 3e 3a 34     qkc^YSNMKJEAA>:4
    13e4:	30 30 2f 2b 27 25 23 1f 18 15 13 11 10 0e 0d 0f     00/+'%#.........
    13f4:	13 14 0f 09 03 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1410:	00 00 00 01 01 01 02 00 18 51 8e d3 fc fe fe fe     .........Q......
    1420:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1430:	ff ff fe ff f7 d6 bc a5 94 86 79 6d 66 63 63 64     ..........ymfccd
    1440:	64 63 64 64 5f 54 46 35 21 0a 00 00 00 00 00 00     dcdd_TF5!.......
	...
    1458:	00 01 00 02 00 0a 35 5f 88 b0 d7 f8 ff fe ff ff     ......5_........
    1468:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1478:	ff ff ff ff ff ff ff ff ff ff ff fe ff f6 e1 d0     ................
    1488:	bf ab 94 7b 61 48 30 17 04 00 01 00 01 00 00 00     ...{aH0.........
    1498:	01 11 27 3d 55 6d 89 a4 c1 dc f4 ff fe ff ff ff     ..'=Um..........
    14a8:	ff ff ff ff ff ff ff ff ff ff ff ff f3 e8 e5 e5     ................
    14b8:	e5 e7 ea ee f1 f1 f0 f0 ee ed ea e7 e4 de d4 c8     ................
    14c8:	bd b1 a3 94 84 74 67 5d 56 51 4d 4c 4a 46 46 47     .....tg]VQMLJFFG
    14d8:	49 4b 4f 54 5c 65 6d 75 7e 87 8d 90 91 91 92 92     IKOT\emu~.......
    14e8:	91 8d 89 87 81 77 6b 5b 4b 39 27 16 05 00 00 00     .....wk[K9'.....
	...
    1518:	00 01 01 02 00 03 00 12 66 c6 fe fe fe fe fe fe     ........f.......
    1528:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff fd ff     ................
    1538:	f1 b5 81 57 38 21 12 09 06 08 10 1c 29 34 40 4d     ...W8!......)4@M
    1548:	55 59 57 4f 41 2e 15 02 00 00 00 00 00 00 00 00     UYWOA...........
    1558:	00 00 00 00 00 00 01 01 02 00 06 37 71 a4 dc fe     ...........7q...
    1568:	fe fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1578:	ff ff ff ff fe ef e2 d7 ce c6 bf bb ba bb ba b9     ................
    1588:	b6 b3 ad a2 98 89 73 57 38 17 02 00 00 00 00 00     ......sW8.......
    1598:	00 00 00 00 00 00 00 01 01 01 1d 46 6d 97 bc e3     ...........Fm...
    15a8:	fd fe fe ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15c8:	fe ff f8 e5 d0 b8 a2 8d 77 5f 47 31 23 17 0c 05     ........w_G1#...
    15d8:	01 00 02 0c 17 22 33 47 5c 71 87 98 ab ba c5 cd     ....."3G\q......
    15e8:	ce cd ca c6 c1 bb b6 b2 af ae ab ab aa a9 a9 aa     ................
    15f8:	ad ae ae b0 b3 b6 b7 b7 b5 b0 a9 a0 93 85 74 60     ..............t`
    1608:	4a 33 1c 07 00 00 00 00 00 00 00 00 00 00 00 00     J3..............
	...
    1630:	00 01 01 01 00 03 00 33 ae fa ff fe fe fe fe ff     .......3........
    1640:	ff ff ff ff ff ff ff ff ff ff fe fe fe fe fc c2     ................
    1650:	78 3c 0a 00 02 01 02 01 00 01 00 08 25 3a 4c 58     x<..........%:LX
    1660:	5c 56 45 2b 0c 00 00 00 00 00 00 00 00 00 00 00     \VE+............
    1670:	00 00 00 00 02 01 02 00 06 48 9a e7 ff fc ff fd     .........H......
    1680:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1690:	ff ff ff ff ff ff ff ff fc fa f9 f7 f1 e8 da c8     ................
    16a0:	b2 95 74 50 25 03 00 01 00 00 00 00 00 00 00 00     ..tP%...........
    16b0:	00 00 00 01 01 01 01 01 29 5e 8e bf ef ff fd fe     ........)^......
    16c0:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16e0:	ff fe ff f8 e1 ce ba a4 8e 79 65 53 43 36 2d 29     .........yeSC6-)
    16f0:	27 25 26 29 2e 36 3e 48 55 67 7c 93 aa c1 d5 e8     '%&).6>HUg|.....
    1700:	f7 fe ff ff ff ff fb f0 e8 de d4 cc c3 ba b2 ad     ................
    1710:	a9 a4 a0 9d 98 94 93 90 8d 8a 88 85 81 7d 77 72     .............}wr
    1720:	6b 63 59 4e 41 32 24 17 08 00 00 00 00 00 00 00     kcYNA2$.........
	...
    1750:	00 01 01 02 00 02 00 0e 8b f6 fe fe fe fe fe fe     ................
    1760:	ff ff ff ff ff ff ff ff ff ff ff fe fe fe fe ff     ................
    1770:	d3 93 64 3e 25 15 0d 08 0d 1d 31 46 57 62 67 66     ..d>%.....1FWbgf
    1780:	57 3f 19 00 00 00 00 00 00 00 00 00 00 00 00 00     W?..............
    1790:	00 00 00 01 00 02 00 08 49 8d ce fc fe fe fe fe     ........I.......
    17a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17b0:	ff ff ff ff ff ff ff ff ff fe ff f7 d6 b5 92 6a     ...............j
    17c0:	44 19 00 01 00 01 00 00 00 00 00 00 00 00 00 00     D...............
    17d0:	00 00 00 00 00 01 00 07 24 3f 5f 81 a0 c0 df fa     ........$?_.....
    17e0:	ff fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17f0:	ff ff ff ff ff ff ff ff fe ff f7 db c7 b5 a8 9e     ................
    1800:	97 95 95 97 9c a2 a5 a6 a6 a5 a6 a2 9b 97 94 91     ................
    1810:	8d 87 7e 77 6f 66 60 5c 5a 5b 5d 62 6c 77 82 8d     ..~wof`\Z[]blw..
    1820:	98 a3 ae b8 c2 cd d6 dc e0 e3 e3 e3 e2 df dd d9     ................
    1830:	d4 d0 cc ca c7 c4 c0 be bb b6 b2 ae aa a6 a3 a0     ................
    1840:	9f 9c 97 91 8a 81 75 67 58 47 36 22 0f 01 00 00     ......ugXG6"....
	...
    1874:	01 01 02 00 04 00 31 c7 ff fc ff fd fe fe ff ff     ......1.........
    1884:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1894:	fe e5 d2 c8 c1 bb b7 b7 b7 b7 b0 a2 89 67 3c 0d     .............g<.
    18a4:	00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18b4:	00 00 01 01 02 00 21 5c 8d bc e9 ff fd fe fe ff     ......!\........
    18c4:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    18d4:	ff ff ff ff ff ff fe ff fe fe fc d8 ac 81 53 26     ..............S&
    18e4:	04 01 01 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
    18f4:	00 00 00 00 00 00 01 00 02 00 0a 2e 52 79 a0 c5     ............Ry..
    1904:	ea fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1914:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1924:	ff ff ff ff fe ff f4 db c7 b1 99 81 6d 5b 4b 40     ............m[K@
    1934:	39 35 36 37 38 3e 46 4f 57 60 6a 76 80 86 89 8c     95678>FOW`jv....
    1944:	8d 8c 8a 84 7d 77 72 6e 6b 6c 70 79 84 8d 99 a7     ....}wrnklpy....
    1954:	b5 c3 cf dc e7 ed f1 f3 f2 f0 ea e0 d3 c3 b2 a0     ................
    1964:	8f 7d 6c 61 59 55 53 54 55 57 58 55 51 4b 43 3d     .}laYUSTUWXUQKC=
    1974:	36 2b 20 11 04 00 00 00 00 00 00 00 00 00 00 00     6+ .............
	...
    1998:	00 01 01 01 01 01 01 07 87 fb fd ff fe fe fe fe     ................
    19a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    19b8:	ff ff ff ff ff ff ff ff fe fe fd ff f9 ca 91 52     ...............R
    19c8:	10 00 02 01 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    19e0:	01 00 0b 2f 4c 65 79 89 99 aa bf d9 f7 ff fe ff     .../Ley.........
    19f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a00:	ff ff ff ff ff fe ff f4 dd c8 b0 96 7b 61 46 2c     ............{aF,
    1a10:	0f 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1a20:	00 00 01 00 01 00 08 33 57 72 86 94 9f a7 ab ad     .......3Wr......
    1a30:	b1 b7 be c8 d3 e0 f0 fe ff ff ff ff ff ff ff ff     ................
    1a40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a50:	ff ff ff ff ff ff ff fc ed e0 d4 c7 ba aa 9b 89     ................
    1a60:	77 68 59 4c 42 39 31 2a 25 21 1d 1d 1d 1d 1d 1d     whYLB91*%!......
    1a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4250:	1d 1d 1d 1d                                         ....

00004254 <__ctors_end>:
    4254:	11 24       	eor	r1, r1
    4256:	1f be       	out	0x3f, r1	; 63
    4258:	cf e5       	ldi	r28, 0x5F	; 95
    425a:	d8 e0       	ldi	r29, 0x08	; 8
    425c:	de bf       	out	0x3e, r29	; 62
    425e:	cd bf       	out	0x3d, r28	; 61

00004260 <__do_copy_data>:
    4260:	10 e0       	ldi	r17, 0x00	; 0
    4262:	a0 e6       	ldi	r26, 0x60	; 96
    4264:	b0 e0       	ldi	r27, 0x00	; 0
    4266:	e0 ed       	ldi	r30, 0xD0	; 208
    4268:	f6 e6       	ldi	r31, 0x66	; 102
    426a:	02 c0       	rjmp	.+4      	; 0x4270 <__do_copy_data+0x10>
    426c:	05 90       	lpm	r0, Z+
    426e:	0d 92       	st	X+, r0
    4270:	aa 3c       	cpi	r26, 0xCA	; 202
    4272:	b1 07       	cpc	r27, r17
    4274:	d9 f7       	brne	.-10     	; 0x426c <__do_copy_data+0xc>

00004276 <__do_clear_bss>:
    4276:	17 e0       	ldi	r17, 0x07	; 7
    4278:	aa ec       	ldi	r26, 0xCA	; 202
    427a:	b0 e0       	ldi	r27, 0x00	; 0
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <.do_clear_bss_start>

0000427e <.do_clear_bss_loop>:
    427e:	1d 92       	st	X+, r1

00004280 <.do_clear_bss_start>:
    4280:	a2 36       	cpi	r26, 0x62	; 98
    4282:	b1 07       	cpc	r27, r17
    4284:	e1 f7       	brne	.-8      	; 0x427e <.do_clear_bss_loop>
    4286:	0e 94 df 23 	call	0x47be	; 0x47be <main>
    428a:	0c 94 66 33 	jmp	0x66cc	; 0x66cc <_exit>

0000428e <__bad_interrupt>:
    428e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00004292 <vMainGameTask>:
		vTaskDelay(1);		
	}	
}


void vMainGameTask(void *pvParameters){
    4292:	8f 92       	push	r8
    4294:	9f 92       	push	r9
    4296:	af 92       	push	r10
    4298:	bf 92       	push	r11
    429a:	cf 92       	push	r12
    429c:	df 92       	push	r13
    429e:	ef 92       	push	r14
    42a0:	ff 92       	push	r15
    42a2:	0f 93       	push	r16
    42a4:	1f 93       	push	r17
    42a6:	cf 93       	push	r28
    42a8:	df 93       	push	r29
    second = 0;
    42aa:	10 92 cd 00 	sts	0x00CD, r1
    42ae:	10 92 cc 00 	sts	0x00CC, r1
	current_state = STARTSCREEN;
    42b2:	10 92 b8 00 	sts	0x00B8, r1
    42b6:	10 92 b7 00 	sts	0x00B7, r1
	int firstloading = 1;
    42ba:	c1 e0       	ldi	r28, 0x01	; 1
    42bc:	d0 e0       	ldi	r29, 0x00	; 0
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
				led_current_state = LED_STOP;
    42be:	34 e0       	ldi	r19, 0x04	; 4
    42c0:	e3 2e       	mov	r14, r19
    42c2:	f1 2c       	mov	r15, r1
				current_lcd_state = LCD_WRITE;
    42c4:	22 e0       	ldi	r18, 0x02	; 2
    42c6:	c2 2e       	mov	r12, r18
    42c8:	d1 2c       	mov	r13, r1
				current_state = RESULT;
    42ca:	93 e0       	ldi	r25, 0x03	; 3
    42cc:	a9 2e       	mov	r10, r25
    42ce:	b1 2c       	mov	r11, r1
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    42d0:	01 e0       	ldi	r16, 0x01	; 1
    42d2:	10 e0       	ldi	r17, 0x00	; 0
			}else{
				set_mode(SLOW_MODE);
				led_current_state = LED_STOP;
			}
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
    42d4:	8d ed       	ldi	r24, 0xDD	; 221
    42d6:	88 2e       	mov	r8, r24
    42d8:	91 2c       	mov	r9, r1
    second = 0;
	current_state = STARTSCREEN;
	int firstloading = 1;
	
	while(1){
		if(current_state == STARTSCREEN){
    42da:	80 91 b7 00 	lds	r24, 0x00B7
    42de:	90 91 b8 00 	lds	r25, 0x00B8
    42e2:	00 97       	sbiw	r24, 0x00	; 0
    42e4:	81 f4       	brne	.+32     	; 0x4306 <vMainGameTask+0x74>
			if(firstloading){
    42e6:	20 97       	sbiw	r28, 0x00	; 0
    42e8:	09 f4       	brne	.+2      	; 0x42ec <vMainGameTask+0x5a>
    42ea:	93 c0       	rjmp	.+294    	; 0x4412 <vMainGameTask+0x180>
				led_current_state = LED_START;
    42ec:	10 93 cf 00 	sts	0x00CF, r17
    42f0:	00 93 ce 00 	sts	0x00CE, r16
				current_lcd_state = LCD_START;
    42f4:	10 93 ba 00 	sts	0x00BA, r17
    42f8:	00 93 b9 00 	sts	0x00B9, r16
				firstloading = 0;
				second = 0;
    42fc:	10 92 cd 00 	sts	0x00CD, r1
    4300:	10 92 cc 00 	sts	0x00CC, r1
    4304:	84 c0       	rjmp	.+264    	; 0x440e <vMainGameTask+0x17c>
			}
		}else if(current_state == LOADING){
    4306:	81 30       	cpi	r24, 0x01	; 1
    4308:	91 05       	cpc	r25, r1
    430a:	39 f5       	brne	.+78     	; 0x435a <vMainGameTask+0xc8>
			if(firstloading){
    430c:	20 97       	sbiw	r28, 0x00	; 0
    430e:	61 f0       	breq	.+24     	; 0x4328 <vMainGameTask+0x96>
				led_current_state = LED_START;
    4310:	90 93 cf 00 	sts	0x00CF, r25
    4314:	80 93 ce 00 	sts	0x00CE, r24
				current_lcd_state = LCD_START;
    4318:	90 93 ba 00 	sts	0x00BA, r25
    431c:	80 93 b9 00 	sts	0x00B9, r24
				firstloading = 0;
				second = 0;
    4320:	10 92 cd 00 	sts	0x00CD, r1
    4324:	10 92 cc 00 	sts	0x00CC, r1
			}

			if(second > LOADING_INTERVAL){
    4328:	80 91 cc 00 	lds	r24, 0x00CC
    432c:	90 91 cd 00 	lds	r25, 0x00CD
    4330:	8b 30       	cpi	r24, 0x0B	; 11
    4332:	91 05       	cpc	r25, r1
    4334:	0c f4       	brge	.+2      	; 0x4338 <vMainGameTask+0xa6>
    4336:	6b c0       	rjmp	.+214    	; 0x440e <vMainGameTask+0x17c>
				second = 0;
    4338:	10 92 cd 00 	sts	0x00CD, r1
    433c:	10 92 cc 00 	sts	0x00CC, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    4340:	f0 92 cf 00 	sts	0x00CF, r15
    4344:	e0 92 ce 00 	sts	0x00CE, r14
				current_lcd_state = LCD_EMPTY;
    4348:	b0 92 ba 00 	sts	0x00BA, r11
    434c:	a0 92 b9 00 	sts	0x00B9, r10
				current_state = GAME;
    4350:	d0 92 b8 00 	sts	0x00B8, r13
    4354:	c0 92 b7 00 	sts	0x00B7, r12
    4358:	57 c0       	rjmp	.+174    	; 0x4408 <vMainGameTask+0x176>
			}
		}else if(current_state == GAME){
    435a:	82 30       	cpi	r24, 0x02	; 2
    435c:	91 05       	cpc	r25, r1
    435e:	09 f0       	breq	.+2      	; 0x4362 <vMainGameTask+0xd0>
    4360:	58 c0       	rjmp	.+176    	; 0x4412 <vMainGameTask+0x180>
			current_lcd_state = LCD_WRITE;
    4362:	90 93 ba 00 	sts	0x00BA, r25
    4366:	80 93 b9 00 	sts	0x00B9, r24
			if(firstloading){
    436a:	20 97       	sbiw	r28, 0x00	; 0
    436c:	31 f0       	breq	.+12     	; 0x437a <vMainGameTask+0xe8>
				init_game();
    436e:	0e 94 4d 30 	call	0x609a	; 0x609a <init_game>
				firstloading = 0;
				second = 0;
    4372:	10 92 cd 00 	sts	0x00CD, r1
    4376:	10 92 cc 00 	sts	0x00CC, r1
			}

			//switchinput = PORTD;
			update_game();
    437a:	0e 94 b8 30 	call	0x6170	; 0x6170 <update_game>
			
			if (global_sonar_cm<10){
    437e:	80 91 ca 00 	lds	r24, 0x00CA
    4382:	90 91 cb 00 	lds	r25, 0x00CB
    4386:	8a 30       	cpi	r24, 0x0A	; 10
    4388:	91 05       	cpc	r25, r1
    438a:	4c f4       	brge	.+18     	; 0x439e <vMainGameTask+0x10c>
				set_mode(FAST_MODE);
    438c:	82 e0       	ldi	r24, 0x02	; 2
    438e:	90 e0       	ldi	r25, 0x00	; 0
    4390:	0e 94 c3 31 	call	0x6386	; 0x6386 <set_mode>
				led_current_state = LED_START;
    4394:	10 93 cf 00 	sts	0x00CF, r17
    4398:	00 93 ce 00 	sts	0x00CE, r16
    439c:	08 c0       	rjmp	.+16     	; 0x43ae <vMainGameTask+0x11c>
			}else{
				set_mode(SLOW_MODE);
    439e:	81 e0       	ldi	r24, 0x01	; 1
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	0e 94 c3 31 	call	0x6386	; 0x6386 <set_mode>
				led_current_state = LED_STOP;
    43a6:	f0 92 cf 00 	sts	0x00CF, r15
    43aa:	e0 92 ce 00 	sts	0x00CE, r14
			}
			if(!firstsrand){
    43ae:	80 91 d0 00 	lds	r24, 0x00D0
    43b2:	90 91 d1 00 	lds	r25, 0x00D1
    43b6:	00 97       	sbiw	r24, 0x00	; 0
    43b8:	91 f4       	brne	.+36     	; 0x43de <vMainGameTask+0x14c>
				srand(global_sonar_cm*17*13);
    43ba:	80 91 ca 00 	lds	r24, 0x00CA
    43be:	90 91 cb 00 	lds	r25, 0x00CB
    43c2:	9c 01       	movw	r18, r24
    43c4:	28 9d       	mul	r18, r8
    43c6:	c0 01       	movw	r24, r0
    43c8:	29 9d       	mul	r18, r9
    43ca:	90 0d       	add	r25, r0
    43cc:	38 9d       	mul	r19, r8
    43ce:	90 0d       	add	r25, r0
    43d0:	11 24       	eor	r1, r1
    43d2:	0e 94 38 32 	call	0x6470	; 0x6470 <srand>
				firstsrand=1;
    43d6:	10 93 d1 00 	sts	0x00D1, r17
    43da:	00 93 d0 00 	sts	0x00D0, r16
			}

			if(get_state() == GAME_FINAL){
    43de:	0e 94 b9 31 	call	0x6372	; 0x6372 <get_state>
    43e2:	81 30       	cpi	r24, 0x01	; 1
    43e4:	91 05       	cpc	r25, r1
    43e6:	99 f4       	brne	.+38     	; 0x440e <vMainGameTask+0x17c>
				second = 0;
    43e8:	10 92 cd 00 	sts	0x00CD, r1
    43ec:	10 92 cc 00 	sts	0x00CC, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    43f0:	f0 92 cf 00 	sts	0x00CF, r15
    43f4:	e0 92 ce 00 	sts	0x00CE, r14
				current_lcd_state = LCD_WRITE;
    43f8:	d0 92 ba 00 	sts	0x00BA, r13
    43fc:	c0 92 b9 00 	sts	0x00B9, r12
				current_state = RESULT;
    4400:	b0 92 b8 00 	sts	0x00B8, r11
    4404:	a0 92 b7 00 	sts	0x00B7, r10
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    4408:	c1 e0       	ldi	r28, 0x01	; 1
    440a:	d0 e0       	ldi	r29, 0x00	; 0
    440c:	02 c0       	rjmp	.+4      	; 0x4412 <vMainGameTask+0x180>
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
    440e:	c0 e0       	ldi	r28, 0x00	; 0
    4410:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_STOP;
				current_lcd_state = LCD_WRITE;
				current_state = RESULT;
			}
		}
		second++;
    4412:	80 91 cc 00 	lds	r24, 0x00CC
    4416:	90 91 cd 00 	lds	r25, 0x00CD
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	90 93 cd 00 	sts	0x00CD, r25
    4420:	80 93 cc 00 	sts	0x00CC, r24
		vTaskDelay(20 * TICKS_PER_MS);
    4424:	84 e6       	ldi	r24, 0x64	; 100
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
	}	
    442c:	56 cf       	rjmp	.-340    	; 0x42da <vMainGameTask+0x48>

0000442e <vLEDTask>:
	}
}



void vLEDTask ( void * pvParameters ) {
    442e:	ef 92       	push	r14
    4430:	ff 92       	push	r15
    4432:	0f 93       	push	r16
    4434:	1f 93       	push	r17
    4436:	cf 93       	push	r28
    4438:	df 93       	push	r29
	int current = 0;
	// Set PORTB as LED output //
	DDRB = 0xFF;
    443a:	8f ef       	ldi	r24, 0xFF	; 255
    443c:	87 bb       	out	0x17, r24	; 23
	PORTB = current;
    443e:	18 ba       	out	0x18, r1	; 24
	led_current_state = LED_START;
    4440:	81 e0       	ldi	r24, 0x01	; 1
    4442:	90 e0       	ldi	r25, 0x00	; 0
    4444:	90 93 cf 00 	sts	0x00CF, r25
    4448:	80 93 ce 00 	sts	0x00CE, r24
}



void vLEDTask ( void * pvParameters ) {
	int current = 0;
    444c:	c0 e0       	ldi	r28, 0x00	; 0
    444e:	d0 e0       	ldi	r29, 0x00	; 0
			}else{
				current = current >> 1;
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
			if (current == 0b11100000){
				led_current_state = LED_MOVE_LEFT;
    4450:	02 e0       	ldi	r16, 0x02	; 2
    4452:	10 e0       	ldi	r17, 0x00	; 0
		}else if(led_current_state == LED_START){
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
			if (current == 0b00000111){
				led_current_state = LED_MOVE_RIGHT;
    4454:	63 e0       	ldi	r22, 0x03	; 3
    4456:	e6 2e       	mov	r14, r22
    4458:	f1 2c       	mov	r15, r1
	// Set PORTB as LED output //
	DDRB = 0xFF;
	PORTB = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
    445a:	80 91 ce 00 	lds	r24, 0x00CE
    445e:	90 91 cf 00 	lds	r25, 0x00CF
    4462:	84 30       	cpi	r24, 0x04	; 4
    4464:	91 05       	cpc	r25, r1
    4466:	31 f1       	breq	.+76     	; 0x44b4 <vLEDTask+0x86>
			current = 0;	
		}else if(led_current_state == LED_START){
    4468:	81 30       	cpi	r24, 0x01	; 1
    446a:	91 05       	cpc	r25, r1
    446c:	39 f4       	brne	.+14     	; 0x447c <vLEDTask+0x4e>
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
    446e:	10 93 cf 00 	sts	0x00CF, r17
    4472:	00 93 ce 00 	sts	0x00CE, r16
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
		}else if(led_current_state == LED_START){
			current = 0b11100000;
    4476:	c0 ee       	ldi	r28, 0xE0	; 224
    4478:	d0 e0       	ldi	r29, 0x00	; 0
    447a:	1e c0       	rjmp	.+60     	; 0x44b8 <vLEDTask+0x8a>
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
    447c:	82 30       	cpi	r24, 0x02	; 2
    447e:	91 05       	cpc	r25, r1
    4480:	59 f4       	brne	.+22     	; 0x4498 <vLEDTask+0x6a>
			if (current == 0b00000111){
    4482:	c7 30       	cpi	r28, 0x07	; 7
    4484:	d1 05       	cpc	r29, r1
    4486:	29 f4       	brne	.+10     	; 0x4492 <vLEDTask+0x64>
				led_current_state = LED_MOVE_RIGHT;
    4488:	f0 92 cf 00 	sts	0x00CF, r15
    448c:	e0 92 ce 00 	sts	0x00CE, r14
    4490:	13 c0       	rjmp	.+38     	; 0x44b8 <vLEDTask+0x8a>
			}else{
				current = current >> 1;
    4492:	d5 95       	asr	r29
    4494:	c7 95       	ror	r28
    4496:	10 c0       	rjmp	.+32     	; 0x44b8 <vLEDTask+0x8a>
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
    4498:	83 30       	cpi	r24, 0x03	; 3
    449a:	91 05       	cpc	r25, r1
    449c:	69 f4       	brne	.+26     	; 0x44b8 <vLEDTask+0x8a>
			if (current == 0b11100000){
    449e:	c0 3e       	cpi	r28, 0xE0	; 224
    44a0:	d1 05       	cpc	r29, r1
    44a2:	29 f4       	brne	.+10     	; 0x44ae <vLEDTask+0x80>
				led_current_state = LED_MOVE_LEFT;
    44a4:	10 93 cf 00 	sts	0x00CF, r17
    44a8:	00 93 ce 00 	sts	0x00CE, r16
    44ac:	05 c0       	rjmp	.+10     	; 0x44b8 <vLEDTask+0x8a>
			}else{
				current = current << 1;
    44ae:	cc 0f       	add	r28, r28
    44b0:	dd 1f       	adc	r29, r29
    44b2:	02 c0       	rjmp	.+4      	; 0x44b8 <vLEDTask+0x8a>
	DDRB = 0xFF;
	PORTB = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
    44b4:	c0 e0       	ldi	r28, 0x00	; 0
    44b6:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_MOVE_LEFT;
			}else{
				current = current << 1;
			}
		}
		PORTB = current ^ 0b11111111;
    44b8:	9e 01       	movw	r18, r28
    44ba:	20 95       	com	r18
    44bc:	28 bb       	out	0x18, r18	; 24
		vTaskDelay(20 * TICKS_PER_MS);
    44be:	84 e6       	ldi	r24, 0x64	; 100
    44c0:	90 e0       	ldi	r25, 0x00	; 0
    44c2:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
	}
    44c6:	c9 cf       	rjmp	.-110    	; 0x445a <vLEDTask+0x2c>

000044c8 <vInputTask>:
}


void vInputTask(void *pvParameters){
    44c8:	ef 92       	push	r14
    44ca:	ff 92       	push	r15
    44cc:	0f 93       	push	r16
    44ce:	1f 93       	push	r17
    44d0:	cf 93       	push	r28
    44d2:	df 93       	push	r29
	DDRD = 0x11111100;
    44d4:	11 ba       	out	0x11, r1	; 17
			}else if(input == 0b11111101){
				set_mario(0);
			}
		}else if(current_state==RESULT && input == 0b11111110){
			clear_lcd();
			led_current_state = LED_STOP;
    44d6:	04 e0       	ldi	r16, 0x04	; 4
    44d8:	10 e0       	ldi	r17, 0x00	; 0
			current_lcd_state = LCD_EMPTY;
			current_state = LOADING;
    44da:	c1 e0       	ldi	r28, 0x01	; 1
    44dc:	d0 e0       	ldi	r29, 0x00	; 0


void vInputTask(void *pvParameters){
	DDRD = 0x11111100;
	while(1){
		int input = PIND;
    44de:	80 b3       	in	r24, 0x10	; 16
    44e0:	90 e0       	ldi	r25, 0x00	; 0
		if(current_state == STARTSCREEN){
    44e2:	e0 90 b7 00 	lds	r14, 0x00B7
    44e6:	f0 90 b8 00 	lds	r15, 0x00B8
    44ea:	e1 14       	cp	r14, r1
    44ec:	f1 04       	cpc	r15, r1
    44ee:	89 f4       	brne	.+34     	; 0x4512 <vInputTask+0x4a>
			if(input == 0b11111110){
    44f0:	8e 3f       	cpi	r24, 0xFE	; 254
    44f2:	91 05       	cpc	r25, r1
    44f4:	19 f4       	brne	.+6      	; 0x44fc <vInputTask+0x34>
				clear_lcd();
    44f6:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
    44fa:	3c c0       	rjmp	.+120    	; 0x4574 <vInputTask+0xac>
				current_state = LOADING;
				second = 0;
				
			}else if(input == 0b11111101){
    44fc:	8d 3f       	cpi	r24, 0xFD	; 253
    44fe:	91 05       	cpc	r25, r1
    4500:	09 f0       	breq	.+2      	; 0x4504 <vInputTask+0x3c>
    4502:	40 c0       	rjmp	.+128    	; 0x4584 <vInputTask+0xbc>
				clear_lcd();
    4504:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
				current_state = HISCORESCREEN;
    4508:	10 93 b8 00 	sts	0x00B8, r17
    450c:	00 93 b7 00 	sts	0x00B7, r16
    4510:	39 c0       	rjmp	.+114    	; 0x4584 <vInputTask+0xbc>
			}
		}else if(current_state == HISCORESCREEN){
    4512:	24 e0       	ldi	r18, 0x04	; 4
    4514:	e2 16       	cp	r14, r18
    4516:	f1 04       	cpc	r15, r1
    4518:	51 f4       	brne	.+20     	; 0x452e <vInputTask+0x66>
			if(input == 0b11111110){
    451a:	8e 3f       	cpi	r24, 0xFE	; 254
    451c:	91 05       	cpc	r25, r1
    451e:	91 f5       	brne	.+100    	; 0x4584 <vInputTask+0xbc>
				clear_lcd();
    4520:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
				current_state = STARTSCREEN;
    4524:	10 92 b8 00 	sts	0x00B8, r1
    4528:	10 92 b7 00 	sts	0x00B7, r1
    452c:	2b c0       	rjmp	.+86     	; 0x4584 <vInputTask+0xbc>
			}
		}else if(current_state == GAME){
    452e:	22 e0       	ldi	r18, 0x02	; 2
    4530:	e2 16       	cp	r14, r18
    4532:	f1 04       	cpc	r15, r1
    4534:	71 f4       	brne	.+28     	; 0x4552 <vInputTask+0x8a>
			if(input == 0b11111110){
    4536:	8e 3f       	cpi	r24, 0xFE	; 254
    4538:	91 05       	cpc	r25, r1
    453a:	19 f4       	brne	.+6      	; 0x4542 <vInputTask+0x7a>
				set_mario(1);
    453c:	81 e0       	ldi	r24, 0x01	; 1
    453e:	90 e0       	ldi	r25, 0x00	; 0
    4540:	05 c0       	rjmp	.+10     	; 0x454c <vInputTask+0x84>
			}else if(input == 0b11111101){
    4542:	8d 3f       	cpi	r24, 0xFD	; 253
    4544:	91 05       	cpc	r25, r1
    4546:	f1 f4       	brne	.+60     	; 0x4584 <vInputTask+0xbc>
				set_mario(0);
    4548:	80 e0       	ldi	r24, 0x00	; 0
    454a:	90 e0       	ldi	r25, 0x00	; 0
    454c:	0e 94 a6 31 	call	0x634c	; 0x634c <set_mario>
    4550:	19 c0       	rjmp	.+50     	; 0x4584 <vInputTask+0xbc>
			}
		}else if(current_state==RESULT && input == 0b11111110){
    4552:	23 e0       	ldi	r18, 0x03	; 3
    4554:	e2 16       	cp	r14, r18
    4556:	f1 04       	cpc	r15, r1
    4558:	a9 f4       	brne	.+42     	; 0x4584 <vInputTask+0xbc>
    455a:	8e 3f       	cpi	r24, 0xFE	; 254
    455c:	91 05       	cpc	r25, r1
    455e:	91 f4       	brne	.+36     	; 0x4584 <vInputTask+0xbc>
			clear_lcd();
    4560:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
			led_current_state = LED_STOP;
    4564:	10 93 cf 00 	sts	0x00CF, r17
    4568:	00 93 ce 00 	sts	0x00CE, r16
			current_lcd_state = LCD_EMPTY;
    456c:	f0 92 ba 00 	sts	0x00BA, r15
    4570:	e0 92 b9 00 	sts	0x00B9, r14
			current_state = LOADING;
    4574:	d0 93 b8 00 	sts	0x00B8, r29
    4578:	c0 93 b7 00 	sts	0x00B7, r28
			second = 0;
    457c:	10 92 cd 00 	sts	0x00CD, r1
    4580:	10 92 cc 00 	sts	0x00CC, r1
		}
		
		vTaskDelay(3 * TICKS_PER_MS);
    4584:	8f e0       	ldi	r24, 0x0F	; 15
    4586:	90 e0       	ldi	r25, 0x00	; 0
    4588:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
	}
    458c:	a8 cf       	rjmp	.-176    	; 0x44de <vInputTask+0x16>

0000458e <vLCDTask>:
	}
}



void vLCDTask( void * pvParameters) {
    458e:	af 92       	push	r10
    4590:	bf 92       	push	r11
    4592:	cf 92       	push	r12
    4594:	df 92       	push	r13
    4596:	ef 92       	push	r14
    4598:	ff 92       	push	r15
    459a:	0f 93       	push	r16
    459c:	1f 93       	push	r17
    459e:	df 93       	push	r29
    45a0:	cf 93       	push	r28
    45a2:	cd b7       	in	r28, 0x3d	; 61
    45a4:	de b7       	in	r29, 0x3e	; 62
    45a6:	60 97       	sbiw	r28, 0x10	; 16
    45a8:	0f b6       	in	r0, 0x3f	; 63
    45aa:	f8 94       	cli
    45ac:	de bf       	out	0x3e, r29	; 62
    45ae:	0f be       	out	0x3f, r0	; 63
    45b0:	cd bf       	out	0x3d, r28	; 61
	init_lcd();
    45b2:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <init_lcd>
				eeprom_update_word((uint16_t*)46,pas);
			}else{
				tulis_string("SCORE: ",1,0);
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    45b6:	7e 01       	movw	r14, r28
    45b8:	08 94       	sec
    45ba:	e1 1c       	adc	r14, r1
    45bc:	f1 1c       	adc	r15, r1
		}else if(current_state == STARTSCREEN){
			tulis_string("0.START",0,0);
			tulis_string("1.HISKOR",0,1);
		}else if(current_state == LOADING){
			if(current_lcd_state == LCD_START){	
				current_lcd_state = LCD_WRITE;
    45be:	72 e0       	ldi	r23, 0x02	; 2
    45c0:	a7 2e       	mov	r10, r23
    45c2:	b1 2c       	mov	r11, r1
	tulis_data_ram_lcd(0x20); 		// Tulis spasi
	*/
	
	int ii = 0;
	while (1){
		if (current_lcd_state == LCD_EMPTY){
    45c4:	20 91 b9 00 	lds	r18, 0x00B9
    45c8:	30 91 ba 00 	lds	r19, 0x00BA
    45cc:	23 30       	cpi	r18, 0x03	; 3
    45ce:	31 05       	cpc	r19, r1
    45d0:	21 f4       	brne	.+8      	; 0x45da <vLCDTask+0x4c>
			kirim_perintah_lcd(0x01);
    45d2:	81 e0       	ldi	r24, 0x01	; 1
    45d4:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
    45d8:	88 c0       	rjmp	.+272    	; 0x46ea <vLCDTask+0x15c>
		}else if(current_state == HISCORESCREEN){
    45da:	80 91 b7 00 	lds	r24, 0x00B7
    45de:	90 91 b8 00 	lds	r25, 0x00B8
    45e2:	84 30       	cpi	r24, 0x04	; 4
    45e4:	91 05       	cpc	r25, r1
    45e6:	b9 f4       	brne	.+46     	; 0x4616 <vLCDTask+0x88>
			tulis_string("HISCORE",0,0);
    45e8:	80 e6       	ldi	r24, 0x60	; 96
    45ea:	90 e0       	ldi	r25, 0x00	; 0
    45ec:	60 e0       	ldi	r22, 0x00	; 0
    45ee:	70 e0       	ldi	r23, 0x00	; 0
    45f0:	40 e0       	ldi	r20, 0x00	; 0
    45f2:	50 e0       	ldi	r21, 0x00	; 0
    45f4:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>
			int highscore = eeprom_read_word((uint16_t*)46);
    45f8:	8e e2       	ldi	r24, 0x2E	; 46
    45fa:	90 e0       	ldi	r25, 0x00	; 0
    45fc:	0e 94 96 32 	call	0x652c	; 0x652c <__eerd_word_m32>
			if(highscore<0){
				highscore=0;
			}
			char lcdstr[16];
			ltoa(highscore, lcdstr, 10);
    4600:	68 2f       	mov	r22, r24
    4602:	79 2f       	mov	r23, r25
    4604:	77 ff       	sbrs	r23, 7
    4606:	02 c0       	rjmp	.+4      	; 0x460c <vLCDTask+0x7e>
    4608:	60 e0       	ldi	r22, 0x00	; 0
    460a:	70 e0       	ldi	r23, 0x00	; 0
    460c:	88 27       	eor	r24, r24
    460e:	77 fd       	sbrc	r23, 7
    4610:	80 95       	com	r24
    4612:	98 2f       	mov	r25, r24
    4614:	5e c0       	rjmp	.+188    	; 0x46d2 <vLCDTask+0x144>
			tulis_string(lcdstr,3,1);
		}else if(current_state == STARTSCREEN){
    4616:	00 97       	sbiw	r24, 0x00	; 0
    4618:	69 f4       	brne	.+26     	; 0x4634 <vLCDTask+0xa6>
			tulis_string("0.START",0,0);
    461a:	88 e6       	ldi	r24, 0x68	; 104
    461c:	90 e0       	ldi	r25, 0x00	; 0
    461e:	60 e0       	ldi	r22, 0x00	; 0
    4620:	70 e0       	ldi	r23, 0x00	; 0
    4622:	40 e0       	ldi	r20, 0x00	; 0
    4624:	50 e0       	ldi	r21, 0x00	; 0
    4626:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>
			tulis_string("1.HISKOR",0,1);
    462a:	80 e7       	ldi	r24, 0x70	; 112
    462c:	90 e0       	ldi	r25, 0x00	; 0
    462e:	60 e0       	ldi	r22, 0x00	; 0
    4630:	70 e0       	ldi	r23, 0x00	; 0
    4632:	57 c0       	rjmp	.+174    	; 0x46e2 <vLCDTask+0x154>
		}else if(current_state == LOADING){
    4634:	81 30       	cpi	r24, 0x01	; 1
    4636:	91 05       	cpc	r25, r1
    4638:	c9 f4       	brne	.+50     	; 0x466c <vLCDTask+0xde>
			if(current_lcd_state == LCD_START){	
    463a:	21 30       	cpi	r18, 0x01	; 1
    463c:	31 05       	cpc	r19, r1
    463e:	29 f4       	brne	.+10     	; 0x464a <vLCDTask+0xbc>
				current_lcd_state = LCD_WRITE;
    4640:	b0 92 ba 00 	sts	0x00BA, r11
    4644:	a0 92 b9 00 	sts	0x00B9, r10
    4648:	50 c0       	rjmp	.+160    	; 0x46ea <vLCDTask+0x15c>
			}else if (current_lcd_state == LCD_WRITE){
    464a:	22 30       	cpi	r18, 0x02	; 2
    464c:	31 05       	cpc	r19, r1
    464e:	09 f0       	breq	.+2      	; 0x4652 <vLCDTask+0xc4>
    4650:	4c c0       	rjmp	.+152    	; 0x46ea <vLCDTask+0x15c>
				tulis_string("LOADING.",0,0);
    4652:	89 e7       	ldi	r24, 0x79	; 121
    4654:	90 e0       	ldi	r25, 0x00	; 0
    4656:	60 e0       	ldi	r22, 0x00	; 0
    4658:	70 e0       	ldi	r23, 0x00	; 0
    465a:	40 e0       	ldi	r20, 0x00	; 0
    465c:	50 e0       	ldi	r21, 0x00	; 0
    465e:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>
				tulis_string("GAME...",1,1);
    4662:	82 e8       	ldi	r24, 0x82	; 130
    4664:	90 e0       	ldi	r25, 0x00	; 0
    4666:	61 e0       	ldi	r22, 0x01	; 1
    4668:	70 e0       	ldi	r23, 0x00	; 0
    466a:	3b c0       	rjmp	.+118    	; 0x46e2 <vLCDTask+0x154>
			}
		}else if(current_state == GAME){
    466c:	82 30       	cpi	r24, 0x02	; 2
    466e:	91 05       	cpc	r25, r1
    4670:	29 f4       	brne	.+10     	; 0x467c <vLCDTask+0xee>
			clear_lcd();
    4672:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
			draw_game();
    4676:	0e 94 58 31 	call	0x62b0	; 0x62b0 <draw_game>
    467a:	37 c0       	rjmp	.+110    	; 0x46ea <vLCDTask+0x15c>
			//tulis_string("MULAI",0,0);
		}else if(current_state == RESULT){
    467c:	83 30       	cpi	r24, 0x03	; 3
    467e:	91 05       	cpc	r25, r1
    4680:	a1 f5       	brne	.+104    	; 0x46ea <vLCDTask+0x15c>
			clear_lcd();
    4682:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <clear_lcd>
			
			int highscore = eeprom_read_word((uint16_t*)46);
    4686:	8e e2       	ldi	r24, 0x2E	; 46
    4688:	90 e0       	ldi	r25, 0x00	; 0
    468a:	0e 94 96 32 	call	0x652c	; 0x652c <__eerd_word_m32>
    468e:	6c 01       	movw	r12, r24
			int pas = getpass();
    4690:	0e 94 be 31 	call	0x637c	; 0x637c <getpass>
    4694:	8c 01       	movw	r16, r24
			if(pas>=highscore){
    4696:	8c 15       	cp	r24, r12
    4698:	9d 05       	cpc	r25, r13
    469a:	74 f0       	brlt	.+28     	; 0x46b8 <vLCDTask+0x12a>
				tulis_string("HISCORE: ",0,0);
    469c:	8a e8       	ldi	r24, 0x8A	; 138
    469e:	90 e0       	ldi	r25, 0x00	; 0
    46a0:	60 e0       	ldi	r22, 0x00	; 0
    46a2:	70 e0       	ldi	r23, 0x00	; 0
    46a4:	40 e0       	ldi	r20, 0x00	; 0
    46a6:	50 e0       	ldi	r21, 0x00	; 0
    46a8:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>
				eeprom_update_word((uint16_t*)46,pas);
    46ac:	8e e2       	ldi	r24, 0x2E	; 46
    46ae:	90 e0       	ldi	r25, 0x00	; 0
    46b0:	b8 01       	movw	r22, r16
    46b2:	0e 94 9c 32 	call	0x6538	; 0x6538 <__eeupd_word_m32>
    46b6:	08 c0       	rjmp	.+16     	; 0x46c8 <vLCDTask+0x13a>
			}else{
				tulis_string("SCORE: ",1,0);
    46b8:	84 e9       	ldi	r24, 0x94	; 148
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	61 e0       	ldi	r22, 0x01	; 1
    46be:	70 e0       	ldi	r23, 0x00	; 0
    46c0:	40 e0       	ldi	r20, 0x00	; 0
    46c2:	50 e0       	ldi	r21, 0x00	; 0
    46c4:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    46c8:	b8 01       	movw	r22, r16
    46ca:	88 27       	eor	r24, r24
    46cc:	77 fd       	sbrc	r23, 7
    46ce:	80 95       	com	r24
    46d0:	98 2f       	mov	r25, r24
    46d2:	a7 01       	movw	r20, r14
    46d4:	2a e0       	ldi	r18, 0x0A	; 10
    46d6:	30 e0       	ldi	r19, 0x00	; 0
    46d8:	0e 94 62 32 	call	0x64c4	; 0x64c4 <ltoa>
			tulis_string(lcdstr,3,1);
    46dc:	c7 01       	movw	r24, r14
    46de:	63 e0       	ldi	r22, 0x03	; 3
    46e0:	70 e0       	ldi	r23, 0x00	; 0
    46e2:	41 e0       	ldi	r20, 0x01	; 1
    46e4:	50 e0       	ldi	r21, 0x00	; 0
    46e6:	0e 94 01 30 	call	0x6002	; 0x6002 <tulis_string>

			
		}	
		
		vTaskDelay(20 * TICKS_PER_MS);
    46ea:	84 e6       	ldi	r24, 0x64	; 100
    46ec:	90 e0       	ldi	r25, 0x00	; 0
    46ee:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
		
		
	}
    46f2:	68 cf       	rjmp	.-304    	; 0x45c4 <vLCDTask+0x36>

000046f4 <vSonarTask>:
This task measures distance using the SRF08 every 100 ms 
and display the result in cm to LCD
*/
int global_sonar_cm = 0;
void vSonarTask( void * pvParameters )
{
    46f4:	ef 92       	push	r14
    46f6:	ff 92       	push	r15
    46f8:	cf 93       	push	r28
    46fa:	df 93       	push	r29
    char lcd[16];
	int i = 0;
	init_lcd();
    46fc:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <init_lcd>
	
	while(1){
		unsigned int data = 0;
		// Send command to start measurement
 		i2c_transmit(0xE0, 0, 81);
    4700:	80 ee       	ldi	r24, 0xE0	; 224
    4702:	60 e0       	ldi	r22, 0x00	; 0
    4704:	41 e5       	ldi	r20, 0x51	; 81
    4706:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <i2c_transmit>
		// Wait for the measurement to be done
		vTaskDelay(70 * TICKS_PER_MS);
    470a:	8e e5       	ldi	r24, 0x5E	; 94
    470c:	91 e0       	ldi	r25, 0x01	; 1
    470e:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
		// Read the 16 bit result
		data = i2cRead(0xE0, 2) << 8;
    4712:	80 ee       	ldi	r24, 0xE0	; 224
    4714:	62 e0       	ldi	r22, 0x02	; 2
    4716:	0e 94 76 2f 	call	0x5eec	; 0x5eec <i2cRead>
    471a:	98 2f       	mov	r25, r24
    471c:	80 e0       	ldi	r24, 0x00	; 0
    471e:	ec 01       	movw	r28, r24
		data |= i2cRead(0xE0, 3);
    4720:	80 ee       	ldi	r24, 0xE0	; 224
    4722:	63 e0       	ldi	r22, 0x03	; 3
    4724:	0e 94 76 2f 	call	0x5eec	; 0x5eec <i2cRead>
    4728:	90 e0       	ldi	r25, 0x00	; 0
    472a:	8c 2b       	or	r24, r28
    472c:	9d 2b       	or	r25, r29
		global_sonar_cm = data;
    472e:	90 93 cb 00 	sts	0x00CB, r25
    4732:	80 93 ca 00 	sts	0x00CA, r24
			//tulis_data_ram_lcd(lcd[i]);
		}
		*/
		
		// Delay for another 100 ms
		vTaskDelay(20 * TICKS_PER_MS);
    4736:	84 e6       	ldi	r24, 0x64	; 100
    4738:	90 e0       	ldi	r25, 0x00	; 0
    473a:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
    473e:	e0 cf       	rjmp	.-64     	; 0x4700 <vSonarTask+0xc>

00004740 <vServoTask>:
	}

}


void vServoTask(void *pvParameters){
    4740:	0f 93       	push	r16
    4742:	1f 93       	push	r17
    4744:	cf 93       	push	r28
    4746:	df 93       	push	r29
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
    4748:	80 91 b7 00 	lds	r24, 0x00B7
    474c:	90 91 b8 00 	lds	r25, 0x00B8
    4750:	82 30       	cpi	r24, 0x02	; 2
    4752:	91 05       	cpc	r25, r1
    4754:	79 f5       	brne	.+94     	; 0x47b4 <vServoTask+0x74>
    4756:	c8 e2       	ldi	r28, 0x28	; 40
    4758:	d0 e0       	ldi	r29, 0x00	; 0
			i = 1;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
    475a:	c0 9a       	sbi	0x18, 0	; 24
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    475c:	81 e0       	ldi	r24, 0x01	; 1
    475e:	90 e0       	ldi	r25, 0x00	; 0
    4760:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
    4764:	81 e0       	ldi	r24, 0x01	; 1
    4766:	90 e0       	ldi	r25, 0x00	; 0
    4768:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
				}
				PORTB &= 0b11111110;
    476c:	c0 98       	cbi	0x18, 0	; 24
		
				vTaskDelay(10 * TICKS_PER_MS);
    476e:	82 e3       	ldi	r24, 0x32	; 50
    4770:	90 e0       	ldi	r25, 0x00	; 0
    4772:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
    4776:	21 97       	sbiw	r28, 0x01	; 1
void vServoTask(void *pvParameters){
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
			i = 1;
			for (k = 0; k < 40; k++) {
    4778:	81 f7       	brne	.-32     	; 0x475a <vServoTask+0x1a>
				}
				PORTB &= 0b11111110;
		
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    477a:	81 e0       	ldi	r24, 0x01	; 1
    477c:	90 e0       	ldi	r25, 0x00	; 0
    477e:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
		
			i = 45;
			for (k = 0; k < 40; k++) {
    4782:	c0 e0       	ldi	r28, 0x00	; 0
    4784:	d0 e0       	ldi	r29, 0x00	; 0
				PORTB |= 0b00000001;
    4786:	c0 9a       	sbi	0x18, 0	; 24
    4788:	0e e2       	ldi	r16, 0x2E	; 46
    478a:	10 e0       	ldi	r17, 0x00	; 0
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    478c:	81 e0       	ldi	r24, 0x01	; 1
    478e:	90 e0       	ldi	r25, 0x00	; 0
    4790:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
    4794:	01 50       	subi	r16, 0x01	; 1
    4796:	10 40       	sbci	r17, 0x00	; 0
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
				for (j = 0; j <= i; j++) {
    4798:	c9 f7       	brne	.-14     	; 0x478c <vServoTask+0x4c>
					vTaskDelay(1);
				}
				PORTB &= 0b11111110;
    479a:	c0 98       	cbi	0x18, 0	; 24
			
				vTaskDelay(10 * TICKS_PER_MS);
    479c:	82 e3       	ldi	r24, 0x32	; 50
    479e:	90 e0       	ldi	r25, 0x00	; 0
    47a0:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
    47a4:	21 96       	adiw	r28, 0x01	; 1
    47a6:	c8 32       	cpi	r28, 0x28	; 40
    47a8:	d1 05       	cpc	r29, r1
    47aa:	69 f7       	brne	.-38     	; 0x4786 <vServoTask+0x46>
				}
				PORTB &= 0b11111110;
			
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    47ac:	81 e0       	ldi	r24, 0x01	; 1
    47ae:	90 e0       	ldi	r25, 0x00	; 0
    47b0:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
		}
		vTaskDelay(1);		
    47b4:	81 e0       	ldi	r24, 0x01	; 1
    47b6:	90 e0       	ldi	r25, 0x00	; 0
    47b8:	0e 94 8d 2c 	call	0x591a	; 0x591a <vTaskDelay>
	}	
    47bc:	c5 cf       	rjmp	.-118    	; 0x4748 <vServoTask+0x8>

000047be <main>:
}




int main(){
    47be:	af 92       	push	r10
    47c0:	bf 92       	push	r11
    47c2:	cf 92       	push	r12
    47c4:	df 92       	push	r13
    47c6:	ef 92       	push	r14
    47c8:	ff 92       	push	r15
    47ca:	0f 93       	push	r16
    47cc:	df 93       	push	r29
    47ce:	cf 93       	push	r28
    47d0:	cd b7       	in	r28, 0x3d	; 61
    47d2:	de b7       	in	r29, 0x3e	; 62
    47d4:	2a 97       	sbiw	r28, 0x0a	; 10
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	de bf       	out	0x3e, r29	; 62
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	cd bf       	out	0x3d, r28	; 61
	xTaskHandle xSonarTaskHandle, xMusicTaskHandle, xSoundTaskHandle, xLEDTaskHandle, xLCDTaskHandle, xMainGameTaskHandle;
	xTaskHandle xInputTaskHandle;
	
	/* set the I2C bit rate generator to 100 kb/s */
	
	TWSR &= ~0x03;
    47e0:	81 b1       	in	r24, 0x01	; 1
    47e2:	8c 7f       	andi	r24, 0xFC	; 252
    47e4:	81 b9       	out	0x01, r24	; 1
	TWBR  = 28;
    47e6:	8c e1       	ldi	r24, 0x1C	; 28
    47e8:	80 b9       	out	0x00, r24	; 0
	TWCR |= _BV(TWEN);
    47ea:	86 b7       	in	r24, 0x36	; 54
    47ec:	84 60       	ori	r24, 0x04	; 4
    47ee:	86 bf       	out	0x36, r24	; 54

	LCD_CONTROL_DDR	 = _BV(LCD_RS_BIT) | _BV(LCD_EN_BIT) | _BV(LCD_RW_BIT);
    47f0:	80 ee       	ldi	r24, 0xE0	; 224
    47f2:	84 bb       	out	0x14, r24	; 20
	DDRA = 0xFF;
    47f4:	8f ef       	ldi	r24, 0xFF	; 255
    47f6:	8a bb       	out	0x1a, r24	; 26
	

	/*
	Create the tasks
	*/
	xTaskCreate( vMainGameTask, "GAME", 100, NULL, tskIDLE_PRIORITY, &xMainGameTaskHandle);
    47f8:	89 e4       	ldi	r24, 0x49	; 73
    47fa:	91 e2       	ldi	r25, 0x21	; 33
    47fc:	6c e9       	ldi	r22, 0x9C	; 156
    47fe:	70 e0       	ldi	r23, 0x00	; 0
    4800:	44 e6       	ldi	r20, 0x64	; 100
    4802:	50 e0       	ldi	r21, 0x00	; 0
    4804:	20 e0       	ldi	r18, 0x00	; 0
    4806:	30 e0       	ldi	r19, 0x00	; 0
    4808:	00 e0       	ldi	r16, 0x00	; 0
    480a:	b7 e0       	ldi	r27, 0x07	; 7
    480c:	eb 2e       	mov	r14, r27
    480e:	f1 2c       	mov	r15, r1
    4810:	ec 0e       	add	r14, r28
    4812:	fd 1e       	adc	r15, r29
    4814:	cc 24       	eor	r12, r12
    4816:	dd 24       	eor	r13, r13
    4818:	aa 24       	eor	r10, r10
    481a:	bb 24       	eor	r11, r11
    481c:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>
	xTaskCreate( vLCDTask, "LCD", 100, NULL, tskIDLE_PRIORITY, &xLCDTaskHandle);
    4820:	87 ec       	ldi	r24, 0xC7	; 199
    4822:	92 e2       	ldi	r25, 0x22	; 34
    4824:	61 ea       	ldi	r22, 0xA1	; 161
    4826:	70 e0       	ldi	r23, 0x00	; 0
    4828:	44 e6       	ldi	r20, 0x64	; 100
    482a:	50 e0       	ldi	r21, 0x00	; 0
    482c:	20 e0       	ldi	r18, 0x00	; 0
    482e:	30 e0       	ldi	r19, 0x00	; 0
    4830:	a5 e0       	ldi	r26, 0x05	; 5
    4832:	ea 2e       	mov	r14, r26
    4834:	f1 2c       	mov	r15, r1
    4836:	ec 0e       	add	r14, r28
    4838:	fd 1e       	adc	r15, r29
    483a:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>
	xTaskCreate( vLEDTask, "LED", 100, NULL, tskIDLE_PRIORITY, &xLEDTaskHandle);
    483e:	87 e1       	ldi	r24, 0x17	; 23
    4840:	92 e2       	ldi	r25, 0x22	; 34
    4842:	65 ea       	ldi	r22, 0xA5	; 165
    4844:	70 e0       	ldi	r23, 0x00	; 0
    4846:	44 e6       	ldi	r20, 0x64	; 100
    4848:	50 e0       	ldi	r21, 0x00	; 0
    484a:	20 e0       	ldi	r18, 0x00	; 0
    484c:	30 e0       	ldi	r19, 0x00	; 0
    484e:	f3 e0       	ldi	r31, 0x03	; 3
    4850:	ef 2e       	mov	r14, r31
    4852:	f1 2c       	mov	r15, r1
    4854:	ec 0e       	add	r14, r28
    4856:	fd 1e       	adc	r15, r29
    4858:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>
	xTaskCreate( vSonarTask, "Sonar", 100, NULL , tskIDLE_PRIORITY, &xSonarTaskHandle );
    485c:	8a e7       	ldi	r24, 0x7A	; 122
    485e:	93 e2       	ldi	r25, 0x23	; 35
    4860:	69 ea       	ldi	r22, 0xA9	; 169
    4862:	70 e0       	ldi	r23, 0x00	; 0
    4864:	44 e6       	ldi	r20, 0x64	; 100
    4866:	50 e0       	ldi	r21, 0x00	; 0
    4868:	20 e0       	ldi	r18, 0x00	; 0
    486a:	30 e0       	ldi	r19, 0x00	; 0
    486c:	7e 01       	movw	r14, r28
    486e:	08 94       	sec
    4870:	e1 1c       	adc	r14, r1
    4872:	f1 1c       	adc	r15, r1
    4874:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>
	xTaskCreate( vInputTask, "Input", 100, NULL , tskIDLE_PRIORITY, &xInputTaskHandle );
    4878:	84 e6       	ldi	r24, 0x64	; 100
    487a:	92 e2       	ldi	r25, 0x22	; 34
    487c:	6f ea       	ldi	r22, 0xAF	; 175
    487e:	70 e0       	ldi	r23, 0x00	; 0
    4880:	44 e6       	ldi	r20, 0x64	; 100
    4882:	50 e0       	ldi	r21, 0x00	; 0
    4884:	20 e0       	ldi	r18, 0x00	; 0
    4886:	30 e0       	ldi	r19, 0x00	; 0
    4888:	e9 e0       	ldi	r30, 0x09	; 9
    488a:	ee 2e       	mov	r14, r30
    488c:	f1 2c       	mov	r15, r1
    488e:	ec 0e       	add	r14, r28
    4890:	fd 1e       	adc	r15, r29
    4892:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>


	// Start the scheduler
	vTaskStartScheduler();
    4896:	0e 94 21 2b 	call	0x5642	; 0x5642 <vTaskStartScheduler>
}
    489a:	80 e0       	ldi	r24, 0x00	; 0
    489c:	90 e0       	ldi	r25, 0x00	; 0
    489e:	2a 96       	adiw	r28, 0x0a	; 10
    48a0:	0f b6       	in	r0, 0x3f	; 63
    48a2:	f8 94       	cli
    48a4:	de bf       	out	0x3e, r29	; 62
    48a6:	0f be       	out	0x3f, r0	; 63
    48a8:	cd bf       	out	0x3d, r28	; 61
    48aa:	cf 91       	pop	r28
    48ac:	df 91       	pop	r29
    48ae:	0f 91       	pop	r16
    48b0:	ff 90       	pop	r15
    48b2:	ef 90       	pop	r14
    48b4:	df 90       	pop	r13
    48b6:	cf 90       	pop	r12
    48b8:	bf 90       	pop	r11
    48ba:	af 90       	pop	r10
    48bc:	08 95       	ret

000048be <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    48be:	af 92       	push	r10
    48c0:	bf 92       	push	r11
    48c2:	cf 92       	push	r12
    48c4:	df 92       	push	r13
    48c6:	ef 92       	push	r14
    48c8:	ff 92       	push	r15
    48ca:	0f 93       	push	r16
    48cc:	1f 93       	push	r17
    48ce:	cf 93       	push	r28
    48d0:	df 93       	push	r29
    48d2:	6c 01       	movw	r12, r24
    48d4:	b6 2e       	mov	r11, r22
    48d6:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    48d8:	8a e1       	ldi	r24, 0x1A	; 26
    48da:	90 e0       	ldi	r25, 0x00	; 0
    48dc:	0e 94 23 2f 	call	0x5e46	; 0x5e46 <pvPortMalloc>
    48e0:	e8 2e       	mov	r14, r24
    48e2:	e7 01       	movw	r28, r14
    48e4:	7e 01       	movw	r14, r28
    48e6:	f9 2e       	mov	r15, r25
    48e8:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    48ea:	20 97       	sbiw	r28, 0x00	; 0
    48ec:	09 f4       	brne	.+2      	; 0x48f0 <xCoRoutineCreate+0x32>
    48ee:	5e c0       	rjmp	.+188    	; 0x49ac <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    48f0:	80 91 d2 00 	lds	r24, 0x00D2
    48f4:	90 91 d3 00 	lds	r25, 0x00D3
    48f8:	00 97       	sbiw	r24, 0x00	; 0
    48fa:	21 f5       	brne	.+72     	; 0x4944 <xCoRoutineCreate+0x86>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    48fc:	f0 92 d3 00 	sts	0x00D3, r15
    4900:	e0 92 d2 00 	sts	0x00D2, r14
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    4904:	8e ed       	ldi	r24, 0xDE	; 222
    4906:	90 e0       	ldi	r25, 0x00	; 0
    4908:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
    490c:	87 ee       	ldi	r24, 0xE7	; 231
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    4914:	5a ef       	ldi	r21, 0xFA	; 250
    4916:	e5 2e       	mov	r14, r21
    4918:	50 e0       	ldi	r21, 0x00	; 0
    491a:	f5 2e       	mov	r15, r21
    491c:	c7 01       	movw	r24, r14
    491e:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    4922:	03 e0       	ldi	r16, 0x03	; 3
    4924:	11 e0       	ldi	r17, 0x01	; 1
    4926:	c8 01       	movw	r24, r16
    4928:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    492c:	84 ed       	ldi	r24, 0xD4	; 212
    492e:	90 e0       	ldi	r25, 0x00	; 0
    4930:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    4934:	f0 92 f7 00 	sts	0x00F7, r15
    4938:	e0 92 f6 00 	sts	0x00F6, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    493c:	10 93 f9 00 	sts	0x00F9, r17
    4940:	00 93 f8 00 	sts	0x00F8, r16
    4944:	bb 20       	and	r11, r11
    4946:	11 f0       	breq	.+4      	; 0x494c <xCoRoutineCreate+0x8e>
    4948:	bb 24       	eor	r11, r11
    494a:	b3 94       	inc	r11
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    494c:	19 8e       	std	Y+25, r1	; 0x19
    494e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4950:	be 8a       	std	Y+22, r11	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4952:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4954:	fe 01       	movw	r30, r28
    4956:	c1 92       	st	Z+, r12
    4958:	d1 92       	st	Z+, r13
    495a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    495c:	cf 01       	movw	r24, r30
    495e:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    4962:	ce 01       	movw	r24, r28
    4964:	0c 96       	adiw	r24, 0x0c	; 12
    4966:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    496a:	d9 87       	std	Y+9, r29	; 0x09
    496c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    496e:	db 8b       	std	Y+19, r29	; 0x13
    4970:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4972:	84 e0       	ldi	r24, 0x04	; 4
    4974:	90 e0       	ldi	r25, 0x00	; 0
    4976:	8b 19       	sub	r24, r11
    4978:	91 09       	sbc	r25, r1
    497a:	9d 87       	std	Y+13, r25	; 0x0d
    497c:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    497e:	2e 89       	ldd	r18, Y+22	; 0x16
    4980:	80 91 dd 00 	lds	r24, 0x00DD
    4984:	82 17       	cp	r24, r18
    4986:	10 f4       	brcc	.+4      	; 0x498c <xCoRoutineCreate+0xce>
    4988:	20 93 dd 00 	sts	0x00DD, r18
    498c:	30 e0       	ldi	r19, 0x00	; 0
    498e:	c9 01       	movw	r24, r18
    4990:	43 e0       	ldi	r20, 0x03	; 3
    4992:	88 0f       	add	r24, r24
    4994:	99 1f       	adc	r25, r25
    4996:	4a 95       	dec	r20
    4998:	e1 f7       	brne	.-8      	; 0x4992 <xCoRoutineCreate+0xd4>
    499a:	82 0f       	add	r24, r18
    499c:	93 1f       	adc	r25, r19
    499e:	82 52       	subi	r24, 0x22	; 34
    49a0:	9f 4f       	sbci	r25, 0xFF	; 255
    49a2:	b8 01       	movw	r22, r16
    49a4:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>

		xReturn = pdPASS;
    49a8:	81 e0       	ldi	r24, 0x01	; 1
    49aa:	01 c0       	rjmp	.+2      	; 0x49ae <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    49ac:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    49ae:	df 91       	pop	r29
    49b0:	cf 91       	pop	r28
    49b2:	1f 91       	pop	r17
    49b4:	0f 91       	pop	r16
    49b6:	ff 90       	pop	r15
    49b8:	ef 90       	pop	r14
    49ba:	df 90       	pop	r13
    49bc:	cf 90       	pop	r12
    49be:	bf 90       	pop	r11
    49c0:	af 90       	pop	r10
    49c2:	08 95       	ret

000049c4 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    49c4:	0f 93       	push	r16
    49c6:	1f 93       	push	r17
    49c8:	cf 93       	push	r28
    49ca:	df 93       	push	r29
    49cc:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    49ce:	00 91 f4 00 	lds	r16, 0x00F4
    49d2:	10 91 f5 00 	lds	r17, 0x00F5
    49d6:	08 0f       	add	r16, r24
    49d8:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    49da:	80 91 d2 00 	lds	r24, 0x00D2
    49de:	90 91 d3 00 	lds	r25, 0x00D3
    49e2:	02 96       	adiw	r24, 0x02	; 2
    49e4:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    49e8:	60 91 d2 00 	lds	r22, 0x00D2
    49ec:	70 91 d3 00 	lds	r23, 0x00D3
    49f0:	fb 01       	movw	r30, r22
    49f2:	13 83       	std	Z+3, r17	; 0x03
    49f4:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    49f6:	80 91 f4 00 	lds	r24, 0x00F4
    49fa:	90 91 f5 00 	lds	r25, 0x00F5
    49fe:	6e 5f       	subi	r22, 0xFE	; 254
    4a00:	7f 4f       	sbci	r23, 0xFF	; 255
    4a02:	08 17       	cp	r16, r24
    4a04:	19 07       	cpc	r17, r25
    4a06:	28 f4       	brcc	.+10     	; 0x4a12 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4a08:	80 91 f8 00 	lds	r24, 0x00F8
    4a0c:	90 91 f9 00 	lds	r25, 0x00F9
    4a10:	04 c0       	rjmp	.+8      	; 0x4a1a <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4a12:	80 91 f6 00 	lds	r24, 0x00F6
    4a16:	90 91 f7 00 	lds	r25, 0x00F7
    4a1a:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <vListInsert>
	}

	if( pxEventList )
    4a1e:	20 97       	sbiw	r28, 0x00	; 0
    4a20:	49 f0       	breq	.+18     	; 0x4a34 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4a22:	60 91 d2 00 	lds	r22, 0x00D2
    4a26:	70 91 d3 00 	lds	r23, 0x00D3
    4a2a:	64 5f       	subi	r22, 0xF4	; 244
    4a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a2e:	ce 01       	movw	r24, r28
    4a30:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <vListInsert>
	}
}
    4a34:	df 91       	pop	r29
    4a36:	cf 91       	pop	r28
    4a38:	1f 91       	pop	r17
    4a3a:	0f 91       	pop	r16
    4a3c:	08 95       	ret

00004a3e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    4a3e:	0f 93       	push	r16
    4a40:	1f 93       	push	r17
    4a42:	cf 93       	push	r28
    4a44:	df 93       	push	r29
    4a46:	27 c0       	rjmp	.+78     	; 0x4a96 <vCoRoutineSchedule+0x58>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    4a48:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4a4a:	e0 91 d9 00 	lds	r30, 0x00D9
    4a4e:	f0 91 da 00 	lds	r31, 0x00DA
    4a52:	c6 81       	ldd	r28, Z+6	; 0x06
    4a54:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4a56:	ce 01       	movw	r24, r28
    4a58:	0c 96       	adiw	r24, 0x0c	; 12
    4a5a:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4a5e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4a60:	8e 01       	movw	r16, r28
    4a62:	0e 5f       	subi	r16, 0xFE	; 254
    4a64:	1f 4f       	sbci	r17, 0xFF	; 255
    4a66:	c8 01       	movw	r24, r16
    4a68:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4a6c:	2e 89       	ldd	r18, Y+22	; 0x16
    4a6e:	80 91 dd 00 	lds	r24, 0x00DD
    4a72:	82 17       	cp	r24, r18
    4a74:	10 f4       	brcc	.+4      	; 0x4a7a <vCoRoutineSchedule+0x3c>
    4a76:	20 93 dd 00 	sts	0x00DD, r18
    4a7a:	30 e0       	ldi	r19, 0x00	; 0
    4a7c:	c9 01       	movw	r24, r18
    4a7e:	f3 e0       	ldi	r31, 0x03	; 3
    4a80:	88 0f       	add	r24, r24
    4a82:	99 1f       	adc	r25, r25
    4a84:	fa 95       	dec	r31
    4a86:	e1 f7       	brne	.-8      	; 0x4a80 <vCoRoutineSchedule+0x42>
    4a88:	82 0f       	add	r24, r18
    4a8a:	93 1f       	adc	r25, r19
    4a8c:	82 52       	subi	r24, 0x22	; 34
    4a8e:	9f 4f       	sbci	r25, 0xFF	; 255
    4a90:	b8 01       	movw	r22, r16
    4a92:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4a96:	80 91 d4 00 	lds	r24, 0x00D4
    4a9a:	88 23       	and	r24, r24
    4a9c:	a9 f6       	brne	.-86     	; 0x4a48 <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4a9e:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <xTaskGetTickCount>
    4aa2:	20 91 f0 00 	lds	r18, 0x00F0
    4aa6:	30 91 f1 00 	lds	r19, 0x00F1
    4aaa:	82 1b       	sub	r24, r18
    4aac:	93 0b       	sbc	r25, r19
    4aae:	90 93 f3 00 	sts	0x00F3, r25
    4ab2:	80 93 f2 00 	sts	0x00F2, r24
    4ab6:	59 c0       	rjmp	.+178    	; 0x4b6a <vCoRoutineSchedule+0x12c>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4ab8:	01 96       	adiw	r24, 0x01	; 1
    4aba:	90 93 f5 00 	sts	0x00F5, r25
    4abe:	80 93 f4 00 	sts	0x00F4, r24
		xPassedTicks--;
    4ac2:	21 50       	subi	r18, 0x01	; 1
    4ac4:	30 40       	sbci	r19, 0x00	; 0
    4ac6:	30 93 f3 00 	sts	0x00F3, r19
    4aca:	20 93 f2 00 	sts	0x00F2, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    4ace:	00 97       	sbiw	r24, 0x00	; 0
    4ad0:	09 f0       	breq	.+2      	; 0x4ad4 <vCoRoutineSchedule+0x96>
    4ad2:	44 c0       	rjmp	.+136    	; 0x4b5c <vCoRoutineSchedule+0x11e>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    4ad4:	80 91 f6 00 	lds	r24, 0x00F6
    4ad8:	90 91 f7 00 	lds	r25, 0x00F7
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4adc:	20 91 f8 00 	lds	r18, 0x00F8
    4ae0:	30 91 f9 00 	lds	r19, 0x00F9
    4ae4:	30 93 f7 00 	sts	0x00F7, r19
    4ae8:	20 93 f6 00 	sts	0x00F6, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    4aec:	90 93 f9 00 	sts	0x00F9, r25
    4af0:	80 93 f8 00 	sts	0x00F8, r24
    4af4:	33 c0       	rjmp	.+102    	; 0x4b5c <vCoRoutineSchedule+0x11e>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4af6:	05 80       	ldd	r0, Z+5	; 0x05
    4af8:	f6 81       	ldd	r31, Z+6	; 0x06
    4afa:	e0 2d       	mov	r30, r0
    4afc:	c6 81       	ldd	r28, Z+6	; 0x06
    4afe:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4b00:	20 91 f4 00 	lds	r18, 0x00F4
    4b04:	30 91 f5 00 	lds	r19, 0x00F5
    4b08:	8a 81       	ldd	r24, Y+2	; 0x02
    4b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b0c:	28 17       	cp	r18, r24
    4b0e:	39 07       	cpc	r19, r25
    4b10:	60 f1       	brcs	.+88     	; 0x4b6a <vCoRoutineSchedule+0x12c>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4b12:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4b14:	8e 01       	movw	r16, r28
    4b16:	0e 5f       	subi	r16, 0xFE	; 254
    4b18:	1f 4f       	sbci	r17, 0xFF	; 255
    4b1a:	c8 01       	movw	r24, r16
    4b1c:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4b20:	8c 89       	ldd	r24, Y+20	; 0x14
    4b22:	9d 89       	ldd	r25, Y+21	; 0x15
    4b24:	00 97       	sbiw	r24, 0x00	; 0
    4b26:	21 f0       	breq	.+8      	; 0x4b30 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4b28:	ce 01       	movw	r24, r28
    4b2a:	0c 96       	adiw	r24, 0x0c	; 12
    4b2c:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4b30:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    4b32:	2e 89       	ldd	r18, Y+22	; 0x16
    4b34:	80 91 dd 00 	lds	r24, 0x00DD
    4b38:	82 17       	cp	r24, r18
    4b3a:	10 f4       	brcc	.+4      	; 0x4b40 <vCoRoutineSchedule+0x102>
    4b3c:	20 93 dd 00 	sts	0x00DD, r18
    4b40:	30 e0       	ldi	r19, 0x00	; 0
    4b42:	c9 01       	movw	r24, r18
    4b44:	e3 e0       	ldi	r30, 0x03	; 3
    4b46:	88 0f       	add	r24, r24
    4b48:	99 1f       	adc	r25, r25
    4b4a:	ea 95       	dec	r30
    4b4c:	e1 f7       	brne	.-8      	; 0x4b46 <vCoRoutineSchedule+0x108>
    4b4e:	82 0f       	add	r24, r18
    4b50:	93 1f       	adc	r25, r19
    4b52:	82 52       	subi	r24, 0x22	; 34
    4b54:	9f 4f       	sbci	r25, 0xFF	; 255
    4b56:	b8 01       	movw	r22, r16
    4b58:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4b5c:	e0 91 f6 00 	lds	r30, 0x00F6
    4b60:	f0 91 f7 00 	lds	r31, 0x00F7
    4b64:	80 81       	ld	r24, Z
    4b66:	88 23       	and	r24, r24
    4b68:	31 f6       	brne	.-116    	; 0x4af6 <vCoRoutineSchedule+0xb8>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4b6a:	20 91 f2 00 	lds	r18, 0x00F2
    4b6e:	30 91 f3 00 	lds	r19, 0x00F3
    4b72:	80 91 f4 00 	lds	r24, 0x00F4
    4b76:	90 91 f5 00 	lds	r25, 0x00F5
    4b7a:	21 15       	cp	r18, r1
    4b7c:	31 05       	cpc	r19, r1
    4b7e:	09 f0       	breq	.+2      	; 0x4b82 <vCoRoutineSchedule+0x144>
    4b80:	9b cf       	rjmp	.-202    	; 0x4ab8 <vCoRoutineSchedule+0x7a>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    4b82:	90 93 f1 00 	sts	0x00F1, r25
    4b86:	80 93 f0 00 	sts	0x00F0, r24
    4b8a:	40 91 dd 00 	lds	r20, 0x00DD

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4b8e:	06 c0       	rjmp	.+12     	; 0x4b9c <vCoRoutineSchedule+0x15e>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4b90:	44 23       	and	r20, r20
    4b92:	19 f4       	brne	.+6      	; 0x4b9a <vCoRoutineSchedule+0x15c>
    4b94:	10 92 dd 00 	sts	0x00DD, r1
    4b98:	40 c0       	rjmp	.+128    	; 0x4c1a <vCoRoutineSchedule+0x1dc>
    4b9a:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4b9c:	84 2f       	mov	r24, r20
    4b9e:	90 e0       	ldi	r25, 0x00	; 0
    4ba0:	9c 01       	movw	r18, r24
    4ba2:	73 e0       	ldi	r23, 0x03	; 3
    4ba4:	22 0f       	add	r18, r18
    4ba6:	33 1f       	adc	r19, r19
    4ba8:	7a 95       	dec	r23
    4baa:	e1 f7       	brne	.-8      	; 0x4ba4 <vCoRoutineSchedule+0x166>
    4bac:	28 0f       	add	r18, r24
    4bae:	39 1f       	adc	r19, r25
    4bb0:	f9 01       	movw	r30, r18
    4bb2:	e2 52       	subi	r30, 0x22	; 34
    4bb4:	ff 4f       	sbci	r31, 0xFF	; 255
    4bb6:	50 81       	ld	r21, Z
    4bb8:	55 23       	and	r21, r21
    4bba:	51 f3       	breq	.-44     	; 0x4b90 <vCoRoutineSchedule+0x152>
    4bbc:	40 93 dd 00 	sts	0x00DD, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4bc0:	a1 81       	ldd	r26, Z+1	; 0x01
    4bc2:	b2 81       	ldd	r27, Z+2	; 0x02
    4bc4:	12 96       	adiw	r26, 0x02	; 2
    4bc6:	0d 90       	ld	r0, X+
    4bc8:	bc 91       	ld	r27, X
    4bca:	a0 2d       	mov	r26, r0
    4bcc:	b2 83       	std	Z+2, r27	; 0x02
    4bce:	a1 83       	std	Z+1, r26	; 0x01
    4bd0:	2f 51       	subi	r18, 0x1F	; 31
    4bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    4bd4:	a2 17       	cp	r26, r18
    4bd6:	b3 07       	cpc	r27, r19
    4bd8:	31 f4       	brne	.+12     	; 0x4be6 <vCoRoutineSchedule+0x1a8>
    4bda:	12 96       	adiw	r26, 0x02	; 2
    4bdc:	2d 91       	ld	r18, X+
    4bde:	3c 91       	ld	r19, X
    4be0:	13 97       	sbiw	r26, 0x03	; 3
    4be2:	32 83       	std	Z+2, r19	; 0x02
    4be4:	21 83       	std	Z+1, r18	; 0x01
    4be6:	fc 01       	movw	r30, r24
    4be8:	63 e0       	ldi	r22, 0x03	; 3
    4bea:	ee 0f       	add	r30, r30
    4bec:	ff 1f       	adc	r31, r31
    4bee:	6a 95       	dec	r22
    4bf0:	e1 f7       	brne	.-8      	; 0x4bea <vCoRoutineSchedule+0x1ac>
    4bf2:	e8 0f       	add	r30, r24
    4bf4:	f9 1f       	adc	r31, r25
    4bf6:	e2 52       	subi	r30, 0x22	; 34
    4bf8:	ff 4f       	sbci	r31, 0xFF	; 255
    4bfa:	01 80       	ldd	r0, Z+1	; 0x01
    4bfc:	f2 81       	ldd	r31, Z+2	; 0x02
    4bfe:	e0 2d       	mov	r30, r0
    4c00:	a6 81       	ldd	r26, Z+6	; 0x06
    4c02:	b7 81       	ldd	r27, Z+7	; 0x07
    4c04:	b0 93 d3 00 	sts	0x00D3, r27
    4c08:	a0 93 d2 00 	sts	0x00D2, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    4c0c:	ed 91       	ld	r30, X+
    4c0e:	fc 91       	ld	r31, X
    4c10:	11 97       	sbiw	r26, 0x01	; 1
    4c12:	cd 01       	movw	r24, r26
    4c14:	57 96       	adiw	r26, 0x17	; 23
    4c16:	6c 91       	ld	r22, X
    4c18:	09 95       	icall

	return;
}
    4c1a:	df 91       	pop	r29
    4c1c:	cf 91       	pop	r28
    4c1e:	1f 91       	pop	r17
    4c20:	0f 91       	pop	r16
    4c22:	08 95       	ret

00004c24 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    4c24:	0f 93       	push	r16
    4c26:	1f 93       	push	r17
    4c28:	cf 93       	push	r28
    4c2a:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4c2c:	dc 01       	movw	r26, r24
    4c2e:	15 96       	adiw	r26, 0x05	; 5
    4c30:	ed 91       	ld	r30, X+
    4c32:	fc 91       	ld	r31, X
    4c34:	16 97       	sbiw	r26, 0x06	; 6
    4c36:	c6 81       	ldd	r28, Z+6	; 0x06
    4c38:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4c3a:	8e 01       	movw	r16, r28
    4c3c:	04 5f       	subi	r16, 0xF4	; 244
    4c3e:	1f 4f       	sbci	r17, 0xFF	; 255
    4c40:	c8 01       	movw	r24, r16
    4c42:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    4c46:	84 ed       	ldi	r24, 0xD4	; 212
    4c48:	90 e0       	ldi	r25, 0x00	; 0
    4c4a:	b8 01       	movw	r22, r16
    4c4c:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    4c50:	e0 91 d2 00 	lds	r30, 0x00D2
    4c54:	f0 91 d3 00 	lds	r31, 0x00D3
	{
		xReturn = pdTRUE;
    4c58:	81 e0       	ldi	r24, 0x01	; 1
    4c5a:	2e 89       	ldd	r18, Y+22	; 0x16
    4c5c:	96 89       	ldd	r25, Z+22	; 0x16
    4c5e:	29 17       	cp	r18, r25
    4c60:	08 f4       	brcc	.+2      	; 0x4c64 <xCoRoutineRemoveFromEventList+0x40>
    4c62:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    4c64:	df 91       	pop	r29
    4c66:	cf 91       	pop	r28
    4c68:	1f 91       	pop	r17
    4c6a:	0f 91       	pop	r16
    4c6c:	08 95       	ret

00004c6e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4c6e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    4c70:	03 96       	adiw	r24, 0x03	; 3
    4c72:	92 83       	std	Z+2, r25	; 0x02
    4c74:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4c76:	2f ef       	ldi	r18, 0xFF	; 255
    4c78:	3f ef       	ldi	r19, 0xFF	; 255
    4c7a:	34 83       	std	Z+4, r19	; 0x04
    4c7c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    4c7e:	96 83       	std	Z+6, r25	; 0x06
    4c80:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    4c82:	90 87       	std	Z+8, r25	; 0x08
    4c84:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    4c86:	10 82       	st	Z, r1
}
    4c88:	08 95       	ret

00004c8a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    4c8a:	fc 01       	movw	r30, r24
    4c8c:	11 86       	std	Z+9, r1	; 0x09
    4c8e:	10 86       	std	Z+8, r1	; 0x08
}
    4c90:	08 95       	ret

00004c92 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4c92:	cf 93       	push	r28
    4c94:	df 93       	push	r29
    4c96:	fc 01       	movw	r30, r24
    4c98:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    4c9a:	21 81       	ldd	r18, Z+1	; 0x01
    4c9c:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    4c9e:	e9 01       	movw	r28, r18
    4ca0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ca2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ca4:	13 96       	adiw	r26, 0x03	; 3
    4ca6:	9c 93       	st	X, r25
    4ca8:	8e 93       	st	-X, r24
    4caa:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4cac:	15 96       	adiw	r26, 0x05	; 5
    4cae:	3c 93       	st	X, r19
    4cb0:	2e 93       	st	-X, r18
    4cb2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    4cb8:	ec 01       	movw	r28, r24
    4cba:	7d 83       	std	Y+5, r23	; 0x05
    4cbc:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    4cbe:	e9 01       	movw	r28, r18
    4cc0:	7b 83       	std	Y+3, r23	; 0x03
    4cc2:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4cc4:	72 83       	std	Z+2, r23	; 0x02
    4cc6:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4cc8:	19 96       	adiw	r26, 0x09	; 9
    4cca:	fc 93       	st	X, r31
    4ccc:	ee 93       	st	-X, r30
    4cce:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    4cd0:	80 81       	ld	r24, Z
    4cd2:	8f 5f       	subi	r24, 0xFF	; 255
    4cd4:	80 83       	st	Z, r24
}
    4cd6:	df 91       	pop	r29
    4cd8:	cf 91       	pop	r28
    4cda:	08 95       	ret

00004cdc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    4cdc:	cf 93       	push	r28
    4cde:	df 93       	push	r29
    4ce0:	ac 01       	movw	r20, r24
    4ce2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    4ce4:	88 81       	ld	r24, Y
    4ce6:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4ce8:	2f ef       	ldi	r18, 0xFF	; 255
    4cea:	8f 3f       	cpi	r24, 0xFF	; 255
    4cec:	92 07       	cpc	r25, r18
    4cee:	21 f4       	brne	.+8      	; 0x4cf8 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    4cf0:	fa 01       	movw	r30, r20
    4cf2:	a7 81       	ldd	r26, Z+7	; 0x07
    4cf4:	b0 85       	ldd	r27, Z+8	; 0x08
    4cf6:	11 c0       	rjmp	.+34     	; 0x4d1a <vListInsert+0x3e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    4cf8:	da 01       	movw	r26, r20
    4cfa:	13 96       	adiw	r26, 0x03	; 3
    4cfc:	04 c0       	rjmp	.+8      	; 0x4d06 <vListInsert+0x2a>
    4cfe:	12 96       	adiw	r26, 0x02	; 2
    4d00:	0d 90       	ld	r0, X+
    4d02:	bc 91       	ld	r27, X
    4d04:	a0 2d       	mov	r26, r0
    4d06:	12 96       	adiw	r26, 0x02	; 2
    4d08:	2d 91       	ld	r18, X+
    4d0a:	3c 91       	ld	r19, X
    4d0c:	13 97       	sbiw	r26, 0x03	; 3
    4d0e:	f9 01       	movw	r30, r18
    4d10:	20 81       	ld	r18, Z
    4d12:	31 81       	ldd	r19, Z+1	; 0x01
    4d14:	82 17       	cp	r24, r18
    4d16:	93 07       	cpc	r25, r19
    4d18:	90 f7       	brcc	.-28     	; 0x4cfe <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4d1a:	12 96       	adiw	r26, 0x02	; 2
    4d1c:	8d 91       	ld	r24, X+
    4d1e:	9c 91       	ld	r25, X
    4d20:	13 97       	sbiw	r26, 0x03	; 3
    4d22:	9b 83       	std	Y+3, r25	; 0x03
    4d24:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4d26:	fc 01       	movw	r30, r24
    4d28:	d5 83       	std	Z+5, r29	; 0x05
    4d2a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4d2c:	bd 83       	std	Y+5, r27	; 0x05
    4d2e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    4d30:	13 96       	adiw	r26, 0x03	; 3
    4d32:	dc 93       	st	X, r29
    4d34:	ce 93       	st	-X, r28
    4d36:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4d38:	59 87       	std	Y+9, r21	; 0x09
    4d3a:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    4d3c:	fa 01       	movw	r30, r20
    4d3e:	80 81       	ld	r24, Z
    4d40:	8f 5f       	subi	r24, 0xFF	; 255
    4d42:	80 83       	st	Z, r24
}
    4d44:	df 91       	pop	r29
    4d46:	cf 91       	pop	r28
    4d48:	08 95       	ret

00004d4a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4d4a:	cf 93       	push	r28
    4d4c:	df 93       	push	r29
    4d4e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4d50:	a2 81       	ldd	r26, Z+2	; 0x02
    4d52:	b3 81       	ldd	r27, Z+3	; 0x03
    4d54:	84 81       	ldd	r24, Z+4	; 0x04
    4d56:	95 81       	ldd	r25, Z+5	; 0x05
    4d58:	15 96       	adiw	r26, 0x05	; 5
    4d5a:	9c 93       	st	X, r25
    4d5c:	8e 93       	st	-X, r24
    4d5e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4d60:	c4 81       	ldd	r28, Z+4	; 0x04
    4d62:	d5 81       	ldd	r29, Z+5	; 0x05
    4d64:	bb 83       	std	Y+3, r27	; 0x03
    4d66:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    4d68:	a0 85       	ldd	r26, Z+8	; 0x08
    4d6a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4d6c:	11 96       	adiw	r26, 0x01	; 1
    4d6e:	8d 91       	ld	r24, X+
    4d70:	9c 91       	ld	r25, X
    4d72:	12 97       	sbiw	r26, 0x02	; 2
    4d74:	8e 17       	cp	r24, r30
    4d76:	9f 07       	cpc	r25, r31
    4d78:	21 f4       	brne	.+8      	; 0x4d82 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    4d7a:	12 96       	adiw	r26, 0x02	; 2
    4d7c:	dc 93       	st	X, r29
    4d7e:	ce 93       	st	-X, r28
    4d80:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    4d82:	11 86       	std	Z+9, r1	; 0x09
    4d84:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4d86:	8c 91       	ld	r24, X
    4d88:	81 50       	subi	r24, 0x01	; 1
    4d8a:	8c 93       	st	X, r24
}
    4d8c:	df 91       	pop	r29
    4d8e:	cf 91       	pop	r28
    4d90:	08 95       	ret

00004d92 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4d92:	0f 93       	push	r16
    4d94:	1f 93       	push	r17
    4d96:	cf 93       	push	r28
    4d98:	df 93       	push	r29
    4d9a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4d9c:	0f b6       	in	r0, 0x3f	; 63
    4d9e:	f8 94       	cli
    4da0:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4da2:	8c 01       	movw	r16, r24
    4da4:	0f 5e       	subi	r16, 0xEF	; 239
    4da6:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4da8:	0d c0       	rjmp	.+26     	; 0x4dc4 <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4daa:	89 89       	ldd	r24, Y+17	; 0x11
    4dac:	88 23       	and	r24, r24
    4dae:	69 f0       	breq	.+26     	; 0x4dca <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4db0:	c8 01       	movw	r24, r16
    4db2:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    4db6:	88 23       	and	r24, r24
    4db8:	11 f0       	breq	.+4      	; 0x4dbe <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4dba:	0e 94 e8 2d 	call	0x5bd0	; 0x5bd0 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    4dbe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4dc0:	81 50       	subi	r24, 0x01	; 1
    4dc2:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4dc4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4dc6:	18 16       	cp	r1, r24
    4dc8:	84 f3       	brlt	.-32     	; 0x4daa <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4dca:	8f ef       	ldi	r24, 0xFF	; 255
    4dcc:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4dce:	0f 90       	pop	r0
    4dd0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4dd2:	0f b6       	in	r0, 0x3f	; 63
    4dd4:	f8 94       	cli
    4dd6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4dd8:	8e 01       	movw	r16, r28
    4dda:	08 5f       	subi	r16, 0xF8	; 248
    4ddc:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4dde:	0d c0       	rjmp	.+26     	; 0x4dfa <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4de0:	88 85       	ldd	r24, Y+8	; 0x08
    4de2:	88 23       	and	r24, r24
    4de4:	69 f0       	breq	.+26     	; 0x4e00 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4de6:	c8 01       	movw	r24, r16
    4de8:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    4dec:	88 23       	and	r24, r24
    4dee:	11 f0       	breq	.+4      	; 0x4df4 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    4df0:	0e 94 e8 2d 	call	0x5bd0	; 0x5bd0 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4df4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4df6:	81 50       	subi	r24, 0x01	; 1
    4df8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4dfa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4dfc:	18 16       	cp	r1, r24
    4dfe:	84 f3       	brlt	.-32     	; 0x4de0 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4e00:	8f ef       	ldi	r24, 0xFF	; 255
    4e02:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4e04:	0f 90       	pop	r0
    4e06:	0f be       	out	0x3f, r0	; 63
}
    4e08:	df 91       	pop	r29
    4e0a:	cf 91       	pop	r28
    4e0c:	1f 91       	pop	r17
    4e0e:	0f 91       	pop	r16
    4e10:	08 95       	ret

00004e12 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    4e12:	af 92       	push	r10
    4e14:	bf 92       	push	r11
    4e16:	cf 92       	push	r12
    4e18:	df 92       	push	r13
    4e1a:	ef 92       	push	r14
    4e1c:	ff 92       	push	r15
    4e1e:	0f 93       	push	r16
    4e20:	1f 93       	push	r17
    4e22:	cf 93       	push	r28
    4e24:	df 93       	push	r29
    4e26:	b8 2e       	mov	r11, r24
    4e28:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4e2a:	88 23       	and	r24, r24
    4e2c:	09 f4       	brne	.+2      	; 0x4e30 <xQueueCreate+0x1e>
    4e2e:	43 c0       	rjmp	.+134    	; 0x4eb6 <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4e30:	8f e1       	ldi	r24, 0x1F	; 31
    4e32:	90 e0       	ldi	r25, 0x00	; 0
    4e34:	0e 94 23 2f 	call	0x5e46	; 0x5e46 <pvPortMalloc>
    4e38:	e8 2e       	mov	r14, r24
    4e3a:	e7 01       	movw	r28, r14
    4e3c:	7e 01       	movw	r14, r28
    4e3e:	f9 2e       	mov	r15, r25
    4e40:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    4e42:	20 97       	sbiw	r28, 0x00	; 0
    4e44:	c1 f1       	breq	.+112    	; 0x4eb6 <xQueueCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4e46:	0b 2d       	mov	r16, r11
    4e48:	10 e0       	ldi	r17, 0x00	; 0
    4e4a:	ca 2c       	mov	r12, r10
    4e4c:	dd 24       	eor	r13, r13
    4e4e:	c0 9e       	mul	r12, r16
    4e50:	70 01       	movw	r14, r0
    4e52:	c1 9e       	mul	r12, r17
    4e54:	f0 0c       	add	r15, r0
    4e56:	d0 9e       	mul	r13, r16
    4e58:	f0 0c       	add	r15, r0
    4e5a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4e5c:	c7 01       	movw	r24, r14
    4e5e:	01 96       	adiw	r24, 0x01	; 1
    4e60:	0e 94 23 2f 	call	0x5e46	; 0x5e46 <pvPortMalloc>
    4e64:	99 83       	std	Y+1, r25	; 0x01
    4e66:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    4e68:	00 97       	sbiw	r24, 0x00	; 0
    4e6a:	11 f1       	breq	.+68     	; 0x4eb0 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4e6c:	e8 0e       	add	r14, r24
    4e6e:	f9 1e       	adc	r15, r25
    4e70:	fb 82       	std	Y+3, r15	; 0x03
    4e72:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4e74:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    4e76:	9d 83       	std	Y+5, r25	; 0x05
    4e78:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    4e7a:	01 50       	subi	r16, 0x01	; 1
    4e7c:	10 40       	sbci	r17, 0x00	; 0
    4e7e:	0c 9d       	mul	r16, r12
    4e80:	a0 01       	movw	r20, r0
    4e82:	0d 9d       	mul	r16, r13
    4e84:	50 0d       	add	r21, r0
    4e86:	1c 9d       	mul	r17, r12
    4e88:	50 0d       	add	r21, r0
    4e8a:	11 24       	eor	r1, r1
    4e8c:	48 0f       	add	r20, r24
    4e8e:	59 1f       	adc	r21, r25
    4e90:	5f 83       	std	Y+7, r21	; 0x07
    4e92:	4e 83       	std	Y+6, r20	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    4e94:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    4e96:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    4e98:	8f ef       	ldi	r24, 0xFF	; 255
    4e9a:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    4e9c:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4e9e:	ce 01       	movw	r24, r28
    4ea0:	08 96       	adiw	r24, 0x08	; 8
    4ea2:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4ea6:	ce 01       	movw	r24, r28
    4ea8:	41 96       	adiw	r24, 0x11	; 17
    4eaa:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
    4eae:	05 c0       	rjmp	.+10     	; 0x4eba <xQueueCreate+0xa8>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    4eb0:	ce 01       	movw	r24, r28
    4eb2:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4eb6:	c0 e0       	ldi	r28, 0x00	; 0
    4eb8:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    4eba:	ce 01       	movw	r24, r28
    4ebc:	df 91       	pop	r29
    4ebe:	cf 91       	pop	r28
    4ec0:	1f 91       	pop	r17
    4ec2:	0f 91       	pop	r16
    4ec4:	ff 90       	pop	r15
    4ec6:	ef 90       	pop	r14
    4ec8:	df 90       	pop	r13
    4eca:	cf 90       	pop	r12
    4ecc:	bf 90       	pop	r11
    4ece:	af 90       	pop	r10
    4ed0:	08 95       	ret

00004ed2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4ed2:	7f 92       	push	r7
    4ed4:	8f 92       	push	r8
    4ed6:	9f 92       	push	r9
    4ed8:	af 92       	push	r10
    4eda:	bf 92       	push	r11
    4edc:	cf 92       	push	r12
    4ede:	df 92       	push	r13
    4ee0:	ef 92       	push	r14
    4ee2:	ff 92       	push	r15
    4ee4:	0f 93       	push	r16
    4ee6:	1f 93       	push	r17
    4ee8:	df 93       	push	r29
    4eea:	cf 93       	push	r28
    4eec:	00 d0       	rcall	.+0      	; 0x4eee <xQueueGenericSend+0x1c>
    4eee:	00 d0       	rcall	.+0      	; 0x4ef0 <xQueueGenericSend+0x1e>
    4ef0:	0f 92       	push	r0
    4ef2:	cd b7       	in	r28, 0x3d	; 61
    4ef4:	de b7       	in	r29, 0x3e	; 62
    4ef6:	8c 01       	movw	r16, r24
    4ef8:	6b 01       	movw	r12, r22
    4efa:	5d 83       	std	Y+5, r21	; 0x05
    4efc:	4c 83       	std	Y+4, r20	; 0x04
    4efe:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4f00:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4f02:	7e 01       	movw	r14, r28
    4f04:	08 94       	sec
    4f06:	e1 1c       	adc	r14, r1
    4f08:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4f0a:	94 e0       	ldi	r25, 0x04	; 4
    4f0c:	a9 2e       	mov	r10, r25
    4f0e:	b1 2c       	mov	r11, r1
    4f10:	ac 0e       	add	r10, r28
    4f12:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4f14:	88 e0       	ldi	r24, 0x08	; 8
    4f16:	88 2e       	mov	r8, r24
    4f18:	91 2c       	mov	r9, r1
    4f1a:	80 0e       	add	r8, r16
    4f1c:	91 1e       	adc	r9, r17
    4f1e:	01 c0       	rjmp	.+2      	; 0x4f22 <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4f20:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4f22:	0f b6       	in	r0, 0x3f	; 63
    4f24:	f8 94       	cli
    4f26:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4f28:	f8 01       	movw	r30, r16
    4f2a:	92 8d       	ldd	r25, Z+26	; 0x1a
    4f2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    4f2e:	98 17       	cp	r25, r24
    4f30:	08 f0       	brcs	.+2      	; 0x4f34 <xQueueGenericSend+0x62>
    4f32:	4e c0       	rjmp	.+156    	; 0x4fd0 <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    4f34:	44 8d       	ldd	r20, Z+28	; 0x1c
    4f36:	44 23       	and	r20, r20
    4f38:	c1 f1       	breq	.+112    	; 0x4faa <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    4f3a:	77 20       	and	r7, r7
    4f3c:	c1 f4       	brne	.+48     	; 0x4f6e <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4f3e:	84 81       	ldd	r24, Z+4	; 0x04
    4f40:	95 81       	ldd	r25, Z+5	; 0x05
    4f42:	b6 01       	movw	r22, r12
    4f44:	50 e0       	ldi	r21, 0x00	; 0
    4f46:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4f4a:	f8 01       	movw	r30, r16
    4f4c:	24 8d       	ldd	r18, Z+28	; 0x1c
    4f4e:	84 81       	ldd	r24, Z+4	; 0x04
    4f50:	95 81       	ldd	r25, Z+5	; 0x05
    4f52:	82 0f       	add	r24, r18
    4f54:	91 1d       	adc	r25, r1
    4f56:	95 83       	std	Z+5, r25	; 0x05
    4f58:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    4f5a:	22 81       	ldd	r18, Z+2	; 0x02
    4f5c:	33 81       	ldd	r19, Z+3	; 0x03
    4f5e:	82 17       	cp	r24, r18
    4f60:	93 07       	cpc	r25, r19
    4f62:	18 f1       	brcs	.+70     	; 0x4faa <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4f64:	80 81       	ld	r24, Z
    4f66:	91 81       	ldd	r25, Z+1	; 0x01
    4f68:	95 83       	std	Z+5, r25	; 0x05
    4f6a:	84 83       	std	Z+4, r24	; 0x04
    4f6c:	1e c0       	rjmp	.+60     	; 0x4faa <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4f6e:	f8 01       	movw	r30, r16
    4f70:	86 81       	ldd	r24, Z+6	; 0x06
    4f72:	97 81       	ldd	r25, Z+7	; 0x07
    4f74:	b6 01       	movw	r22, r12
    4f76:	50 e0       	ldi	r21, 0x00	; 0
    4f78:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    4f7c:	f8 01       	movw	r30, r16
    4f7e:	24 8d       	ldd	r18, Z+28	; 0x1c
    4f80:	30 e0       	ldi	r19, 0x00	; 0
    4f82:	30 95       	com	r19
    4f84:	21 95       	neg	r18
    4f86:	3f 4f       	sbci	r19, 0xFF	; 255
    4f88:	86 81       	ldd	r24, Z+6	; 0x06
    4f8a:	97 81       	ldd	r25, Z+7	; 0x07
    4f8c:	82 0f       	add	r24, r18
    4f8e:	93 1f       	adc	r25, r19
    4f90:	97 83       	std	Z+7, r25	; 0x07
    4f92:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4f94:	40 81       	ld	r20, Z
    4f96:	51 81       	ldd	r21, Z+1	; 0x01
    4f98:	84 17       	cp	r24, r20
    4f9a:	95 07       	cpc	r25, r21
    4f9c:	30 f4       	brcc	.+12     	; 0x4faa <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4f9e:	82 81       	ldd	r24, Z+2	; 0x02
    4fa0:	93 81       	ldd	r25, Z+3	; 0x03
    4fa2:	82 0f       	add	r24, r18
    4fa4:	93 1f       	adc	r25, r19
    4fa6:	97 83       	std	Z+7, r25	; 0x07
    4fa8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4faa:	f8 01       	movw	r30, r16
    4fac:	82 8d       	ldd	r24, Z+26	; 0x1a
    4fae:	8f 5f       	subi	r24, 0xFF	; 255
    4fb0:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4fb2:	81 89       	ldd	r24, Z+17	; 0x11
    4fb4:	88 23       	and	r24, r24
    4fb6:	41 f0       	breq	.+16     	; 0x4fc8 <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    4fb8:	c8 01       	movw	r24, r16
    4fba:	41 96       	adiw	r24, 0x11	; 17
    4fbc:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    4fc0:	81 30       	cpi	r24, 0x01	; 1
    4fc2:	11 f4       	brne	.+4      	; 0x4fc8 <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    4fc4:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    4fc8:	0f 90       	pop	r0
    4fca:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    4fcc:	81 e0       	ldi	r24, 0x01	; 1
    4fce:	4c c0       	rjmp	.+152    	; 0x5068 <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    4fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    4fd4:	00 97       	sbiw	r24, 0x00	; 0
    4fd6:	19 f4       	brne	.+6      	; 0x4fde <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4fd8:	0f 90       	pop	r0
    4fda:	0f be       	out	0x3f, r0	; 63
    4fdc:	44 c0       	rjmp	.+136    	; 0x5066 <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    4fde:	22 23       	and	r18, r18
    4fe0:	19 f4       	brne	.+6      	; 0x4fe8 <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4fe2:	c7 01       	movw	r24, r14
    4fe4:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    4fe8:	0f 90       	pop	r0
    4fea:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4fec:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4ff0:	0f b6       	in	r0, 0x3f	; 63
    4ff2:	f8 94       	cli
    4ff4:	0f 92       	push	r0
    4ff6:	f8 01       	movw	r30, r16
    4ff8:	85 8d       	ldd	r24, Z+29	; 0x1d
    4ffa:	8f 3f       	cpi	r24, 0xFF	; 255
    4ffc:	09 f4       	brne	.+2      	; 0x5000 <xQueueGenericSend+0x12e>
    4ffe:	15 8e       	std	Z+29, r1	; 0x1d
    5000:	f8 01       	movw	r30, r16
    5002:	86 8d       	ldd	r24, Z+30	; 0x1e
    5004:	8f 3f       	cpi	r24, 0xFF	; 255
    5006:	09 f4       	brne	.+2      	; 0x500a <xQueueGenericSend+0x138>
    5008:	16 8e       	std	Z+30, r1	; 0x1e
    500a:	0f 90       	pop	r0
    500c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    500e:	c7 01       	movw	r24, r14
    5010:	b5 01       	movw	r22, r10
    5012:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <xTaskCheckForTimeOut>
    5016:	88 23       	and	r24, r24
    5018:	09 f5       	brne	.+66     	; 0x505c <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    501a:	0f b6       	in	r0, 0x3f	; 63
    501c:	f8 94       	cli
    501e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5020:	f8 01       	movw	r30, r16
    5022:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5024:	0f 90       	pop	r0
    5026:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5028:	f8 01       	movw	r30, r16
    502a:	83 8d       	ldd	r24, Z+27	; 0x1b
    502c:	98 17       	cp	r25, r24
    502e:	81 f4       	brne	.+32     	; 0x5050 <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5030:	6c 81       	ldd	r22, Y+4	; 0x04
    5032:	7d 81       	ldd	r23, Y+5	; 0x05
    5034:	c4 01       	movw	r24, r8
    5036:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    503a:	c8 01       	movw	r24, r16
    503c:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5040:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
    5044:	88 23       	and	r24, r24
    5046:	09 f0       	breq	.+2      	; 0x504a <xQueueGenericSend+0x178>
    5048:	6b cf       	rjmp	.-298    	; 0x4f20 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    504a:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
    504e:	68 cf       	rjmp	.-304    	; 0x4f20 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5050:	c8 01       	movw	r24, r16
    5052:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5056:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
    505a:	62 cf       	rjmp	.-316    	; 0x4f20 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    505c:	c8 01       	movw	r24, r16
    505e:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5062:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5066:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    5068:	0f 90       	pop	r0
    506a:	0f 90       	pop	r0
    506c:	0f 90       	pop	r0
    506e:	0f 90       	pop	r0
    5070:	0f 90       	pop	r0
    5072:	cf 91       	pop	r28
    5074:	df 91       	pop	r29
    5076:	1f 91       	pop	r17
    5078:	0f 91       	pop	r16
    507a:	ff 90       	pop	r15
    507c:	ef 90       	pop	r14
    507e:	df 90       	pop	r13
    5080:	cf 90       	pop	r12
    5082:	bf 90       	pop	r11
    5084:	af 90       	pop	r10
    5086:	9f 90       	pop	r9
    5088:	8f 90       	pop	r8
    508a:	7f 90       	pop	r7
    508c:	08 95       	ret

0000508e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    508e:	0f 93       	push	r16
    5090:	1f 93       	push	r17
    5092:	cf 93       	push	r28
    5094:	df 93       	push	r29
    5096:	ec 01       	movw	r28, r24
    5098:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    509a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    509c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    509e:	98 17       	cp	r25, r24
    50a0:	08 f0       	brcs	.+2      	; 0x50a4 <xQueueGenericSendFromISR+0x16>
    50a2:	4c c0       	rjmp	.+152    	; 0x513c <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    50a4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    50a6:	44 23       	and	r20, r20
    50a8:	99 f1       	breq	.+102    	; 0x5110 <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    50aa:	22 23       	and	r18, r18
    50ac:	b1 f4       	brne	.+44     	; 0x50da <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    50ae:	8c 81       	ldd	r24, Y+4	; 0x04
    50b0:	9d 81       	ldd	r25, Y+5	; 0x05
    50b2:	50 e0       	ldi	r21, 0x00	; 0
    50b4:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    50b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    50ba:	8c 81       	ldd	r24, Y+4	; 0x04
    50bc:	9d 81       	ldd	r25, Y+5	; 0x05
    50be:	82 0f       	add	r24, r18
    50c0:	91 1d       	adc	r25, r1
    50c2:	9d 83       	std	Y+5, r25	; 0x05
    50c4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    50c6:	2a 81       	ldd	r18, Y+2	; 0x02
    50c8:	3b 81       	ldd	r19, Y+3	; 0x03
    50ca:	82 17       	cp	r24, r18
    50cc:	93 07       	cpc	r25, r19
    50ce:	00 f1       	brcs	.+64     	; 0x5110 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    50d0:	88 81       	ld	r24, Y
    50d2:	99 81       	ldd	r25, Y+1	; 0x01
    50d4:	9d 83       	std	Y+5, r25	; 0x05
    50d6:	8c 83       	std	Y+4, r24	; 0x04
    50d8:	1b c0       	rjmp	.+54     	; 0x5110 <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    50da:	8e 81       	ldd	r24, Y+6	; 0x06
    50dc:	9f 81       	ldd	r25, Y+7	; 0x07
    50de:	50 e0       	ldi	r21, 0x00	; 0
    50e0:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    50e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    50e6:	30 e0       	ldi	r19, 0x00	; 0
    50e8:	30 95       	com	r19
    50ea:	21 95       	neg	r18
    50ec:	3f 4f       	sbci	r19, 0xFF	; 255
    50ee:	8e 81       	ldd	r24, Y+6	; 0x06
    50f0:	9f 81       	ldd	r25, Y+7	; 0x07
    50f2:	82 0f       	add	r24, r18
    50f4:	93 1f       	adc	r25, r19
    50f6:	9f 83       	std	Y+7, r25	; 0x07
    50f8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    50fa:	48 81       	ld	r20, Y
    50fc:	59 81       	ldd	r21, Y+1	; 0x01
    50fe:	84 17       	cp	r24, r20
    5100:	95 07       	cpc	r25, r21
    5102:	30 f4       	brcc	.+12     	; 0x5110 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    5104:	8a 81       	ldd	r24, Y+2	; 0x02
    5106:	9b 81       	ldd	r25, Y+3	; 0x03
    5108:	82 0f       	add	r24, r18
    510a:	93 1f       	adc	r25, r19
    510c:	9f 83       	std	Y+7, r25	; 0x07
    510e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    5110:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5112:	8f 5f       	subi	r24, 0xFF	; 255
    5114:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    5116:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5118:	8f 3f       	cpi	r24, 0xFF	; 255
    511a:	69 f4       	brne	.+26     	; 0x5136 <xQueueGenericSendFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    511c:	89 89       	ldd	r24, Y+17	; 0x11
    511e:	88 23       	and	r24, r24
    5120:	79 f0       	breq	.+30     	; 0x5140 <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5122:	ce 01       	movw	r24, r28
    5124:	41 96       	adiw	r24, 0x11	; 17
    5126:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    512a:	88 23       	and	r24, r24
    512c:	49 f0       	breq	.+18     	; 0x5140 <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    512e:	81 e0       	ldi	r24, 0x01	; 1
    5130:	f8 01       	movw	r30, r16
    5132:	80 83       	st	Z, r24
    5134:	06 c0       	rjmp	.+12     	; 0x5142 <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5136:	8f 5f       	subi	r24, 0xFF	; 255
    5138:	8e 8f       	std	Y+30, r24	; 0x1e
    513a:	02 c0       	rjmp	.+4      	; 0x5140 <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    513c:	80 e0       	ldi	r24, 0x00	; 0
    513e:	01 c0       	rjmp	.+2      	; 0x5142 <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    5140:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5142:	df 91       	pop	r29
    5144:	cf 91       	pop	r28
    5146:	1f 91       	pop	r17
    5148:	0f 91       	pop	r16
    514a:	08 95       	ret

0000514c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    514c:	7f 92       	push	r7
    514e:	8f 92       	push	r8
    5150:	9f 92       	push	r9
    5152:	af 92       	push	r10
    5154:	bf 92       	push	r11
    5156:	cf 92       	push	r12
    5158:	df 92       	push	r13
    515a:	ef 92       	push	r14
    515c:	ff 92       	push	r15
    515e:	0f 93       	push	r16
    5160:	1f 93       	push	r17
    5162:	df 93       	push	r29
    5164:	cf 93       	push	r28
    5166:	00 d0       	rcall	.+0      	; 0x5168 <xQueueGenericReceive+0x1c>
    5168:	00 d0       	rcall	.+0      	; 0x516a <xQueueGenericReceive+0x1e>
    516a:	0f 92       	push	r0
    516c:	cd b7       	in	r28, 0x3d	; 61
    516e:	de b7       	in	r29, 0x3e	; 62
    5170:	8c 01       	movw	r16, r24
    5172:	86 2e       	mov	r8, r22
    5174:	77 2e       	mov	r7, r23
    5176:	5d 83       	std	Y+5, r21	; 0x05
    5178:	4c 83       	std	Y+4, r20	; 0x04
    517a:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    517c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    517e:	7e 01       	movw	r14, r28
    5180:	08 94       	sec
    5182:	e1 1c       	adc	r14, r1
    5184:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5186:	44 e0       	ldi	r20, 0x04	; 4
    5188:	c4 2e       	mov	r12, r20
    518a:	d1 2c       	mov	r13, r1
    518c:	cc 0e       	add	r12, r28
    518e:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5190:	31 e1       	ldi	r19, 0x11	; 17
    5192:	a3 2e       	mov	r10, r19
    5194:	b1 2c       	mov	r11, r1
    5196:	a8 0e       	add	r10, r24
    5198:	b9 1e       	adc	r11, r25
    519a:	01 c0       	rjmp	.+2      	; 0x519e <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    519c:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    519e:	0f b6       	in	r0, 0x3f	; 63
    51a0:	f8 94       	cli
    51a2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    51a4:	f8 01       	movw	r30, r16
    51a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    51a8:	88 23       	and	r24, r24
    51aa:	09 f4       	brne	.+2      	; 0x51ae <xQueueGenericReceive+0x62>
    51ac:	3d c0       	rjmp	.+122    	; 0x5228 <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    51ae:	e6 80       	ldd	r14, Z+6	; 0x06
    51b0:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    51b2:	80 81       	ld	r24, Z
    51b4:	91 81       	ldd	r25, Z+1	; 0x01
    51b6:	00 97       	sbiw	r24, 0x00	; 0
    51b8:	a9 f0       	breq	.+42     	; 0x51e4 <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    51ba:	44 8d       	ldd	r20, Z+28	; 0x1c
    51bc:	97 01       	movw	r18, r14
    51be:	24 0f       	add	r18, r20
    51c0:	31 1d       	adc	r19, r1
    51c2:	37 83       	std	Z+7, r19	; 0x07
    51c4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    51c6:	62 81       	ldd	r22, Z+2	; 0x02
    51c8:	73 81       	ldd	r23, Z+3	; 0x03
    51ca:	26 17       	cp	r18, r22
    51cc:	37 07       	cpc	r19, r23
    51ce:	10 f0       	brcs	.+4      	; 0x51d4 <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    51d0:	97 83       	std	Z+7, r25	; 0x07
    51d2:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    51d4:	f8 01       	movw	r30, r16
    51d6:	66 81       	ldd	r22, Z+6	; 0x06
    51d8:	77 81       	ldd	r23, Z+7	; 0x07
    51da:	88 2d       	mov	r24, r8
    51dc:	97 2d       	mov	r25, r7
    51de:	50 e0       	ldi	r21, 0x00	; 0
    51e0:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    51e4:	99 20       	and	r9, r9
    51e6:	71 f4       	brne	.+28     	; 0x5204 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    51e8:	f8 01       	movw	r30, r16
    51ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    51ec:	81 50       	subi	r24, 0x01	; 1
    51ee:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    51f0:	80 85       	ldd	r24, Z+8	; 0x08
    51f2:	88 23       	and	r24, r24
    51f4:	a9 f0       	breq	.+42     	; 0x5220 <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    51f6:	c8 01       	movw	r24, r16
    51f8:	08 96       	adiw	r24, 0x08	; 8
    51fa:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    51fe:	81 30       	cpi	r24, 0x01	; 1
    5200:	79 f4       	brne	.+30     	; 0x5220 <xQueueGenericReceive+0xd4>
    5202:	0c c0       	rjmp	.+24     	; 0x521c <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5204:	f8 01       	movw	r30, r16
    5206:	f7 82       	std	Z+7, r15	; 0x07
    5208:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    520a:	81 89       	ldd	r24, Z+17	; 0x11
    520c:	88 23       	and	r24, r24
    520e:	41 f0       	breq	.+16     	; 0x5220 <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5210:	c8 01       	movw	r24, r16
    5212:	41 96       	adiw	r24, 0x11	; 17
    5214:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    5218:	88 23       	and	r24, r24
    521a:	11 f0       	breq	.+4      	; 0x5220 <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    521c:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    5220:	0f 90       	pop	r0
    5222:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5224:	81 e0       	ldi	r24, 0x01	; 1
    5226:	4a c0       	rjmp	.+148    	; 0x52bc <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5228:	8c 81       	ldd	r24, Y+4	; 0x04
    522a:	9d 81       	ldd	r25, Y+5	; 0x05
    522c:	00 97       	sbiw	r24, 0x00	; 0
    522e:	19 f4       	brne	.+6      	; 0x5236 <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5230:	0f 90       	pop	r0
    5232:	0f be       	out	0x3f, r0	; 63
    5234:	42 c0       	rjmp	.+132    	; 0x52ba <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    5236:	22 23       	and	r18, r18
    5238:	19 f4       	brne	.+6      	; 0x5240 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    523a:	c7 01       	movw	r24, r14
    523c:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    5240:	0f 90       	pop	r0
    5242:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5244:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5248:	0f b6       	in	r0, 0x3f	; 63
    524a:	f8 94       	cli
    524c:	0f 92       	push	r0
    524e:	f8 01       	movw	r30, r16
    5250:	85 8d       	ldd	r24, Z+29	; 0x1d
    5252:	8f 3f       	cpi	r24, 0xFF	; 255
    5254:	09 f4       	brne	.+2      	; 0x5258 <xQueueGenericReceive+0x10c>
    5256:	15 8e       	std	Z+29, r1	; 0x1d
    5258:	f8 01       	movw	r30, r16
    525a:	86 8d       	ldd	r24, Z+30	; 0x1e
    525c:	8f 3f       	cpi	r24, 0xFF	; 255
    525e:	09 f4       	brne	.+2      	; 0x5262 <xQueueGenericReceive+0x116>
    5260:	16 8e       	std	Z+30, r1	; 0x1e
    5262:	0f 90       	pop	r0
    5264:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5266:	c7 01       	movw	r24, r14
    5268:	b6 01       	movw	r22, r12
    526a:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <xTaskCheckForTimeOut>
    526e:	88 23       	and	r24, r24
    5270:	f9 f4       	brne	.+62     	; 0x52b0 <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5272:	0f b6       	in	r0, 0x3f	; 63
    5274:	f8 94       	cli
    5276:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5278:	f8 01       	movw	r30, r16
    527a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    527c:	0f 90       	pop	r0
    527e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5280:	88 23       	and	r24, r24
    5282:	81 f4       	brne	.+32     	; 0x52a4 <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5284:	6c 81       	ldd	r22, Y+4	; 0x04
    5286:	7d 81       	ldd	r23, Y+5	; 0x05
    5288:	c5 01       	movw	r24, r10
    528a:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    528e:	c8 01       	movw	r24, r16
    5290:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5294:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
    5298:	88 23       	and	r24, r24
    529a:	09 f0       	breq	.+2      	; 0x529e <xQueueGenericReceive+0x152>
    529c:	7f cf       	rjmp	.-258    	; 0x519c <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    529e:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
    52a2:	7c cf       	rjmp	.-264    	; 0x519c <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    52a4:	c8 01       	movw	r24, r16
    52a6:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    52aa:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
    52ae:	76 cf       	rjmp	.-276    	; 0x519c <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    52b0:	c8 01       	movw	r24, r16
    52b2:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    52b6:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    52ba:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    52bc:	0f 90       	pop	r0
    52be:	0f 90       	pop	r0
    52c0:	0f 90       	pop	r0
    52c2:	0f 90       	pop	r0
    52c4:	0f 90       	pop	r0
    52c6:	cf 91       	pop	r28
    52c8:	df 91       	pop	r29
    52ca:	1f 91       	pop	r17
    52cc:	0f 91       	pop	r16
    52ce:	ff 90       	pop	r15
    52d0:	ef 90       	pop	r14
    52d2:	df 90       	pop	r13
    52d4:	cf 90       	pop	r12
    52d6:	bf 90       	pop	r11
    52d8:	af 90       	pop	r10
    52da:	9f 90       	pop	r9
    52dc:	8f 90       	pop	r8
    52de:	7f 90       	pop	r7
    52e0:	08 95       	ret

000052e2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    52e2:	0f 93       	push	r16
    52e4:	1f 93       	push	r17
    52e6:	cf 93       	push	r28
    52e8:	df 93       	push	r29
    52ea:	ec 01       	movw	r28, r24
    52ec:	cb 01       	movw	r24, r22
    52ee:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    52f0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    52f2:	22 23       	and	r18, r18
    52f4:	71 f1       	breq	.+92     	; 0x5352 <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    52f6:	e8 81       	ld	r30, Y
    52f8:	f9 81       	ldd	r31, Y+1	; 0x01
    52fa:	30 97       	sbiw	r30, 0x00	; 0
    52fc:	a1 f0       	breq	.+40     	; 0x5326 <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    52fe:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5300:	2e 81       	ldd	r18, Y+6	; 0x06
    5302:	3f 81       	ldd	r19, Y+7	; 0x07
    5304:	24 0f       	add	r18, r20
    5306:	31 1d       	adc	r19, r1
    5308:	3f 83       	std	Y+7, r19	; 0x07
    530a:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    530c:	aa 81       	ldd	r26, Y+2	; 0x02
    530e:	bb 81       	ldd	r27, Y+3	; 0x03
    5310:	2a 17       	cp	r18, r26
    5312:	3b 07       	cpc	r19, r27
    5314:	10 f0       	brcs	.+4      	; 0x531a <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    5316:	ff 83       	std	Y+7, r31	; 0x07
    5318:	ee 83       	std	Y+6, r30	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    531a:	6e 81       	ldd	r22, Y+6	; 0x06
    531c:	2f 81       	ldd	r18, Y+7	; 0x07
    531e:	72 2f       	mov	r23, r18
    5320:	50 e0       	ldi	r21, 0x00	; 0
    5322:	0e 94 43 32 	call	0x6486	; 0x6486 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    5326:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5328:	81 50       	subi	r24, 0x01	; 1
    532a:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    532c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    532e:	8f 3f       	cpi	r24, 0xFF	; 255
    5330:	69 f4       	brne	.+26     	; 0x534c <xQueueReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5332:	88 85       	ldd	r24, Y+8	; 0x08
    5334:	88 23       	and	r24, r24
    5336:	79 f0       	breq	.+30     	; 0x5356 <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5338:	ce 01       	movw	r24, r28
    533a:	08 96       	adiw	r24, 0x08	; 8
    533c:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <xTaskRemoveFromEventList>
    5340:	88 23       	and	r24, r24
    5342:	49 f0       	breq	.+18     	; 0x5356 <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    5344:	81 e0       	ldi	r24, 0x01	; 1
    5346:	f8 01       	movw	r30, r16
    5348:	80 83       	st	Z, r24
    534a:	06 c0       	rjmp	.+12     	; 0x5358 <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    534c:	8f 5f       	subi	r24, 0xFF	; 255
    534e:	8d 8f       	std	Y+29, r24	; 0x1d
    5350:	02 c0       	rjmp	.+4      	; 0x5356 <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    5352:	80 e0       	ldi	r24, 0x00	; 0
    5354:	01 c0       	rjmp	.+2      	; 0x5358 <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    5356:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5358:	df 91       	pop	r29
    535a:	cf 91       	pop	r28
    535c:	1f 91       	pop	r17
    535e:	0f 91       	pop	r16
    5360:	08 95       	ret

00005362 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5362:	0f b6       	in	r0, 0x3f	; 63
    5364:	f8 94       	cli
    5366:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    5368:	fc 01       	movw	r30, r24
    536a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    536c:	0f 90       	pop	r0
    536e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    5370:	08 95       	ret

00005372 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    5372:	fc 01       	movw	r30, r24
    5374:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    5376:	08 95       	ret

00005378 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    5378:	cf 93       	push	r28
    537a:	df 93       	push	r29
    537c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    537e:	88 81       	ld	r24, Y
    5380:	99 81       	ldd	r25, Y+1	; 0x01
    5382:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <vPortFree>
	vPortFree( pxQueue );
    5386:	ce 01       	movw	r24, r28
    5388:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <vPortFree>
}
    538c:	df 91       	pop	r29
    538e:	cf 91       	pop	r28
    5390:	08 95       	ret

00005392 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5392:	fc 01       	movw	r30, r24
    5394:	92 8d       	ldd	r25, Z+26	; 0x1a
    5396:	81 e0       	ldi	r24, 0x01	; 1
    5398:	91 11       	cpse	r25, r1
    539a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    539c:	08 95       	ret

0000539e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    539e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    53a0:	22 8d       	ldd	r18, Z+26	; 0x1a
    53a2:	81 e0       	ldi	r24, 0x01	; 1
    53a4:	93 8d       	ldd	r25, Z+27	; 0x1b
    53a6:	29 13       	cpse	r18, r25
    53a8:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    53aa:	08 95       	ret

000053ac <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    53ac:	cf 93       	push	r28
    53ae:	df 93       	push	r29
    53b0:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    53b2:	e0 91 0c 01 	lds	r30, 0x010C
    53b6:	f0 91 0d 01 	lds	r31, 0x010D
    53ba:	93 83       	std	Z+3, r25	; 0x03
    53bc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    53be:	80 91 10 01 	lds	r24, 0x0110
    53c2:	90 91 11 01 	lds	r25, 0x0111
    53c6:	c8 17       	cp	r28, r24
    53c8:	d9 07       	cpc	r29, r25
    53ca:	68 f4       	brcc	.+26     	; 0x53e6 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    53cc:	80 91 41 01 	lds	r24, 0x0141
    53d0:	90 91 42 01 	lds	r25, 0x0142
    53d4:	60 91 0c 01 	lds	r22, 0x010C
    53d8:	70 91 0d 01 	lds	r23, 0x010D
    53dc:	6e 5f       	subi	r22, 0xFE	; 254
    53de:	7f 4f       	sbci	r23, 0xFF	; 255
    53e0:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <vListInsert>
    53e4:	17 c0       	rjmp	.+46     	; 0x5414 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    53e6:	80 91 43 01 	lds	r24, 0x0143
    53ea:	90 91 44 01 	lds	r25, 0x0144
    53ee:	60 91 0c 01 	lds	r22, 0x010C
    53f2:	70 91 0d 01 	lds	r23, 0x010D
    53f6:	6e 5f       	subi	r22, 0xFE	; 254
    53f8:	7f 4f       	sbci	r23, 0xFF	; 255
    53fa:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    53fe:	80 91 c0 00 	lds	r24, 0x00C0
    5402:	90 91 c1 00 	lds	r25, 0x00C1
    5406:	c8 17       	cp	r28, r24
    5408:	d9 07       	cpc	r29, r25
    540a:	20 f4       	brcc	.+8      	; 0x5414 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    540c:	d0 93 c1 00 	sts	0x00C1, r29
    5410:	c0 93 c0 00 	sts	0x00C0, r28
		}
	}
}
    5414:	df 91       	pop	r29
    5416:	cf 91       	pop	r28
    5418:	08 95       	ret

0000541a <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    541a:	80 91 14 01 	lds	r24, 0x0114
    541e:	82 30       	cpi	r24, 0x02	; 2
    5420:	e0 f3       	brcs	.-8      	; 0x541a <prvIdleTask>
			{
				taskYIELD();
    5422:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
    5426:	f9 cf       	rjmp	.-14     	; 0x541a <prvIdleTask>

00005428 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    5428:	2f 92       	push	r2
    542a:	3f 92       	push	r3
    542c:	4f 92       	push	r4
    542e:	5f 92       	push	r5
    5430:	6f 92       	push	r6
    5432:	7f 92       	push	r7
    5434:	8f 92       	push	r8
    5436:	9f 92       	push	r9
    5438:	af 92       	push	r10
    543a:	bf 92       	push	r11
    543c:	cf 92       	push	r12
    543e:	df 92       	push	r13
    5440:	ef 92       	push	r14
    5442:	ff 92       	push	r15
    5444:	0f 93       	push	r16
    5446:	1f 93       	push	r17
    5448:	cf 93       	push	r28
    544a:	df 93       	push	r29
    544c:	1c 01       	movw	r2, r24
    544e:	3b 01       	movw	r6, r22
    5450:	5a 01       	movw	r10, r20
    5452:	29 01       	movw	r4, r18
    5454:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    5456:	81 e2       	ldi	r24, 0x21	; 33
    5458:	90 e0       	ldi	r25, 0x00	; 0
    545a:	0e 94 23 2f 	call	0x5e46	; 0x5e46 <pvPortMalloc>
    545e:	e8 2e       	mov	r14, r24
    5460:	e7 01       	movw	r28, r14
    5462:	7e 01       	movw	r14, r28
    5464:	f9 2e       	mov	r15, r25
    5466:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    5468:	20 97       	sbiw	r28, 0x00	; 0
    546a:	09 f4       	brne	.+2      	; 0x546e <xTaskGenericCreate+0x46>
    546c:	d4 c0       	rjmp	.+424    	; 0x5616 <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    546e:	c1 14       	cp	r12, r1
    5470:	d1 04       	cpc	r13, r1
    5472:	29 f4       	brne	.+10     	; 0x547e <xTaskGenericCreate+0x56>
    5474:	c5 01       	movw	r24, r10
    5476:	0e 94 23 2f 	call	0x5e46	; 0x5e46 <pvPortMalloc>
    547a:	c8 2e       	mov	r12, r24
    547c:	d9 2e       	mov	r13, r25
    547e:	d8 8e       	std	Y+24, r13	; 0x18
    5480:	cf 8a       	std	Y+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    5482:	c1 14       	cp	r12, r1
    5484:	d1 04       	cpc	r13, r1
    5486:	21 f4       	brne	.+8      	; 0x5490 <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    5488:	ce 01       	movw	r24, r28
    548a:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <vPortFree>
    548e:	c3 c0       	rjmp	.+390    	; 0x5616 <xTaskGenericCreate+0x1ee>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5490:	c6 01       	movw	r24, r12
    5492:	65 ea       	ldi	r22, 0xA5	; 165
    5494:	70 e0       	ldi	r23, 0x00	; 0
    5496:	a5 01       	movw	r20, r10
    5498:	0e 94 4c 32 	call	0x6498	; 0x6498 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    549c:	08 94       	sec
    549e:	a1 08       	sbc	r10, r1
    54a0:	b1 08       	sbc	r11, r1
    54a2:	ef 88       	ldd	r14, Y+23	; 0x17
    54a4:	f8 8c       	ldd	r15, Y+24	; 0x18
    54a6:	ea 0c       	add	r14, r10
    54a8:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    54aa:	ce 01       	movw	r24, r28
    54ac:	49 96       	adiw	r24, 0x19	; 25
    54ae:	b3 01       	movw	r22, r6
    54b0:	48 e0       	ldi	r20, 0x08	; 8
    54b2:	50 e0       	ldi	r21, 0x00	; 0
    54b4:	0e 94 53 32 	call	0x64a6	; 0x64a6 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    54b8:	18 a2       	std	Y+32, r1	; 0x20
    54ba:	10 2f       	mov	r17, r16
    54bc:	04 30       	cpi	r16, 0x04	; 4
    54be:	08 f0       	brcs	.+2      	; 0x54c2 <xTaskGenericCreate+0x9a>
    54c0:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    54c2:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    54c4:	e2 e0       	ldi	r30, 0x02	; 2
    54c6:	ae 2e       	mov	r10, r30
    54c8:	b1 2c       	mov	r11, r1
    54ca:	ac 0e       	add	r10, r28
    54cc:	bd 1e       	adc	r11, r29
    54ce:	c5 01       	movw	r24, r10
    54d0:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    54d4:	ce 01       	movw	r24, r28
    54d6:	0c 96       	adiw	r24, 0x0c	; 12
    54d8:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    54dc:	d9 87       	std	Y+9, r29	; 0x09
    54de:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    54e0:	84 e0       	ldi	r24, 0x04	; 4
    54e2:	90 e0       	ldi	r25, 0x00	; 0
    54e4:	81 1b       	sub	r24, r17
    54e6:	91 09       	sbc	r25, r1
    54e8:	9d 87       	std	Y+13, r25	; 0x0d
    54ea:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    54ec:	db 8b       	std	Y+19, r29	; 0x13
    54ee:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    54f0:	c7 01       	movw	r24, r14
    54f2:	b1 01       	movw	r22, r2
    54f4:	a2 01       	movw	r20, r4
    54f6:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <pxPortInitialiseStack>
    54fa:	99 83       	std	Y+1, r25	; 0x01
    54fc:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    54fe:	81 14       	cp	r8, r1
    5500:	91 04       	cpc	r9, r1
    5502:	19 f0       	breq	.+6      	; 0x550a <xTaskGenericCreate+0xe2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5504:	f4 01       	movw	r30, r8
    5506:	d1 83       	std	Z+1, r29	; 0x01
    5508:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    550a:	0f b6       	in	r0, 0x3f	; 63
    550c:	f8 94       	cli
    550e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    5510:	80 91 46 01 	lds	r24, 0x0146
    5514:	8f 5f       	subi	r24, 0xFF	; 255
    5516:	80 93 46 01 	sts	0x0146, r24
			if( pxCurrentTCB == NULL )
    551a:	80 91 0c 01 	lds	r24, 0x010C
    551e:	90 91 0d 01 	lds	r25, 0x010D
    5522:	00 97       	sbiw	r24, 0x00	; 0
    5524:	c9 f5       	brne	.+114    	; 0x5598 <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5526:	d0 93 0d 01 	sts	0x010D, r29
    552a:	c0 93 0c 01 	sts	0x010C, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    552e:	80 91 46 01 	lds	r24, 0x0146
    5532:	81 30       	cpi	r24, 0x01	; 1
    5534:	09 f0       	breq	.+2      	; 0x5538 <xTaskGenericCreate+0x110>
    5536:	3f c0       	rjmp	.+126    	; 0x55b6 <xTaskGenericCreate+0x18e>
    5538:	ee 24       	eor	r14, r14
    553a:	ff 24       	eor	r15, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    553c:	c7 01       	movw	r24, r14
    553e:	73 e0       	ldi	r23, 0x03	; 3
    5540:	88 0f       	add	r24, r24
    5542:	99 1f       	adc	r25, r25
    5544:	7a 95       	dec	r23
    5546:	e1 f7       	brne	.-8      	; 0x5540 <xTaskGenericCreate+0x118>
    5548:	8e 0d       	add	r24, r14
    554a:	9f 1d       	adc	r25, r15
    554c:	8c 5e       	subi	r24, 0xEC	; 236
    554e:	9e 4f       	sbci	r25, 0xFE	; 254
    5550:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
    5554:	08 94       	sec
    5556:	e1 1c       	adc	r14, r1
    5558:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    555a:	f4 e0       	ldi	r31, 0x04	; 4
    555c:	ef 16       	cp	r14, r31
    555e:	f1 04       	cpc	r15, r1
    5560:	69 f7       	brne	.-38     	; 0x553c <xTaskGenericCreate+0x114>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5562:	6a e4       	ldi	r22, 0x4A	; 74
    5564:	e6 2e       	mov	r14, r22
    5566:	61 e0       	ldi	r22, 0x01	; 1
    5568:	f6 2e       	mov	r15, r22
    556a:	c7 01       	movw	r24, r14
    556c:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5570:	53 e5       	ldi	r21, 0x53	; 83
    5572:	c5 2e       	mov	r12, r21
    5574:	51 e0       	ldi	r21, 0x01	; 1
    5576:	d5 2e       	mov	r13, r21
    5578:	c6 01       	movw	r24, r12
    557a:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    557e:	88 e3       	ldi	r24, 0x38	; 56
    5580:	91 e0       	ldi	r25, 0x01	; 1
    5582:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5586:	f0 92 44 01 	sts	0x0144, r15
    558a:	e0 92 43 01 	sts	0x0143, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    558e:	d0 92 42 01 	sts	0x0142, r13
    5592:	c0 92 41 01 	sts	0x0141, r12
    5596:	0f c0       	rjmp	.+30     	; 0x55b6 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    5598:	80 91 47 01 	lds	r24, 0x0147
    559c:	88 23       	and	r24, r24
    559e:	59 f4       	brne	.+22     	; 0x55b6 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    55a0:	e0 91 0c 01 	lds	r30, 0x010C
    55a4:	f0 91 0d 01 	lds	r31, 0x010D
    55a8:	86 89       	ldd	r24, Z+22	; 0x16
    55aa:	08 17       	cp	r16, r24
    55ac:	20 f0       	brcs	.+8      	; 0x55b6 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    55ae:	d0 93 0d 01 	sts	0x010D, r29
    55b2:	c0 93 0c 01 	sts	0x010C, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    55b6:	2e 89       	ldd	r18, Y+22	; 0x16
    55b8:	80 91 48 01 	lds	r24, 0x0148
    55bc:	82 17       	cp	r24, r18
    55be:	10 f4       	brcc	.+4      	; 0x55c4 <xTaskGenericCreate+0x19c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    55c0:	20 93 48 01 	sts	0x0148, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    55c4:	80 91 49 01 	lds	r24, 0x0149
    55c8:	8f 5f       	subi	r24, 0xFF	; 255
    55ca:	80 93 49 01 	sts	0x0149, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    55ce:	80 91 13 01 	lds	r24, 0x0113
    55d2:	82 17       	cp	r24, r18
    55d4:	10 f4       	brcc	.+4      	; 0x55da <xTaskGenericCreate+0x1b2>
    55d6:	20 93 13 01 	sts	0x0113, r18
    55da:	30 e0       	ldi	r19, 0x00	; 0
    55dc:	c9 01       	movw	r24, r18
    55de:	43 e0       	ldi	r20, 0x03	; 3
    55e0:	88 0f       	add	r24, r24
    55e2:	99 1f       	adc	r25, r25
    55e4:	4a 95       	dec	r20
    55e6:	e1 f7       	brne	.-8      	; 0x55e0 <xTaskGenericCreate+0x1b8>
    55e8:	82 0f       	add	r24, r18
    55ea:	93 1f       	adc	r25, r19
    55ec:	8c 5e       	subi	r24, 0xEC	; 236
    55ee:	9e 4f       	sbci	r25, 0xFE	; 254
    55f0:	b5 01       	movw	r22, r10
    55f2:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    55f6:	0f 90       	pop	r0
    55f8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    55fa:	80 91 47 01 	lds	r24, 0x0147
    55fe:	88 23       	and	r24, r24
    5600:	61 f0       	breq	.+24     	; 0x561a <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5602:	e0 91 0c 01 	lds	r30, 0x010C
    5606:	f0 91 0d 01 	lds	r31, 0x010D
    560a:	86 89       	ldd	r24, Z+22	; 0x16
    560c:	80 17       	cp	r24, r16
    560e:	28 f4       	brcc	.+10     	; 0x561a <xTaskGenericCreate+0x1f2>
			{
				portYIELD_WITHIN_API();
    5610:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
    5614:	02 c0       	rjmp	.+4      	; 0x561a <xTaskGenericCreate+0x1f2>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5616:	8f ef       	ldi	r24, 0xFF	; 255
    5618:	01 c0       	rjmp	.+2      	; 0x561c <xTaskGenericCreate+0x1f4>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    561a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    561c:	df 91       	pop	r29
    561e:	cf 91       	pop	r28
    5620:	1f 91       	pop	r17
    5622:	0f 91       	pop	r16
    5624:	ff 90       	pop	r15
    5626:	ef 90       	pop	r14
    5628:	df 90       	pop	r13
    562a:	cf 90       	pop	r12
    562c:	bf 90       	pop	r11
    562e:	af 90       	pop	r10
    5630:	9f 90       	pop	r9
    5632:	8f 90       	pop	r8
    5634:	7f 90       	pop	r7
    5636:	6f 90       	pop	r6
    5638:	5f 90       	pop	r5
    563a:	4f 90       	pop	r4
    563c:	3f 90       	pop	r3
    563e:	2f 90       	pop	r2
    5640:	08 95       	ret

00005642 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    5642:	af 92       	push	r10
    5644:	bf 92       	push	r11
    5646:	cf 92       	push	r12
    5648:	df 92       	push	r13
    564a:	ef 92       	push	r14
    564c:	ff 92       	push	r15
    564e:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    5650:	8d e0       	ldi	r24, 0x0D	; 13
    5652:	9a e2       	ldi	r25, 0x2A	; 42
    5654:	6b eb       	ldi	r22, 0xBB	; 187
    5656:	70 e0       	ldi	r23, 0x00	; 0
    5658:	45 e5       	ldi	r20, 0x55	; 85
    565a:	50 e0       	ldi	r21, 0x00	; 0
    565c:	20 e0       	ldi	r18, 0x00	; 0
    565e:	30 e0       	ldi	r19, 0x00	; 0
    5660:	00 e0       	ldi	r16, 0x00	; 0
    5662:	ee 24       	eor	r14, r14
    5664:	ff 24       	eor	r15, r15
    5666:	cc 24       	eor	r12, r12
    5668:	dd 24       	eor	r13, r13
    566a:	aa 24       	eor	r10, r10
    566c:	bb 24       	eor	r11, r11
    566e:	0e 94 14 2a 	call	0x5428	; 0x5428 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    5672:	81 30       	cpi	r24, 0x01	; 1
    5674:	49 f4       	brne	.+18     	; 0x5688 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    5676:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    5678:	80 93 47 01 	sts	0x0147, r24
		xTickCount = ( portTickType ) 0U;
    567c:	10 92 11 01 	sts	0x0111, r1
    5680:	10 92 10 01 	sts	0x0110, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5684:	0e 94 36 2e 	call	0x5c6c	; 0x5c6c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    5688:	0f 91       	pop	r16
    568a:	ff 90       	pop	r15
    568c:	ef 90       	pop	r14
    568e:	df 90       	pop	r13
    5690:	cf 90       	pop	r12
    5692:	bf 90       	pop	r11
    5694:	af 90       	pop	r10
    5696:	08 95       	ret

00005698 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5698:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    569a:	10 92 47 01 	sts	0x0147, r1
	vPortEndScheduler();
    569e:	0e 94 6b 2e 	call	0x5cd6	; 0x5cd6 <vPortEndScheduler>
}
    56a2:	08 95       	ret

000056a4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    56a4:	80 91 12 01 	lds	r24, 0x0112
    56a8:	8f 5f       	subi	r24, 0xFF	; 255
    56aa:	80 93 12 01 	sts	0x0112, r24
}
    56ae:	08 95       	ret

000056b0 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    56b0:	0f b6       	in	r0, 0x3f	; 63
    56b2:	f8 94       	cli
    56b4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    56b6:	20 91 10 01 	lds	r18, 0x0110
    56ba:	30 91 11 01 	lds	r19, 0x0111
	}
	taskEXIT_CRITICAL();
    56be:	0f 90       	pop	r0
    56c0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    56c2:	c9 01       	movw	r24, r18
    56c4:	08 95       	ret

000056c6 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    56c6:	20 91 10 01 	lds	r18, 0x0110
    56ca:	30 91 11 01 	lds	r19, 0x0111
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    56ce:	c9 01       	movw	r24, r18
    56d0:	08 95       	ret

000056d2 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    56d2:	80 91 46 01 	lds	r24, 0x0146
}
    56d6:	08 95       	ret

000056d8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    56d8:	0f 93       	push	r16
    56da:	1f 93       	push	r17
    56dc:	cf 93       	push	r28
    56de:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    56e0:	80 91 12 01 	lds	r24, 0x0112
    56e4:	88 23       	and	r24, r24
    56e6:	09 f0       	breq	.+2      	; 0x56ea <vTaskIncrementTick+0x12>
    56e8:	8f c0       	rjmp	.+286    	; 0x5808 <vTaskIncrementTick+0x130>
	{
		++xTickCount;
    56ea:	80 91 10 01 	lds	r24, 0x0110
    56ee:	90 91 11 01 	lds	r25, 0x0111
    56f2:	01 96       	adiw	r24, 0x01	; 1
    56f4:	90 93 11 01 	sts	0x0111, r25
    56f8:	80 93 10 01 	sts	0x0110, r24
		if( xTickCount == ( portTickType ) 0U )
    56fc:	80 91 10 01 	lds	r24, 0x0110
    5700:	90 91 11 01 	lds	r25, 0x0111
    5704:	00 97       	sbiw	r24, 0x00	; 0
    5706:	79 f5       	brne	.+94     	; 0x5766 <vTaskIncrementTick+0x8e>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    5708:	80 91 43 01 	lds	r24, 0x0143
    570c:	90 91 44 01 	lds	r25, 0x0144
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    5710:	20 91 41 01 	lds	r18, 0x0141
    5714:	30 91 42 01 	lds	r19, 0x0142
    5718:	30 93 44 01 	sts	0x0144, r19
    571c:	20 93 43 01 	sts	0x0143, r18
			pxOverflowDelayedTaskList = pxTemp;
    5720:	90 93 42 01 	sts	0x0142, r25
    5724:	80 93 41 01 	sts	0x0141, r24
			xNumOfOverflows++;
    5728:	80 91 0f 01 	lds	r24, 0x010F
    572c:	8f 5f       	subi	r24, 0xFF	; 255
    572e:	80 93 0f 01 	sts	0x010F, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5732:	e0 91 43 01 	lds	r30, 0x0143
    5736:	f0 91 44 01 	lds	r31, 0x0144
    573a:	80 81       	ld	r24, Z
    573c:	88 23       	and	r24, r24
    573e:	19 f4       	brne	.+6      	; 0x5746 <vTaskIncrementTick+0x6e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    5740:	8f ef       	ldi	r24, 0xFF	; 255
    5742:	9f ef       	ldi	r25, 0xFF	; 255
    5744:	0c c0       	rjmp	.+24     	; 0x575e <vTaskIncrementTick+0x86>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5746:	e0 91 43 01 	lds	r30, 0x0143
    574a:	f0 91 44 01 	lds	r31, 0x0144
    574e:	05 80       	ldd	r0, Z+5	; 0x05
    5750:	f6 81       	ldd	r31, Z+6	; 0x06
    5752:	e0 2d       	mov	r30, r0
    5754:	06 80       	ldd	r0, Z+6	; 0x06
    5756:	f7 81       	ldd	r31, Z+7	; 0x07
    5758:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    575a:	82 81       	ldd	r24, Z+2	; 0x02
    575c:	93 81       	ldd	r25, Z+3	; 0x03
    575e:	90 93 c1 00 	sts	0x00C1, r25
    5762:	80 93 c0 00 	sts	0x00C0, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5766:	20 91 10 01 	lds	r18, 0x0110
    576a:	30 91 11 01 	lds	r19, 0x0111
    576e:	80 91 c0 00 	lds	r24, 0x00C0
    5772:	90 91 c1 00 	lds	r25, 0x00C1
    5776:	28 17       	cp	r18, r24
    5778:	39 07       	cpc	r19, r25
    577a:	08 f4       	brcc	.+2      	; 0x577e <vTaskIncrementTick+0xa6>
    577c:	4a c0       	rjmp	.+148    	; 0x5812 <vTaskIncrementTick+0x13a>
    577e:	e0 91 43 01 	lds	r30, 0x0143
    5782:	f0 91 44 01 	lds	r31, 0x0144
    5786:	80 81       	ld	r24, Z
    5788:	88 23       	and	r24, r24
    578a:	19 f4       	brne	.+6      	; 0x5792 <vTaskIncrementTick+0xba>
    578c:	8f ef       	ldi	r24, 0xFF	; 255
    578e:	9f ef       	ldi	r25, 0xFF	; 255
    5790:	12 c0       	rjmp	.+36     	; 0x57b6 <vTaskIncrementTick+0xde>
    5792:	e0 91 43 01 	lds	r30, 0x0143
    5796:	f0 91 44 01 	lds	r31, 0x0144
    579a:	05 80       	ldd	r0, Z+5	; 0x05
    579c:	f6 81       	ldd	r31, Z+6	; 0x06
    579e:	e0 2d       	mov	r30, r0
    57a0:	c6 81       	ldd	r28, Z+6	; 0x06
    57a2:	d7 81       	ldd	r29, Z+7	; 0x07
    57a4:	8a 81       	ldd	r24, Y+2	; 0x02
    57a6:	9b 81       	ldd	r25, Y+3	; 0x03
    57a8:	20 91 10 01 	lds	r18, 0x0110
    57ac:	30 91 11 01 	lds	r19, 0x0111
    57b0:	28 17       	cp	r18, r24
    57b2:	39 07       	cpc	r19, r25
    57b4:	28 f4       	brcc	.+10     	; 0x57c0 <vTaskIncrementTick+0xe8>
    57b6:	90 93 c1 00 	sts	0x00C1, r25
    57ba:	80 93 c0 00 	sts	0x00C0, r24
    57be:	29 c0       	rjmp	.+82     	; 0x5812 <vTaskIncrementTick+0x13a>
    57c0:	8e 01       	movw	r16, r28
    57c2:	0e 5f       	subi	r16, 0xFE	; 254
    57c4:	1f 4f       	sbci	r17, 0xFF	; 255
    57c6:	c8 01       	movw	r24, r16
    57c8:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
    57cc:	8c 89       	ldd	r24, Y+20	; 0x14
    57ce:	9d 89       	ldd	r25, Y+21	; 0x15
    57d0:	00 97       	sbiw	r24, 0x00	; 0
    57d2:	21 f0       	breq	.+8      	; 0x57dc <vTaskIncrementTick+0x104>
    57d4:	ce 01       	movw	r24, r28
    57d6:	0c 96       	adiw	r24, 0x0c	; 12
    57d8:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
    57dc:	2e 89       	ldd	r18, Y+22	; 0x16
    57de:	80 91 13 01 	lds	r24, 0x0113
    57e2:	82 17       	cp	r24, r18
    57e4:	10 f4       	brcc	.+4      	; 0x57ea <vTaskIncrementTick+0x112>
    57e6:	20 93 13 01 	sts	0x0113, r18
    57ea:	30 e0       	ldi	r19, 0x00	; 0
    57ec:	c9 01       	movw	r24, r18
    57ee:	f3 e0       	ldi	r31, 0x03	; 3
    57f0:	88 0f       	add	r24, r24
    57f2:	99 1f       	adc	r25, r25
    57f4:	fa 95       	dec	r31
    57f6:	e1 f7       	brne	.-8      	; 0x57f0 <vTaskIncrementTick+0x118>
    57f8:	82 0f       	add	r24, r18
    57fa:	93 1f       	adc	r25, r19
    57fc:	8c 5e       	subi	r24, 0xEC	; 236
    57fe:	9e 4f       	sbci	r25, 0xFE	; 254
    5800:	b8 01       	movw	r22, r16
    5802:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>
    5806:	bb cf       	rjmp	.-138    	; 0x577e <vTaskIncrementTick+0xa6>
	}
	else
	{
		++uxMissedTicks;
    5808:	80 91 45 01 	lds	r24, 0x0145
    580c:	8f 5f       	subi	r24, 0xFF	; 255
    580e:	80 93 45 01 	sts	0x0145, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5812:	df 91       	pop	r29
    5814:	cf 91       	pop	r28
    5816:	1f 91       	pop	r17
    5818:	0f 91       	pop	r16
    581a:	08 95       	ret

0000581c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    581c:	ef 92       	push	r14
    581e:	ff 92       	push	r15
    5820:	0f 93       	push	r16
    5822:	1f 93       	push	r17
    5824:	df 93       	push	r29
    5826:	cf 93       	push	r28
    5828:	0f 92       	push	r0
    582a:	cd b7       	in	r28, 0x3d	; 61
    582c:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    582e:	0f b6       	in	r0, 0x3f	; 63
    5830:	f8 94       	cli
    5832:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5834:	80 91 12 01 	lds	r24, 0x0112
    5838:	81 50       	subi	r24, 0x01	; 1
    583a:	80 93 12 01 	sts	0x0112, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    583e:	80 91 12 01 	lds	r24, 0x0112
    5842:	88 23       	and	r24, r24
    5844:	09 f0       	breq	.+2      	; 0x5848 <xTaskResumeAll+0x2c>
    5846:	5e c0       	rjmp	.+188    	; 0x5904 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    5848:	80 91 46 01 	lds	r24, 0x0146
    584c:	88 23       	and	r24, r24
    584e:	09 f4       	brne	.+2      	; 0x5852 <xTaskResumeAll+0x36>
    5850:	59 c0       	rjmp	.+178    	; 0x5904 <xTaskResumeAll+0xe8>
    5852:	19 82       	std	Y+1, r1	; 0x01
    5854:	35 c0       	rjmp	.+106    	; 0x58c0 <xTaskResumeAll+0xa4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    5856:	e0 91 3d 01 	lds	r30, 0x013D
    585a:	f0 91 3e 01 	lds	r31, 0x013E
    585e:	e6 80       	ldd	r14, Z+6	; 0x06
    5860:	f7 80       	ldd	r15, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    5862:	c7 01       	movw	r24, r14
    5864:	0c 96       	adiw	r24, 0x0c	; 12
    5866:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    586a:	87 01       	movw	r16, r14
    586c:	0e 5f       	subi	r16, 0xFE	; 254
    586e:	1f 4f       	sbci	r17, 0xFF	; 255
    5870:	c8 01       	movw	r24, r16
    5872:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    5876:	d7 01       	movw	r26, r14
    5878:	56 96       	adiw	r26, 0x16	; 22
    587a:	2c 91       	ld	r18, X
    587c:	56 97       	sbiw	r26, 0x16	; 22
    587e:	80 91 13 01 	lds	r24, 0x0113
    5882:	82 17       	cp	r24, r18
    5884:	10 f4       	brcc	.+4      	; 0x588a <xTaskResumeAll+0x6e>
    5886:	20 93 13 01 	sts	0x0113, r18
    588a:	30 e0       	ldi	r19, 0x00	; 0
    588c:	c9 01       	movw	r24, r18
    588e:	a3 e0       	ldi	r26, 0x03	; 3
    5890:	88 0f       	add	r24, r24
    5892:	99 1f       	adc	r25, r25
    5894:	aa 95       	dec	r26
    5896:	e1 f7       	brne	.-8      	; 0x5890 <xTaskResumeAll+0x74>
    5898:	82 0f       	add	r24, r18
    589a:	93 1f       	adc	r25, r19
    589c:	8c 5e       	subi	r24, 0xEC	; 236
    589e:	9e 4f       	sbci	r25, 0xFE	; 254
    58a0:	b8 01       	movw	r22, r16
    58a2:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    58a6:	e0 91 0c 01 	lds	r30, 0x010C
    58aa:	f0 91 0d 01 	lds	r31, 0x010D
    58ae:	d7 01       	movw	r26, r14
    58b0:	56 96       	adiw	r26, 0x16	; 22
    58b2:	9c 91       	ld	r25, X
    58b4:	56 97       	sbiw	r26, 0x16	; 22
    58b6:	86 89       	ldd	r24, Z+22	; 0x16
    58b8:	98 17       	cp	r25, r24
    58ba:	10 f0       	brcs	.+4      	; 0x58c0 <xTaskResumeAll+0xa4>
					{
						xYieldRequired = pdTRUE;
    58bc:	b1 e0       	ldi	r27, 0x01	; 1
    58be:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    58c0:	80 91 38 01 	lds	r24, 0x0138
    58c4:	88 23       	and	r24, r24
    58c6:	39 f6       	brne	.-114    	; 0x5856 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    58c8:	80 91 45 01 	lds	r24, 0x0145
    58cc:	88 23       	and	r24, r24
    58ce:	41 f4       	brne	.+16     	; 0x58e0 <xTaskResumeAll+0xc4>
    58d0:	0c c0       	rjmp	.+24     	; 0x58ea <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    58d2:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <vTaskIncrementTick>
						--uxMissedTicks;
    58d6:	80 91 45 01 	lds	r24, 0x0145
    58da:	81 50       	subi	r24, 0x01	; 1
    58dc:	80 93 45 01 	sts	0x0145, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    58e0:	80 91 45 01 	lds	r24, 0x0145
    58e4:	88 23       	and	r24, r24
    58e6:	a9 f7       	brne	.-22     	; 0x58d2 <xTaskResumeAll+0xb6>
    58e8:	07 c0       	rjmp	.+14     	; 0x58f8 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    58ea:	e9 81       	ldd	r30, Y+1	; 0x01
    58ec:	e1 30       	cpi	r30, 0x01	; 1
    58ee:	21 f0       	breq	.+8      	; 0x58f8 <xTaskResumeAll+0xdc>
    58f0:	80 91 0e 01 	lds	r24, 0x010E
    58f4:	81 30       	cpi	r24, 0x01	; 1
    58f6:	31 f4       	brne	.+12     	; 0x5904 <xTaskResumeAll+0xe8>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    58f8:	10 92 0e 01 	sts	0x010E, r1
					portYIELD_WITHIN_API();
    58fc:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    5900:	81 e0       	ldi	r24, 0x01	; 1
    5902:	01 c0       	rjmp	.+2      	; 0x5906 <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5904:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5906:	0f 90       	pop	r0
    5908:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    590a:	0f 90       	pop	r0
    590c:	cf 91       	pop	r28
    590e:	df 91       	pop	r29
    5910:	1f 91       	pop	r17
    5912:	0f 91       	pop	r16
    5914:	ff 90       	pop	r15
    5916:	ef 90       	pop	r14
    5918:	08 95       	ret

0000591a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    591a:	0f 93       	push	r16
    591c:	1f 93       	push	r17
    591e:	cf 93       	push	r28
    5920:	df 93       	push	r29
    5922:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    5924:	00 97       	sbiw	r24, 0x00	; 0
    5926:	b1 f0       	breq	.+44     	; 0x5954 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    5928:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    592c:	00 91 10 01 	lds	r16, 0x0110
    5930:	10 91 11 01 	lds	r17, 0x0111

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5934:	80 91 0c 01 	lds	r24, 0x010C
    5938:	90 91 0d 01 	lds	r25, 0x010D
    593c:	02 96       	adiw	r24, 0x02	; 2
    593e:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5942:	ce 01       	movw	r24, r28
    5944:	80 0f       	add	r24, r16
    5946:	91 1f       	adc	r25, r17
    5948:	0e 94 d6 29 	call	0x53ac	; 0x53ac <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    594c:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5950:	88 23       	and	r24, r24
    5952:	11 f4       	brne	.+4      	; 0x5958 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    5954:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
		}
	}
    5958:	df 91       	pop	r29
    595a:	cf 91       	pop	r28
    595c:	1f 91       	pop	r17
    595e:	0f 91       	pop	r16
    5960:	08 95       	ret

00005962 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    5962:	0f 93       	push	r16
    5964:	1f 93       	push	r17
    5966:	cf 93       	push	r28
    5968:	df 93       	push	r29
    596a:	8c 01       	movw	r16, r24
    596c:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    596e:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5972:	f8 01       	movw	r30, r16
    5974:	80 81       	ld	r24, Z
    5976:	91 81       	ldd	r25, Z+1	; 0x01
    5978:	c8 0f       	add	r28, r24
    597a:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    597c:	20 91 10 01 	lds	r18, 0x0110
    5980:	30 91 11 01 	lds	r19, 0x0111
    5984:	28 17       	cp	r18, r24
    5986:	39 07       	cpc	r19, r25
    5988:	20 f4       	brcc	.+8      	; 0x5992 <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    598a:	c8 17       	cp	r28, r24
    598c:	d9 07       	cpc	r29, r25
    598e:	60 f4       	brcc	.+24     	; 0x59a8 <vTaskDelayUntil+0x46>
    5990:	03 c0       	rjmp	.+6      	; 0x5998 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    5992:	c8 17       	cp	r28, r24
    5994:	d9 07       	cpc	r29, r25
    5996:	50 f0       	brcs	.+20     	; 0x59ac <vTaskDelayUntil+0x4a>
    5998:	80 91 10 01 	lds	r24, 0x0110
    599c:	90 91 11 01 	lds	r25, 0x0111
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    59a0:	21 e0       	ldi	r18, 0x01	; 1
    59a2:	8c 17       	cp	r24, r28
    59a4:	9d 07       	cpc	r25, r29
    59a6:	18 f0       	brcs	.+6      	; 0x59ae <vTaskDelayUntil+0x4c>
    59a8:	20 e0       	ldi	r18, 0x00	; 0
    59aa:	01 c0       	rjmp	.+2      	; 0x59ae <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    59ac:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    59ae:	f8 01       	movw	r30, r16
    59b0:	d1 83       	std	Z+1, r29	; 0x01
    59b2:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    59b4:	22 23       	and	r18, r18
    59b6:	51 f0       	breq	.+20     	; 0x59cc <vTaskDelayUntil+0x6a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    59b8:	80 91 0c 01 	lds	r24, 0x010C
    59bc:	90 91 0d 01 	lds	r25, 0x010D
    59c0:	02 96       	adiw	r24, 0x02	; 2
    59c2:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    59c6:	ce 01       	movw	r24, r28
    59c8:	0e 94 d6 29 	call	0x53ac	; 0x53ac <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    59cc:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    59d0:	88 23       	and	r24, r24
    59d2:	11 f4       	brne	.+4      	; 0x59d8 <vTaskDelayUntil+0x76>
		{
			portYIELD_WITHIN_API();
    59d4:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <vPortYield>
		}
	}
    59d8:	df 91       	pop	r29
    59da:	cf 91       	pop	r28
    59dc:	1f 91       	pop	r17
    59de:	0f 91       	pop	r16
    59e0:	08 95       	ret

000059e2 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    59e2:	80 91 12 01 	lds	r24, 0x0112
    59e6:	88 23       	and	r24, r24
    59e8:	49 f0       	breq	.+18     	; 0x59fc <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    59ea:	81 e0       	ldi	r24, 0x01	; 1
    59ec:	80 93 0e 01 	sts	0x010E, r24
    59f0:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    59f2:	80 91 13 01 	lds	r24, 0x0113
    59f6:	81 50       	subi	r24, 0x01	; 1
    59f8:	80 93 13 01 	sts	0x0113, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    59fc:	80 91 13 01 	lds	r24, 0x0113
    5a00:	90 e0       	ldi	r25, 0x00	; 0
    5a02:	fc 01       	movw	r30, r24
    5a04:	53 e0       	ldi	r21, 0x03	; 3
    5a06:	ee 0f       	add	r30, r30
    5a08:	ff 1f       	adc	r31, r31
    5a0a:	5a 95       	dec	r21
    5a0c:	e1 f7       	brne	.-8      	; 0x5a06 <vTaskSwitchContext+0x24>
    5a0e:	e8 0f       	add	r30, r24
    5a10:	f9 1f       	adc	r31, r25
    5a12:	ec 5e       	subi	r30, 0xEC	; 236
    5a14:	fe 4f       	sbci	r31, 0xFE	; 254
    5a16:	80 81       	ld	r24, Z
    5a18:	88 23       	and	r24, r24
    5a1a:	59 f3       	breq	.-42     	; 0x59f2 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5a1c:	80 91 13 01 	lds	r24, 0x0113
    5a20:	90 e0       	ldi	r25, 0x00	; 0
    5a22:	9c 01       	movw	r18, r24
    5a24:	43 e0       	ldi	r20, 0x03	; 3
    5a26:	22 0f       	add	r18, r18
    5a28:	33 1f       	adc	r19, r19
    5a2a:	4a 95       	dec	r20
    5a2c:	e1 f7       	brne	.-8      	; 0x5a26 <vTaskSwitchContext+0x44>
    5a2e:	28 0f       	add	r18, r24
    5a30:	39 1f       	adc	r19, r25
    5a32:	f9 01       	movw	r30, r18
    5a34:	ec 5e       	subi	r30, 0xEC	; 236
    5a36:	fe 4f       	sbci	r31, 0xFE	; 254
    5a38:	a1 81       	ldd	r26, Z+1	; 0x01
    5a3a:	b2 81       	ldd	r27, Z+2	; 0x02
    5a3c:	12 96       	adiw	r26, 0x02	; 2
    5a3e:	0d 90       	ld	r0, X+
    5a40:	bc 91       	ld	r27, X
    5a42:	a0 2d       	mov	r26, r0
    5a44:	b2 83       	std	Z+2, r27	; 0x02
    5a46:	a1 83       	std	Z+1, r26	; 0x01
    5a48:	29 5e       	subi	r18, 0xE9	; 233
    5a4a:	3e 4f       	sbci	r19, 0xFE	; 254
    5a4c:	a2 17       	cp	r26, r18
    5a4e:	b3 07       	cpc	r27, r19
    5a50:	31 f4       	brne	.+12     	; 0x5a5e <vTaskSwitchContext+0x7c>
    5a52:	12 96       	adiw	r26, 0x02	; 2
    5a54:	2d 91       	ld	r18, X+
    5a56:	3c 91       	ld	r19, X
    5a58:	13 97       	sbiw	r26, 0x03	; 3
    5a5a:	32 83       	std	Z+2, r19	; 0x02
    5a5c:	21 83       	std	Z+1, r18	; 0x01
    5a5e:	fc 01       	movw	r30, r24
    5a60:	b3 e0       	ldi	r27, 0x03	; 3
    5a62:	ee 0f       	add	r30, r30
    5a64:	ff 1f       	adc	r31, r31
    5a66:	ba 95       	dec	r27
    5a68:	e1 f7       	brne	.-8      	; 0x5a62 <vTaskSwitchContext+0x80>
    5a6a:	e8 0f       	add	r30, r24
    5a6c:	f9 1f       	adc	r31, r25
    5a6e:	ec 5e       	subi	r30, 0xEC	; 236
    5a70:	fe 4f       	sbci	r31, 0xFE	; 254
    5a72:	01 80       	ldd	r0, Z+1	; 0x01
    5a74:	f2 81       	ldd	r31, Z+2	; 0x02
    5a76:	e0 2d       	mov	r30, r0
    5a78:	86 81       	ldd	r24, Z+6	; 0x06
    5a7a:	97 81       	ldd	r25, Z+7	; 0x07
    5a7c:	90 93 0d 01 	sts	0x010D, r25
    5a80:	80 93 0c 01 	sts	0x010C, r24
    5a84:	08 95       	ret

00005a86 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5a86:	cf 93       	push	r28
    5a88:	df 93       	push	r29
    5a8a:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5a8c:	60 91 0c 01 	lds	r22, 0x010C
    5a90:	70 91 0d 01 	lds	r23, 0x010D
    5a94:	64 5f       	subi	r22, 0xF4	; 244
    5a96:	7f 4f       	sbci	r23, 0xFF	; 255
    5a98:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5a9c:	80 91 0c 01 	lds	r24, 0x010C
    5aa0:	90 91 0d 01 	lds	r25, 0x010D
    5aa4:	02 96       	adiw	r24, 0x02	; 2
    5aa6:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    5aaa:	80 91 10 01 	lds	r24, 0x0110
    5aae:	90 91 11 01 	lds	r25, 0x0111
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5ab2:	8c 0f       	add	r24, r28
    5ab4:	9d 1f       	adc	r25, r29
    5ab6:	0e 94 d6 29 	call	0x53ac	; 0x53ac <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    5aba:	df 91       	pop	r29
    5abc:	cf 91       	pop	r28
    5abe:	08 95       	ret

00005ac0 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    5ac0:	0f 93       	push	r16
    5ac2:	1f 93       	push	r17
    5ac4:	cf 93       	push	r28
    5ac6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5ac8:	dc 01       	movw	r26, r24
    5aca:	15 96       	adiw	r26, 0x05	; 5
    5acc:	ed 91       	ld	r30, X+
    5ace:	fc 91       	ld	r31, X
    5ad0:	16 97       	sbiw	r26, 0x06	; 6
    5ad2:	c6 81       	ldd	r28, Z+6	; 0x06
    5ad4:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5ad6:	8e 01       	movw	r16, r28
    5ad8:	04 5f       	subi	r16, 0xF4	; 244
    5ada:	1f 4f       	sbci	r17, 0xFF	; 255
    5adc:	c8 01       	movw	r24, r16
    5ade:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5ae2:	80 91 12 01 	lds	r24, 0x0112
    5ae6:	88 23       	and	r24, r24
    5ae8:	c9 f4       	brne	.+50     	; 0x5b1c <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5aea:	8e 01       	movw	r16, r28
    5aec:	0e 5f       	subi	r16, 0xFE	; 254
    5aee:	1f 4f       	sbci	r17, 0xFF	; 255
    5af0:	c8 01       	movw	r24, r16
    5af2:	0e 94 a5 26 	call	0x4d4a	; 0x4d4a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    5af6:	2e 89       	ldd	r18, Y+22	; 0x16
    5af8:	80 91 13 01 	lds	r24, 0x0113
    5afc:	82 17       	cp	r24, r18
    5afe:	10 f4       	brcc	.+4      	; 0x5b04 <xTaskRemoveFromEventList+0x44>
    5b00:	20 93 13 01 	sts	0x0113, r18
    5b04:	30 e0       	ldi	r19, 0x00	; 0
    5b06:	c9 01       	movw	r24, r18
    5b08:	63 e0       	ldi	r22, 0x03	; 3
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	6a 95       	dec	r22
    5b10:	e1 f7       	brne	.-8      	; 0x5b0a <xTaskRemoveFromEventList+0x4a>
    5b12:	82 0f       	add	r24, r18
    5b14:	93 1f       	adc	r25, r19
    5b16:	8c 5e       	subi	r24, 0xEC	; 236
    5b18:	9e 4f       	sbci	r25, 0xFE	; 254
    5b1a:	02 c0       	rjmp	.+4      	; 0x5b20 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5b1c:	88 e3       	ldi	r24, 0x38	; 56
    5b1e:	91 e0       	ldi	r25, 0x01	; 1
    5b20:	b8 01       	movw	r22, r16
    5b22:	0e 94 49 26 	call	0x4c92	; 0x4c92 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5b26:	e0 91 0c 01 	lds	r30, 0x010C
    5b2a:	f0 91 0d 01 	lds	r31, 0x010D
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    5b2e:	81 e0       	ldi	r24, 0x01	; 1
    5b30:	2e 89       	ldd	r18, Y+22	; 0x16
    5b32:	96 89       	ldd	r25, Z+22	; 0x16
    5b34:	29 17       	cp	r18, r25
    5b36:	08 f4       	brcc	.+2      	; 0x5b3a <xTaskRemoveFromEventList+0x7a>
    5b38:	80 e0       	ldi	r24, 0x00	; 0
}
    5b3a:	df 91       	pop	r29
    5b3c:	cf 91       	pop	r28
    5b3e:	1f 91       	pop	r17
    5b40:	0f 91       	pop	r16
    5b42:	08 95       	ret

00005b44 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5b44:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5b46:	80 91 0f 01 	lds	r24, 0x010F
    5b4a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5b4c:	80 91 10 01 	lds	r24, 0x0110
    5b50:	90 91 11 01 	lds	r25, 0x0111
    5b54:	92 83       	std	Z+2, r25	; 0x02
    5b56:	81 83       	std	Z+1, r24	; 0x01
}
    5b58:	08 95       	ret

00005b5a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5b5a:	fc 01       	movw	r30, r24
    5b5c:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5b5e:	0f b6       	in	r0, 0x3f	; 63
    5b60:	f8 94       	cli
    5b62:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    5b64:	90 91 0f 01 	lds	r25, 0x010F
    5b68:	80 81       	ld	r24, Z
    5b6a:	98 17       	cp	r25, r24
    5b6c:	49 f0       	breq	.+18     	; 0x5b80 <xTaskCheckForTimeOut+0x26>
    5b6e:	20 91 10 01 	lds	r18, 0x0110
    5b72:	30 91 11 01 	lds	r19, 0x0111
    5b76:	81 81       	ldd	r24, Z+1	; 0x01
    5b78:	92 81       	ldd	r25, Z+2	; 0x02
    5b7a:	28 17       	cp	r18, r24
    5b7c:	39 07       	cpc	r19, r25
    5b7e:	20 f5       	brcc	.+72     	; 0x5bc8 <xTaskCheckForTimeOut+0x6e>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5b80:	20 91 10 01 	lds	r18, 0x0110
    5b84:	30 91 11 01 	lds	r19, 0x0111
    5b88:	81 81       	ldd	r24, Z+1	; 0x01
    5b8a:	92 81       	ldd	r25, Z+2	; 0x02
    5b8c:	4d 91       	ld	r20, X+
    5b8e:	5c 91       	ld	r21, X
    5b90:	11 97       	sbiw	r26, 0x01	; 1
    5b92:	28 1b       	sub	r18, r24
    5b94:	39 0b       	sbc	r19, r25
    5b96:	24 17       	cp	r18, r20
    5b98:	35 07       	cpc	r19, r21
    5b9a:	b0 f4       	brcc	.+44     	; 0x5bc8 <xTaskCheckForTimeOut+0x6e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5b9c:	20 91 10 01 	lds	r18, 0x0110
    5ba0:	30 91 11 01 	lds	r19, 0x0111
    5ba4:	82 1b       	sub	r24, r18
    5ba6:	93 0b       	sbc	r25, r19
    5ba8:	84 0f       	add	r24, r20
    5baa:	95 1f       	adc	r25, r21
    5bac:	11 96       	adiw	r26, 0x01	; 1
    5bae:	9c 93       	st	X, r25
    5bb0:	8e 93       	st	-X, r24
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5bb2:	80 91 0f 01 	lds	r24, 0x010F
    5bb6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5bb8:	80 91 10 01 	lds	r24, 0x0110
    5bbc:	90 91 11 01 	lds	r25, 0x0111
    5bc0:	92 83       	std	Z+2, r25	; 0x02
    5bc2:	81 83       	std	Z+1, r24	; 0x01
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    5bc4:	80 e0       	ldi	r24, 0x00	; 0
    5bc6:	01 c0       	rjmp	.+2      	; 0x5bca <xTaskCheckForTimeOut+0x70>
		}
		else
		{
			xReturn = pdTRUE;
    5bc8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    5bca:	0f 90       	pop	r0
    5bcc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    5bce:	08 95       	ret

00005bd0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	80 93 0e 01 	sts	0x010E, r24
}
    5bd6:	08 95       	ret

00005bd8 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    5bd8:	21 e1       	ldi	r18, 0x11	; 17
    5bda:	fc 01       	movw	r30, r24
    5bdc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    5bde:	92 e2       	ldi	r25, 0x22	; 34
    5be0:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    5be2:	83 e3       	ldi	r24, 0x33	; 51
    5be4:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5be6:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5be8:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    5bea:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    5bec:	80 e8       	ldi	r24, 0x80	; 128
    5bee:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    5bf0:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    5bf2:	82 e0       	ldi	r24, 0x02	; 2
    5bf4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    5bf6:	83 e0       	ldi	r24, 0x03	; 3
    5bf8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    5bfa:	84 e0       	ldi	r24, 0x04	; 4
    5bfc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    5bfe:	85 e0       	ldi	r24, 0x05	; 5
    5c00:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    5c02:	86 e0       	ldi	r24, 0x06	; 6
    5c04:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    5c06:	87 e0       	ldi	r24, 0x07	; 7
    5c08:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    5c0a:	88 e0       	ldi	r24, 0x08	; 8
    5c0c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    5c0e:	89 e0       	ldi	r24, 0x09	; 9
    5c10:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    5c12:	80 e1       	ldi	r24, 0x10	; 16
    5c14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    5c16:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    5c18:	82 e1       	ldi	r24, 0x12	; 18
    5c1a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    5c1c:	83 e1       	ldi	r24, 0x13	; 19
    5c1e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    5c20:	84 e1       	ldi	r24, 0x14	; 20
    5c22:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    5c24:	85 e1       	ldi	r24, 0x15	; 21
    5c26:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5c28:	86 e1       	ldi	r24, 0x16	; 22
    5c2a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    5c2c:	87 e1       	ldi	r24, 0x17	; 23
    5c2e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5c30:	88 e1       	ldi	r24, 0x18	; 24
    5c32:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    5c34:	89 e1       	ldi	r24, 0x19	; 25
    5c36:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    5c38:	80 e2       	ldi	r24, 0x20	; 32
    5c3a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    5c3c:	81 e2       	ldi	r24, 0x21	; 33
    5c3e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    5c40:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    5c42:	83 e2       	ldi	r24, 0x23	; 35
    5c44:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c46:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c48:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    5c4a:	86 e2       	ldi	r24, 0x26	; 38
    5c4c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    5c4e:	87 e2       	ldi	r24, 0x27	; 39
    5c50:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    5c52:	88 e2       	ldi	r24, 0x28	; 40
    5c54:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5c56:	89 e2       	ldi	r24, 0x29	; 41
    5c58:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5c5a:	80 e3       	ldi	r24, 0x30	; 48
    5c5c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5c5e:	81 e3       	ldi	r24, 0x31	; 49
    5c60:	82 93       	st	-Z, r24
	pxTopOfStack--;
    5c62:	9f 01       	movw	r18, r30
    5c64:	21 50       	subi	r18, 0x01	; 1
    5c66:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    5c68:	c9 01       	movw	r24, r18
    5c6a:	08 95       	ret

00005c6c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    5c6c:	89 e0       	ldi	r24, 0x09	; 9
    5c6e:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    5c70:	9f e5       	ldi	r25, 0x5F	; 95
    5c72:	9a bd       	out	0x2a, r25	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    5c74:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5c76:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5c78:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    5c7a:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5c7c:	a0 91 0c 01 	lds	r26, 0x010C
    5c80:	b0 91 0d 01 	lds	r27, 0x010D
    5c84:	cd 91       	ld	r28, X+
    5c86:	cd bf       	out	0x3d, r28	; 61
    5c88:	dd 91       	ld	r29, X+
    5c8a:	de bf       	out	0x3e, r29	; 62
    5c8c:	ff 91       	pop	r31
    5c8e:	ef 91       	pop	r30
    5c90:	df 91       	pop	r29
    5c92:	cf 91       	pop	r28
    5c94:	bf 91       	pop	r27
    5c96:	af 91       	pop	r26
    5c98:	9f 91       	pop	r25
    5c9a:	8f 91       	pop	r24
    5c9c:	7f 91       	pop	r23
    5c9e:	6f 91       	pop	r22
    5ca0:	5f 91       	pop	r21
    5ca2:	4f 91       	pop	r20
    5ca4:	3f 91       	pop	r19
    5ca6:	2f 91       	pop	r18
    5ca8:	1f 91       	pop	r17
    5caa:	0f 91       	pop	r16
    5cac:	ff 90       	pop	r15
    5cae:	ef 90       	pop	r14
    5cb0:	df 90       	pop	r13
    5cb2:	cf 90       	pop	r12
    5cb4:	bf 90       	pop	r11
    5cb6:	af 90       	pop	r10
    5cb8:	9f 90       	pop	r9
    5cba:	8f 90       	pop	r8
    5cbc:	7f 90       	pop	r7
    5cbe:	6f 90       	pop	r6
    5cc0:	5f 90       	pop	r5
    5cc2:	4f 90       	pop	r4
    5cc4:	3f 90       	pop	r3
    5cc6:	2f 90       	pop	r2
    5cc8:	1f 90       	pop	r1
    5cca:	0f 90       	pop	r0
    5ccc:	0f be       	out	0x3f, r0	; 63
    5cce:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5cd0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    5cd2:	81 e0       	ldi	r24, 0x01	; 1
    5cd4:	08 95       	ret

00005cd6 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5cd6:	08 95       	ret

00005cd8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5cd8:	0f 92       	push	r0
    5cda:	0f b6       	in	r0, 0x3f	; 63
    5cdc:	f8 94       	cli
    5cde:	0f 92       	push	r0
    5ce0:	1f 92       	push	r1
    5ce2:	11 24       	eor	r1, r1
    5ce4:	2f 92       	push	r2
    5ce6:	3f 92       	push	r3
    5ce8:	4f 92       	push	r4
    5cea:	5f 92       	push	r5
    5cec:	6f 92       	push	r6
    5cee:	7f 92       	push	r7
    5cf0:	8f 92       	push	r8
    5cf2:	9f 92       	push	r9
    5cf4:	af 92       	push	r10
    5cf6:	bf 92       	push	r11
    5cf8:	cf 92       	push	r12
    5cfa:	df 92       	push	r13
    5cfc:	ef 92       	push	r14
    5cfe:	ff 92       	push	r15
    5d00:	0f 93       	push	r16
    5d02:	1f 93       	push	r17
    5d04:	2f 93       	push	r18
    5d06:	3f 93       	push	r19
    5d08:	4f 93       	push	r20
    5d0a:	5f 93       	push	r21
    5d0c:	6f 93       	push	r22
    5d0e:	7f 93       	push	r23
    5d10:	8f 93       	push	r24
    5d12:	9f 93       	push	r25
    5d14:	af 93       	push	r26
    5d16:	bf 93       	push	r27
    5d18:	cf 93       	push	r28
    5d1a:	df 93       	push	r29
    5d1c:	ef 93       	push	r30
    5d1e:	ff 93       	push	r31
    5d20:	a0 91 0c 01 	lds	r26, 0x010C
    5d24:	b0 91 0d 01 	lds	r27, 0x010D
    5d28:	0d b6       	in	r0, 0x3d	; 61
    5d2a:	0d 92       	st	X+, r0
    5d2c:	0e b6       	in	r0, 0x3e	; 62
    5d2e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5d30:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5d34:	a0 91 0c 01 	lds	r26, 0x010C
    5d38:	b0 91 0d 01 	lds	r27, 0x010D
    5d3c:	cd 91       	ld	r28, X+
    5d3e:	cd bf       	out	0x3d, r28	; 61
    5d40:	dd 91       	ld	r29, X+
    5d42:	de bf       	out	0x3e, r29	; 62
    5d44:	ff 91       	pop	r31
    5d46:	ef 91       	pop	r30
    5d48:	df 91       	pop	r29
    5d4a:	cf 91       	pop	r28
    5d4c:	bf 91       	pop	r27
    5d4e:	af 91       	pop	r26
    5d50:	9f 91       	pop	r25
    5d52:	8f 91       	pop	r24
    5d54:	7f 91       	pop	r23
    5d56:	6f 91       	pop	r22
    5d58:	5f 91       	pop	r21
    5d5a:	4f 91       	pop	r20
    5d5c:	3f 91       	pop	r19
    5d5e:	2f 91       	pop	r18
    5d60:	1f 91       	pop	r17
    5d62:	0f 91       	pop	r16
    5d64:	ff 90       	pop	r15
    5d66:	ef 90       	pop	r14
    5d68:	df 90       	pop	r13
    5d6a:	cf 90       	pop	r12
    5d6c:	bf 90       	pop	r11
    5d6e:	af 90       	pop	r10
    5d70:	9f 90       	pop	r9
    5d72:	8f 90       	pop	r8
    5d74:	7f 90       	pop	r7
    5d76:	6f 90       	pop	r6
    5d78:	5f 90       	pop	r5
    5d7a:	4f 90       	pop	r4
    5d7c:	3f 90       	pop	r3
    5d7e:	2f 90       	pop	r2
    5d80:	1f 90       	pop	r1
    5d82:	0f 90       	pop	r0
    5d84:	0f be       	out	0x3f, r0	; 63
    5d86:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5d88:	08 95       	ret

00005d8a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    5d8a:	0f 92       	push	r0
    5d8c:	0f b6       	in	r0, 0x3f	; 63
    5d8e:	f8 94       	cli
    5d90:	0f 92       	push	r0
    5d92:	1f 92       	push	r1
    5d94:	11 24       	eor	r1, r1
    5d96:	2f 92       	push	r2
    5d98:	3f 92       	push	r3
    5d9a:	4f 92       	push	r4
    5d9c:	5f 92       	push	r5
    5d9e:	6f 92       	push	r6
    5da0:	7f 92       	push	r7
    5da2:	8f 92       	push	r8
    5da4:	9f 92       	push	r9
    5da6:	af 92       	push	r10
    5da8:	bf 92       	push	r11
    5daa:	cf 92       	push	r12
    5dac:	df 92       	push	r13
    5dae:	ef 92       	push	r14
    5db0:	ff 92       	push	r15
    5db2:	0f 93       	push	r16
    5db4:	1f 93       	push	r17
    5db6:	2f 93       	push	r18
    5db8:	3f 93       	push	r19
    5dba:	4f 93       	push	r20
    5dbc:	5f 93       	push	r21
    5dbe:	6f 93       	push	r22
    5dc0:	7f 93       	push	r23
    5dc2:	8f 93       	push	r24
    5dc4:	9f 93       	push	r25
    5dc6:	af 93       	push	r26
    5dc8:	bf 93       	push	r27
    5dca:	cf 93       	push	r28
    5dcc:	df 93       	push	r29
    5dce:	ef 93       	push	r30
    5dd0:	ff 93       	push	r31
    5dd2:	a0 91 0c 01 	lds	r26, 0x010C
    5dd6:	b0 91 0d 01 	lds	r27, 0x010D
    5dda:	0d b6       	in	r0, 0x3d	; 61
    5ddc:	0d 92       	st	X+, r0
    5dde:	0e b6       	in	r0, 0x3e	; 62
    5de0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    5de2:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <vTaskIncrementTick>
	vTaskSwitchContext();
    5de6:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5dea:	a0 91 0c 01 	lds	r26, 0x010C
    5dee:	b0 91 0d 01 	lds	r27, 0x010D
    5df2:	cd 91       	ld	r28, X+
    5df4:	cd bf       	out	0x3d, r28	; 61
    5df6:	dd 91       	ld	r29, X+
    5df8:	de bf       	out	0x3e, r29	; 62
    5dfa:	ff 91       	pop	r31
    5dfc:	ef 91       	pop	r30
    5dfe:	df 91       	pop	r29
    5e00:	cf 91       	pop	r28
    5e02:	bf 91       	pop	r27
    5e04:	af 91       	pop	r26
    5e06:	9f 91       	pop	r25
    5e08:	8f 91       	pop	r24
    5e0a:	7f 91       	pop	r23
    5e0c:	6f 91       	pop	r22
    5e0e:	5f 91       	pop	r21
    5e10:	4f 91       	pop	r20
    5e12:	3f 91       	pop	r19
    5e14:	2f 91       	pop	r18
    5e16:	1f 91       	pop	r17
    5e18:	0f 91       	pop	r16
    5e1a:	ff 90       	pop	r15
    5e1c:	ef 90       	pop	r14
    5e1e:	df 90       	pop	r13
    5e20:	cf 90       	pop	r12
    5e22:	bf 90       	pop	r11
    5e24:	af 90       	pop	r10
    5e26:	9f 90       	pop	r9
    5e28:	8f 90       	pop	r8
    5e2a:	7f 90       	pop	r7
    5e2c:	6f 90       	pop	r6
    5e2e:	5f 90       	pop	r5
    5e30:	4f 90       	pop	r4
    5e32:	3f 90       	pop	r3
    5e34:	2f 90       	pop	r2
    5e36:	1f 90       	pop	r1
    5e38:	0f 90       	pop	r0
    5e3a:	0f be       	out	0x3f, r0	; 63
    5e3c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5e3e:	08 95       	ret

00005e40 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5e40:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <vPortYieldFromTick>
		asm volatile ( "reti" );
    5e44:	18 95       	reti

00005e46 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5e46:	ef 92       	push	r14
    5e48:	ff 92       	push	r15
    5e4a:	0f 93       	push	r16
    5e4c:	1f 93       	push	r17
    5e4e:	cf 93       	push	r28
    5e50:	df 93       	push	r29
    5e52:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    5e54:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    5e58:	c0 91 5c 01 	lds	r28, 0x015C
    5e5c:	d0 91 5d 01 	lds	r29, 0x015D
    5e60:	0c 0f       	add	r16, r28
    5e62:	1d 1f       	adc	r17, r29
    5e64:	25 e0       	ldi	r18, 0x05	; 5
    5e66:	0c 3d       	cpi	r16, 0xDC	; 220
    5e68:	12 07       	cpc	r17, r18
    5e6a:	50 f4       	brcc	.+20     	; 0x5e80 <pvPortMalloc+0x3a>
    5e6c:	c0 17       	cp	r28, r16
    5e6e:	d1 07       	cpc	r29, r17
    5e70:	38 f4       	brcc	.+14     	; 0x5e80 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    5e72:	c2 5a       	subi	r28, 0xA2	; 162
    5e74:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
    5e76:	10 93 5d 01 	sts	0x015D, r17
    5e7a:	00 93 5c 01 	sts	0x015C, r16
    5e7e:	02 c0       	rjmp	.+4      	; 0x5e84 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    5e80:	c0 e0       	ldi	r28, 0x00	; 0
    5e82:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    5e84:	0e 94 0e 2c 	call	0x581c	; 0x581c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    5e88:	ce 01       	movw	r24, r28
    5e8a:	df 91       	pop	r29
    5e8c:	cf 91       	pop	r28
    5e8e:	1f 91       	pop	r17
    5e90:	0f 91       	pop	r16
    5e92:	ff 90       	pop	r15
    5e94:	ef 90       	pop	r14
    5e96:	08 95       	ret

00005e98 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    5e98:	08 95       	ret

00005e9a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    5e9a:	10 92 5d 01 	sts	0x015D, r1
    5e9e:	10 92 5c 01 	sts	0x015C, r1
}
    5ea2:	08 95       	ret

00005ea4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    5ea4:	2c ed       	ldi	r18, 0xDC	; 220
    5ea6:	35 e0       	ldi	r19, 0x05	; 5
    5ea8:	80 91 5c 01 	lds	r24, 0x015C
    5eac:	90 91 5d 01 	lds	r25, 0x015D
    5eb0:	28 1b       	sub	r18, r24
    5eb2:	39 0b       	sbc	r19, r25
}
    5eb4:	c9 01       	movw	r24, r18
    5eb6:	08 95       	ret

00005eb8 <i2c_transmit>:
#include <util/twi.h>

void i2c_transmit(char address, char reg, char data)
{
	TWCR = 0xA4;                                                  // send a start bit on i2c bus
    5eb8:	94 ea       	ldi	r25, 0xA4	; 164
    5eba:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5ebc:	06 b6       	in	r0, 0x36	; 54
    5ebe:	07 fe       	sbrs	r0, 7
    5ec0:	fd cf       	rjmp	.-6      	; 0x5ebc <i2c_transmit+0x4>
	TWDR = address;                                               // load address of i2c device
    5ec2:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                  // transmit
    5ec4:	84 e8       	ldi	r24, 0x84	; 132
    5ec6:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5ec8:	06 b6       	in	r0, 0x36	; 54
    5eca:	07 fe       	sbrs	r0, 7
    5ecc:	fd cf       	rjmp	.-6      	; 0x5ec8 <i2c_transmit+0x10>
	TWDR = reg;
    5ece:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                                                  // transmit
    5ed0:	84 e8       	ldi	r24, 0x84	; 132
    5ed2:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5ed4:	06 b6       	in	r0, 0x36	; 54
    5ed6:	07 fe       	sbrs	r0, 7
    5ed8:	fd cf       	rjmp	.-6      	; 0x5ed4 <i2c_transmit+0x1c>
	TWDR = data;
    5eda:	43 b9       	out	0x03, r20	; 3
	TWCR = 0x84;                                                  // transmit
    5edc:	84 e8       	ldi	r24, 0x84	; 132
    5ede:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5ee0:	06 b6       	in	r0, 0x36	; 54
    5ee2:	07 fe       	sbrs	r0, 7
    5ee4:	fd cf       	rjmp	.-6      	; 0x5ee0 <i2c_transmit+0x28>
	TWCR = 0x94;                                                  // stop bit
    5ee6:	84 e9       	ldi	r24, 0x94	; 148
    5ee8:	86 bf       	out	0x36, r24	; 54
}
    5eea:	08 95       	ret

00005eec <i2cRead>:

unsigned char i2cRead(char address, char reg)
{
   char read_data = 0;

   TWCR = 0xA4;                                                  // send a start bit on i2c bus
    5eec:	94 ea       	ldi	r25, 0xA4	; 164
    5eee:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit  
    5ef0:	06 b6       	in	r0, 0x36	; 54
    5ef2:	07 fe       	sbrs	r0, 7
    5ef4:	fd cf       	rjmp	.-6      	; 0x5ef0 <i2cRead+0x4>
   TWDR = address;                                               // load address of i2c device
    5ef6:	83 b9       	out	0x03, r24	; 3
   TWCR = 0x84;                                                  // transmit 
    5ef8:	94 e8       	ldi	r25, 0x84	; 132
    5efa:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5efc:	06 b6       	in	r0, 0x36	; 54
    5efe:	07 fe       	sbrs	r0, 7
    5f00:	fd cf       	rjmp	.-6      	; 0x5efc <i2cRead+0x10>
   TWDR = reg;                                                   // send register number to read from
    5f02:	63 b9       	out	0x03, r22	; 3
   TWCR = 0x84;                                                  // transmit
    5f04:	94 e8       	ldi	r25, 0x84	; 132
    5f06:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f08:	06 b6       	in	r0, 0x36	; 54
    5f0a:	07 fe       	sbrs	r0, 7
    5f0c:	fd cf       	rjmp	.-6      	; 0x5f08 <i2cRead+0x1c>

   TWCR = 0xA4;                                                  // send repeated start bit
    5f0e:	94 ea       	ldi	r25, 0xA4	; 164
    5f10:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5f12:	06 b6       	in	r0, 0x36	; 54
    5f14:	07 fe       	sbrs	r0, 7
    5f16:	fd cf       	rjmp	.-6      	; 0x5f12 <i2cRead+0x26>
   TWDR = address+1;                                             // transmit address of i2c device with readbit set
    5f18:	8f 5f       	subi	r24, 0xFF	; 255
    5f1a:	83 b9       	out	0x03, r24	; 3
   TWCR = 0xC4;                                                  // clear transmit interupt flag
    5f1c:	84 ec       	ldi	r24, 0xC4	; 196
    5f1e:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f20:	06 b6       	in	r0, 0x36	; 54
    5f22:	07 fe       	sbrs	r0, 7
    5f24:	fd cf       	rjmp	.-6      	; 0x5f20 <i2cRead+0x34>
   TWCR = 0x84;                                                  // transmit, nack (last byte request)
    5f26:	84 e8       	ldi	r24, 0x84	; 132
    5f28:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5f2a:	06 b6       	in	r0, 0x36	; 54
    5f2c:	07 fe       	sbrs	r0, 7
    5f2e:	fd cf       	rjmp	.-6      	; 0x5f2a <i2cRead+0x3e>
   read_data = TWDR;                                             // and grab the target data
    5f30:	83 b1       	in	r24, 0x03	; 3
   TWCR = 0x94;                                                  // send a stop bit on i2c bus
    5f32:	94 e9       	ldi	r25, 0x94	; 148
    5f34:	96 bf       	out	0x36, r25	; 54
   return read_data;
}
    5f36:	08 95       	ret

00005f38 <lcdSiap>:


unsigned char lcdSiap(){
	unsigned char busyFlag;

	LCD_DATA_DDR = 0x00;					// Set PORT DATA sebagai input
    5f38:	1a ba       	out	0x1a, r1	; 26
	LCD_DATA_PORT = 0x00;					// Matikan pull-up
    5f3a:	1b ba       	out	0x1b, r1	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    5f3c:	ad 98       	cbi	0x15, 5	; 21
	LCD_CONTROL_PORT |= _BV(LCD_RW_BIT);	// RW = 1
    5f3e:	ae 9a       	sbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    5f40:	af 9a       	sbi	0x15, 7	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5f42:	84 e0       	ldi	r24, 0x04	; 4
    5f44:	8a 95       	dec	r24
    5f46:	f1 f7       	brne	.-4      	; 0x5f44 <lcdSiap+0xc>

	_delay_us(1);							// Beri jeda untuk menunggu input stabil

	busyFlag = (LCD_DATA_PIN & _BV(7));		// Check busy flag bit
    5f48:	89 b3       	in	r24, 0x19	; 25
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0
    5f4a:	af 98       	cbi	0x15, 7	; 21

	return busyFlag;
}
    5f4c:	80 78       	andi	r24, 0x80	; 128
    5f4e:	08 95       	ret

00005f50 <lcdWait>:

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
		busyFlag = lcdSiap();
    5f50:	0e 94 9c 2f 	call	0x5f38	; 0x5f38 <lcdSiap>
}

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
    5f54:	88 23       	and	r24, r24
    5f56:	e1 f7       	brne	.-8      	; 0x5f50 <lcdWait>
		busyFlag = lcdSiap();
	}
}
    5f58:	08 95       	ret

00005f5a <kirim_perintah_lcd>:

void kirim_perintah_lcd(unsigned char perintah){
    5f5a:	df 93       	push	r29
    5f5c:	cf 93       	push	r28
    5f5e:	0f 92       	push	r0
    5f60:	cd b7       	in	r28, 0x3d	; 61
    5f62:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    5f64:	89 83       	std	Y+1, r24	; 0x01
    5f66:	0e 94 a8 2f 	call	0x5f50	; 0x5f50 <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    5f6a:	9f ef       	ldi	r25, 0xFF	; 255
    5f6c:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    5f6e:	ad 98       	cbi	0x15, 5	; 21
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    5f70:	ae 98       	cbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    5f72:	af 9a       	sbi	0x15, 7	; 21
	LCD_DATA_PORT = perintah;				// Set perintah yang ingin dikirim	
    5f74:	89 81       	ldd	r24, Y+1	; 0x01
    5f76:	8b bb       	out	0x1b, r24	; 27
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    5f78:	af 98       	cbi	0x15, 7	; 21
}
    5f7a:	0f 90       	pop	r0
    5f7c:	cf 91       	pop	r28
    5f7e:	df 91       	pop	r29
    5f80:	08 95       	ret

00005f82 <init_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5f82:	8f e5       	ldi	r24, 0x5F	; 95
    5f84:	9a ee       	ldi	r25, 0xEA	; 234
    5f86:	01 97       	sbiw	r24, 0x01	; 1
    5f88:	f1 f7       	brne	.-4      	; 0x5f86 <init_lcd+0x4>
    5f8a:	00 c0       	rjmp	.+0      	; 0x5f8c <init_lcd+0xa>
    5f8c:	00 00       	nop
//Inisialisasi LCD
void init_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							
    kirim_perintah_lcd(0x38);  				//Function set: Interface is 8 bit long,
    5f8e:	88 e3       	ldi	r24, 0x38	; 56
    5f90:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5f94:	98 ec       	ldi	r25, 0xC8	; 200
    5f96:	9a 95       	dec	r25
    5f98:	f1 f7       	brne	.-4      	; 0x5f96 <init_lcd+0x14>
    _delay_us(50);  						// 2lines, 5x7 dots (N=1, F=0)
											//Execution time 39 us
    
    kirim_perintah_lcd(0x04);				//Display Off
    5f9a:	84 e0       	ldi	r24, 0x04	; 4
    5f9c:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x01);				//Display Clear
    5fa0:	81 e0       	ldi	r24, 0x01	; 1
    5fa2:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x06);				//Entry mode set: increment & no display shift
    5fa6:	86 e0       	ldi	r24, 0x06	; 6
    5fa8:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x0E);				//Display ON,Cursor OFF & Blink OFF
    5fac:	8e e0       	ldi	r24, 0x0E	; 14
    5fae:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
}
    5fb2:	08 95       	ret

00005fb4 <clear_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5fb4:	8f e5       	ldi	r24, 0x5F	; 95
    5fb6:	9a ee       	ldi	r25, 0xEA	; 234
    5fb8:	01 97       	sbiw	r24, 0x01	; 1
    5fba:	f1 f7       	brne	.-4      	; 0x5fb8 <clear_lcd+0x4>
    5fbc:	00 c0       	rjmp	.+0      	; 0x5fbe <clear_lcd+0xa>
    5fbe:	00 00       	nop
//Clear LCD
void clear_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							  
    kirim_perintah_lcd(0x01);				//Display Clear
    5fc0:	81 e0       	ldi	r24, 0x01	; 1
    5fc2:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
    
}
    5fc6:	08 95       	ret

00005fc8 <set_cursor>:

void set_cursor(int x,int y){
	int address = 0b10000000;
	char ddram = address ^ x;
    5fc8:	80 58       	subi	r24, 0x80	; 128
	if (y==1){
    5fca:	61 30       	cpi	r22, 0x01	; 1
    5fcc:	71 05       	cpc	r23, r1
    5fce:	11 f4       	brne	.+4      	; 0x5fd4 <set_cursor+0xc>
		ddram = ddram ^ 0b01000000;
    5fd0:	90 e4       	ldi	r25, 0x40	; 64
    5fd2:	89 27       	eor	r24, r25
	}
	kirim_perintah_lcd(ddram);
    5fd4:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <kirim_perintah_lcd>
}
    5fd8:	08 95       	ret

00005fda <tulis_data_ram_lcd>:
		tulis_data_ram_lcd(data[ii]);
	}

}

void tulis_data_ram_lcd(unsigned char data){
    5fda:	df 93       	push	r29
    5fdc:	cf 93       	push	r28
    5fde:	0f 92       	push	r0
    5fe0:	cd b7       	in	r28, 0x3d	; 61
    5fe2:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    5fe4:	89 83       	std	Y+1, r24	; 0x01
    5fe6:	0e 94 a8 2f 	call	0x5f50	; 0x5f50 <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    5fea:	9f ef       	ldi	r25, 0xFF	; 255
    5fec:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT |= _BV(LCD_RS_BIT);	// RS = 1
    5fee:	ad 9a       	sbi	0x15, 5	; 21
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    5ff0:	ae 98       	cbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    5ff2:	af 9a       	sbi	0x15, 7	; 21
	
	LCD_DATA_PORT = data;					// Set data yang ingin dikirim
    5ff4:	89 81       	ldd	r24, Y+1	; 0x01
    5ff6:	8b bb       	out	0x1b, r24	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    5ff8:	af 98       	cbi	0x15, 7	; 21
}
    5ffa:	0f 90       	pop	r0
    5ffc:	cf 91       	pop	r28
    5ffe:	df 91       	pop	r29
    6000:	08 95       	ret

00006002 <tulis_string>:
void tulis_data_at(unsigned char data, int x, int y){
	set_cursor(x,y);
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
    6002:	ef 92       	push	r14
    6004:	ff 92       	push	r15
    6006:	0f 93       	push	r16
    6008:	1f 93       	push	r17
    600a:	cf 93       	push	r28
    600c:	df 93       	push	r29
    600e:	7c 01       	movw	r14, r24
    6010:	cb 01       	movw	r24, r22
	set_cursor(x,y);
    6012:	ba 01       	movw	r22, r20
    6014:	0e 94 e4 2f 	call	0x5fc8	; 0x5fc8 <set_cursor>
    6018:	0e 2d       	mov	r16, r14
    601a:	1f 2d       	mov	r17, r15
	for(int ii=0; ii<strlen(data); ii++){
    601c:	c0 e0       	ldi	r28, 0x00	; 0
    601e:	d0 e0       	ldi	r29, 0x00	; 0
    6020:	06 c0       	rjmp	.+12     	; 0x602e <tulis_string+0x2c>
		tulis_data_ram_lcd(data[ii]);
    6022:	f8 01       	movw	r30, r16
    6024:	81 91       	ld	r24, Z+
    6026:	8f 01       	movw	r16, r30
    6028:	0e 94 ed 2f 	call	0x5fda	; 0x5fda <tulis_data_ram_lcd>
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
	set_cursor(x,y);
	for(int ii=0; ii<strlen(data); ii++){
    602c:	21 96       	adiw	r28, 0x01	; 1
    602e:	f7 01       	movw	r30, r14
    6030:	01 90       	ld	r0, Z+
    6032:	00 20       	and	r0, r0
    6034:	e9 f7       	brne	.-6      	; 0x6030 <tulis_string+0x2e>
    6036:	31 97       	sbiw	r30, 0x01	; 1
    6038:	ee 19       	sub	r30, r14
    603a:	ff 09       	sbc	r31, r15
    603c:	ce 17       	cp	r28, r30
    603e:	df 07       	cpc	r29, r31
    6040:	80 f3       	brcs	.-32     	; 0x6022 <tulis_string+0x20>
		tulis_data_ram_lcd(data[ii]);
	}

}
    6042:	df 91       	pop	r29
    6044:	cf 91       	pop	r28
    6046:	1f 91       	pop	r17
    6048:	0f 91       	pop	r16
    604a:	ff 90       	pop	r15
    604c:	ef 90       	pop	r14
    604e:	08 95       	ret

00006050 <tulis_data_at>:
		ddram = ddram ^ 0b01000000;
	}
	kirim_perintah_lcd(ddram);
}

void tulis_data_at(unsigned char data, int x, int y){
    6050:	1f 93       	push	r17
    6052:	18 2f       	mov	r17, r24
	set_cursor(x,y);
    6054:	cb 01       	movw	r24, r22
    6056:	ba 01       	movw	r22, r20
    6058:	0e 94 e4 2f 	call	0x5fc8	; 0x5fc8 <set_cursor>
	tulis_data_ram_lcd(data);
    605c:	81 2f       	mov	r24, r17
    605e:	0e 94 ed 2f 	call	0x5fda	; 0x5fda <tulis_data_ram_lcd>
}
    6062:	1f 91       	pop	r17
    6064:	08 95       	ret

00006066 <setup_seed>:
static int play_state=0;
//state mode
static int mode = SLOW_MODE;


void setup_seed(){
    6066:	1f 93       	push	r17
	 unsigned char oldADMUX = ADMUX;
    6068:	17 b1       	in	r17, 0x07	; 7
	 ADMUX |=  _BV(MUX0); //choose ADC1 on PB2
    606a:	38 9a       	sbi	0x07, 0	; 7
	 ADCSRA |= _BV(ADPS2) |_BV(ADPS1) |_BV(ADPS0); //set prescaler to max value, 128
    606c:	86 b1       	in	r24, 0x06	; 6
    606e:	87 60       	ori	r24, 0x07	; 7
    6070:	86 b9       	out	0x06, r24	; 6
	 ADCSRA |= _BV(ADEN); //enable the ADC
    6072:	37 9a       	sbi	0x06, 7	; 6
	 ADCSRA |= _BV(ADSC);//start conversion
    6074:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait until the hardware clears the flag. Note semicolon!
    6076:	36 99       	sbic	0x06, 6	; 6
    6078:	fe cf       	rjmp	.-4      	; 0x6076 <setup_seed+0x10>
	 unsigned char byte1 = ADCL;
    607a:	94 b1       	in	r25, 0x04	; 4
	 ADCSRA |= _BV(ADSC);//start conversion
    607c:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait again note semicolon!
    607e:	36 99       	sbic	0x06, 6	; 6
    6080:	fe cf       	rjmp	.-4      	; 0x607e <setup_seed+0x18>
	 unsigned char byte2 = ADCL;
    6082:	84 b1       	in	r24, 0x04	; 4
	 unsigned int seed = byte1 << 8 | byte2;
    6084:	39 2f       	mov	r19, r25
    6086:	20 e0       	ldi	r18, 0x00	; 0
    6088:	90 e0       	ldi	r25, 0x00	; 0
	 srand(seed);
    608a:	82 2b       	or	r24, r18
    608c:	93 2b       	or	r25, r19
    608e:	0e 94 38 32 	call	0x6470	; 0x6470 <srand>
	 ADCSRA &= ~_BV(ADEN); //disable ADC
    6092:	37 98       	cbi	0x06, 7	; 6
	 ADMUX = oldADMUX;
    6094:	17 b9       	out	0x07, r17	; 7
}
    6096:	1f 91       	pop	r17
    6098:	08 95       	ret

0000609a <init_game>:

void init_game(){
	setup_seed();
    609a:	0e 94 33 30 	call	0x6066	; 0x6066 <setup_seed>
	mario = 0;
    609e:	10 92 3f 07 	sts	0x073F, r1
    60a2:	10 92 3e 07 	sts	0x073E, r1
	pass = 0;
    60a6:	10 92 3b 07 	sts	0x073B, r1
    60aa:	10 92 3a 07 	sts	0x073A, r1
	speed = 0;
    60ae:	10 92 61 07 	sts	0x0761, r1
    60b2:	10 92 60 07 	sts	0x0760, r1
	summon_time = 2*TIME_INTERVAL;
    60b6:	84 e0       	ldi	r24, 0x04	; 4
    60b8:	90 e0       	ldi	r25, 0x00	; 0
    60ba:	90 93 c5 00 	sts	0x00C5, r25
    60be:	80 93 c4 00 	sts	0x00C4, r24
	play_state = GAME_PLAY;
    60c2:	10 92 3d 07 	sts	0x073D, r1
    60c6:	10 92 3c 07 	sts	0x073C, r1
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			obstacle[ii][jj] = 0;
    60ca:	10 92 41 07 	sts	0x0741, r1
    60ce:	10 92 40 07 	sts	0x0740, r1
    60d2:	10 92 43 07 	sts	0x0743, r1
    60d6:	10 92 42 07 	sts	0x0742, r1
    60da:	10 92 45 07 	sts	0x0745, r1
    60de:	10 92 44 07 	sts	0x0744, r1
    60e2:	10 92 47 07 	sts	0x0747, r1
    60e6:	10 92 46 07 	sts	0x0746, r1
    60ea:	10 92 49 07 	sts	0x0749, r1
    60ee:	10 92 48 07 	sts	0x0748, r1
    60f2:	10 92 4b 07 	sts	0x074B, r1
    60f6:	10 92 4a 07 	sts	0x074A, r1
    60fa:	10 92 4d 07 	sts	0x074D, r1
    60fe:	10 92 4c 07 	sts	0x074C, r1
    6102:	10 92 4f 07 	sts	0x074F, r1
    6106:	10 92 4e 07 	sts	0x074E, r1
    610a:	10 92 51 07 	sts	0x0751, r1
    610e:	10 92 50 07 	sts	0x0750, r1
    6112:	10 92 53 07 	sts	0x0753, r1
    6116:	10 92 52 07 	sts	0x0752, r1
    611a:	10 92 55 07 	sts	0x0755, r1
    611e:	10 92 54 07 	sts	0x0754, r1
    6122:	10 92 57 07 	sts	0x0757, r1
    6126:	10 92 56 07 	sts	0x0756, r1
    612a:	10 92 59 07 	sts	0x0759, r1
    612e:	10 92 58 07 	sts	0x0758, r1
    6132:	10 92 5b 07 	sts	0x075B, r1
    6136:	10 92 5a 07 	sts	0x075A, r1
    613a:	10 92 5d 07 	sts	0x075D, r1
    613e:	10 92 5c 07 	sts	0x075C, r1
    6142:	10 92 5f 07 	sts	0x075F, r1
    6146:	10 92 5e 07 	sts	0x075E, r1
		}
	}
	obstacle[rand()%2][7] = 1;
    614a:	0e 94 33 32 	call	0x6466	; 0x6466 <rand>
    614e:	62 e0       	ldi	r22, 0x02	; 2
    6150:	70 e0       	ldi	r23, 0x00	; 0
    6152:	0e 94 c8 31 	call	0x6390	; 0x6390 <__divmodhi4>
    6156:	24 e0       	ldi	r18, 0x04	; 4
    6158:	88 0f       	add	r24, r24
    615a:	99 1f       	adc	r25, r25
    615c:	2a 95       	dec	r18
    615e:	e1 f7       	brne	.-8      	; 0x6158 <init_game+0xbe>
    6160:	80 5c       	subi	r24, 0xC0	; 192
    6162:	98 4f       	sbci	r25, 0xF8	; 248
    6164:	21 e0       	ldi	r18, 0x01	; 1
    6166:	30 e0       	ldi	r19, 0x00	; 0
    6168:	fc 01       	movw	r30, r24
    616a:	37 87       	std	Z+15, r19	; 0x0f
    616c:	26 87       	std	Z+14, r18	; 0x0e
}
    616e:	08 95       	ret

00006170 <update_game>:


void update_game(){
    6170:	cf 93       	push	r28
    6172:	df 93       	push	r29
	if(play_state==GAME_PLAY){
    6174:	80 91 3c 07 	lds	r24, 0x073C
    6178:	90 91 3d 07 	lds	r25, 0x073D
    617c:	00 97       	sbiw	r24, 0x00	; 0
    617e:	09 f0       	breq	.+2      	; 0x6182 <update_game+0x12>
    6180:	94 c0       	rjmp	.+296    	; 0x62aa <update_game+0x13a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
    6182:	83 e0       	ldi	r24, 0x03	; 3
    6184:	90 e0       	ldi	r25, 0x00	; 0
    6186:	60 91 c2 00 	lds	r22, 0x00C2
    618a:	70 91 c3 00 	lds	r23, 0x00C3
    618e:	86 1b       	sub	r24, r22
    6190:	97 0b       	sbc	r25, r23
    6192:	20 91 60 07 	lds	r18, 0x0760
    6196:	30 91 61 07 	lds	r19, 0x0761
    619a:	82 17       	cp	r24, r18
    619c:	93 07       	cpc	r25, r19
    619e:	ec f5       	brge	.+122    	; 0x621a <update_game+0xaa>
			speed = 0;
    61a0:	10 92 61 07 	sts	0x0761, r1
    61a4:	10 92 60 07 	sts	0x0760, r1
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
						}else{
							pass+=mode;
    61a8:	40 91 3a 07 	lds	r20, 0x073A
    61ac:	50 91 3b 07 	lds	r21, 0x073B
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    61b0:	80 e0       	ldi	r24, 0x00	; 0
    61b2:	90 e0       	ldi	r25, 0x00	; 0
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
    61b4:	a1 e0       	ldi	r26, 0x01	; 1
    61b6:	b0 e0       	ldi	r27, 0x00	; 0
    61b8:	18 c0       	rjmp	.+48     	; 0x61ea <update_game+0x7a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
    61ba:	c2 81       	ldd	r28, Z+2	; 0x02
    61bc:	d3 81       	ldd	r29, Z+3	; 0x03
    61be:	20 97       	sbiw	r28, 0x00	; 0
    61c0:	51 f0       	breq	.+20     	; 0x61d6 <update_game+0x66>
						obstacle[ii][jj] = 0;
    61c2:	13 82       	std	Z+3, r1	; 0x03
    61c4:	12 82       	std	Z+2, r1	; 0x02
						if(jj>=1) {
    61c6:	21 15       	cp	r18, r1
    61c8:	31 05       	cpc	r19, r1
    61ca:	19 f0       	breq	.+6      	; 0x61d2 <update_game+0x62>
							obstacle[ii][jj-1] = 1;
    61cc:	b1 83       	std	Z+1, r27	; 0x01
    61ce:	a0 83       	st	Z, r26
    61d0:	02 c0       	rjmp	.+4      	; 0x61d6 <update_game+0x66>
						}else{
							pass+=mode;
    61d2:	46 0f       	add	r20, r22
    61d4:	57 1f       	adc	r21, r23
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
    61d6:	2f 5f       	subi	r18, 0xFF	; 255
    61d8:	3f 4f       	sbci	r19, 0xFF	; 255
    61da:	32 96       	adiw	r30, 0x02	; 2
    61dc:	28 30       	cpi	r18, 0x08	; 8
    61de:	31 05       	cpc	r19, r1
    61e0:	61 f7       	brne	.-40     	; 0x61ba <update_game+0x4a>
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    61e2:	01 96       	adiw	r24, 0x01	; 1
    61e4:	82 30       	cpi	r24, 0x02	; 2
    61e6:	91 05       	cpc	r25, r1
    61e8:	59 f0       	breq	.+22     	; 0x6200 <update_game+0x90>
	}
	obstacle[rand()%2][7] = 1;
}


void update_game(){
    61ea:	fc 01       	movw	r30, r24
    61ec:	24 e0       	ldi	r18, 0x04	; 4
    61ee:	ee 0f       	add	r30, r30
    61f0:	ff 1f       	adc	r31, r31
    61f2:	2a 95       	dec	r18
    61f4:	e1 f7       	brne	.-8      	; 0x61ee <update_game+0x7e>
    61f6:	e2 5c       	subi	r30, 0xC2	; 194
    61f8:	f8 4f       	sbci	r31, 0xF8	; 248
    61fa:	20 e0       	ldi	r18, 0x00	; 0
    61fc:	30 e0       	ldi	r19, 0x00	; 0
    61fe:	dd cf       	rjmp	.-70     	; 0x61ba <update_game+0x4a>
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    6200:	50 93 3b 07 	sts	0x073B, r21
    6204:	40 93 3a 07 	sts	0x073A, r20
						}				
					}

				}
			}
			summon_time--;	
    6208:	80 91 c4 00 	lds	r24, 0x00C4
    620c:	90 91 c5 00 	lds	r25, 0x00C5
    6210:	01 97       	sbiw	r24, 0x01	; 1
    6212:	90 93 c5 00 	sts	0x00C5, r25
    6216:	80 93 c4 00 	sts	0x00C4, r24
		}	

		

		if(obstacle[mario][0]){
    621a:	e0 91 3e 07 	lds	r30, 0x073E
    621e:	f0 91 3f 07 	lds	r31, 0x073F
    6222:	44 e0       	ldi	r20, 0x04	; 4
    6224:	ee 0f       	add	r30, r30
    6226:	ff 1f       	adc	r31, r31
    6228:	4a 95       	dec	r20
    622a:	e1 f7       	brne	.-8      	; 0x6224 <update_game+0xb4>
    622c:	e0 5c       	subi	r30, 0xC0	; 192
    622e:	f8 4f       	sbci	r31, 0xF8	; 248
    6230:	80 81       	ld	r24, Z
    6232:	91 81       	ldd	r25, Z+1	; 0x01
    6234:	00 97       	sbiw	r24, 0x00	; 0
    6236:	31 f0       	breq	.+12     	; 0x6244 <update_game+0xd4>
			play_state = GAME_FINAL;
    6238:	81 e0       	ldi	r24, 0x01	; 1
    623a:	90 e0       	ldi	r25, 0x00	; 0
    623c:	90 93 3d 07 	sts	0x073D, r25
    6240:	80 93 3c 07 	sts	0x073C, r24
		}


		if(summon_time<=0){
    6244:	80 91 c4 00 	lds	r24, 0x00C4
    6248:	90 91 c5 00 	lds	r25, 0x00C5
    624c:	18 16       	cp	r1, r24
    624e:	19 06       	cpc	r1, r25
    6250:	1c f1       	brlt	.+70     	; 0x6298 <update_game+0x128>
			int yy =  rand()%2;
    6252:	0e 94 33 32 	call	0x6466	; 0x6466 <rand>
    6256:	62 e0       	ldi	r22, 0x02	; 2
    6258:	70 e0       	ldi	r23, 0x00	; 0
    625a:	0e 94 c8 31 	call	0x6390	; 0x6390 <__divmodhi4>
			obstacle[yy][7] = 1;
    625e:	34 e0       	ldi	r19, 0x04	; 4
    6260:	88 0f       	add	r24, r24
    6262:	99 1f       	adc	r25, r25
    6264:	3a 95       	dec	r19
    6266:	e1 f7       	brne	.-8      	; 0x6260 <update_game+0xf0>
    6268:	80 5c       	subi	r24, 0xC0	; 192
    626a:	98 4f       	sbci	r25, 0xF8	; 248
    626c:	21 e0       	ldi	r18, 0x01	; 1
    626e:	30 e0       	ldi	r19, 0x00	; 0
    6270:	fc 01       	movw	r30, r24
    6272:	37 87       	std	Z+15, r19	; 0x0f
    6274:	26 87       	std	Z+14, r18	; 0x0e
			summon_time = rand()%(3-(mode-1))+2;	
    6276:	0e 94 33 32 	call	0x6466	; 0x6466 <rand>
    627a:	64 e0       	ldi	r22, 0x04	; 4
    627c:	70 e0       	ldi	r23, 0x00	; 0
    627e:	20 91 c2 00 	lds	r18, 0x00C2
    6282:	30 91 c3 00 	lds	r19, 0x00C3
    6286:	62 1b       	sub	r22, r18
    6288:	73 0b       	sbc	r23, r19
    628a:	0e 94 c8 31 	call	0x6390	; 0x6390 <__divmodhi4>
    628e:	02 96       	adiw	r24, 0x02	; 2
    6290:	90 93 c5 00 	sts	0x00C5, r25
    6294:	80 93 c4 00 	sts	0x00C4, r24
		}

		speed++;
    6298:	80 91 60 07 	lds	r24, 0x0760
    629c:	90 91 61 07 	lds	r25, 0x0761
    62a0:	01 96       	adiw	r24, 0x01	; 1
    62a2:	90 93 61 07 	sts	0x0761, r25
    62a6:	80 93 60 07 	sts	0x0760, r24
	}
}
    62aa:	df 91       	pop	r29
    62ac:	cf 91       	pop	r28
    62ae:	08 95       	ret

000062b0 <draw_game>:



void draw_game(){
    62b0:	ef 92       	push	r14
    62b2:	ff 92       	push	r15
    62b4:	0f 93       	push	r16
    62b6:	1f 93       	push	r17
    62b8:	cf 93       	push	r28
    62ba:	df 93       	push	r29
	tulis_data_at('M',0,mario);
    62bc:	40 91 3e 07 	lds	r20, 0x073E
    62c0:	50 91 3f 07 	lds	r21, 0x073F
    62c4:	8d e4       	ldi	r24, 0x4D	; 77
    62c6:	60 e0       	ldi	r22, 0x00	; 0
    62c8:	70 e0       	ldi	r23, 0x00	; 0
    62ca:	0e 94 28 30 	call	0x6050	; 0x6050 <tulis_data_at>
	if(mario==1){
    62ce:	80 91 3e 07 	lds	r24, 0x073E
    62d2:	90 91 3f 07 	lds	r25, 0x073F
    62d6:	81 30       	cpi	r24, 0x01	; 1
    62d8:	91 05       	cpc	r25, r1
    62da:	31 f4       	brne	.+12     	; 0x62e8 <draw_game+0x38>
		tulis_data_at(' ',0,0);
    62dc:	80 e2       	ldi	r24, 0x20	; 32
    62de:	60 e0       	ldi	r22, 0x00	; 0
    62e0:	70 e0       	ldi	r23, 0x00	; 0
    62e2:	40 e0       	ldi	r20, 0x00	; 0
    62e4:	50 e0       	ldi	r21, 0x00	; 0
    62e6:	05 c0       	rjmp	.+10     	; 0x62f2 <draw_game+0x42>
	}else{
		tulis_data_at(' ',0,1);
    62e8:	80 e2       	ldi	r24, 0x20	; 32
    62ea:	60 e0       	ldi	r22, 0x00	; 0
    62ec:	70 e0       	ldi	r23, 0x00	; 0
    62ee:	41 e0       	ldi	r20, 0x01	; 1
    62f0:	50 e0       	ldi	r21, 0x00	; 0
    62f2:	0e 94 28 30 	call	0x6050	; 0x6050 <tulis_data_at>
	}
}



void draw_game(){
    62f6:	c0 e0       	ldi	r28, 0x00	; 0
    62f8:	d0 e0       	ldi	r29, 0x00	; 0
    62fa:	16 c0       	rjmp	.+44     	; 0x6328 <draw_game+0x78>
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			if(obstacle[ii][jj]){
    62fc:	f8 01       	movw	r30, r16
    62fe:	81 91       	ld	r24, Z+
    6300:	91 91       	ld	r25, Z+
    6302:	8f 01       	movw	r16, r30
    6304:	00 97       	sbiw	r24, 0x00	; 0
    6306:	29 f0       	breq	.+10     	; 0x6312 <draw_game+0x62>
				tulis_data_at('#',jj,ii);			
    6308:	83 e2       	ldi	r24, 0x23	; 35
    630a:	b7 01       	movw	r22, r14
    630c:	ae 01       	movw	r20, r28
    630e:	0e 94 28 30 	call	0x6050	; 0x6050 <tulis_data_at>
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
    6312:	08 94       	sec
    6314:	e1 1c       	adc	r14, r1
    6316:	f1 1c       	adc	r15, r1
    6318:	f8 e0       	ldi	r31, 0x08	; 8
    631a:	ef 16       	cp	r14, r31
    631c:	f1 04       	cpc	r15, r1
    631e:	71 f7       	brne	.-36     	; 0x62fc <draw_game+0x4c>
	if(mario==1){
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
    6320:	21 96       	adiw	r28, 0x01	; 1
    6322:	c2 30       	cpi	r28, 0x02	; 2
    6324:	d1 05       	cpc	r29, r1
    6326:	59 f0       	breq	.+22     	; 0x633e <draw_game+0x8e>
	}
}



void draw_game(){
    6328:	8e 01       	movw	r16, r28
    632a:	34 e0       	ldi	r19, 0x04	; 4
    632c:	00 0f       	add	r16, r16
    632e:	11 1f       	adc	r17, r17
    6330:	3a 95       	dec	r19
    6332:	e1 f7       	brne	.-8      	; 0x632c <draw_game+0x7c>
    6334:	00 5c       	subi	r16, 0xC0	; 192
    6336:	18 4f       	sbci	r17, 0xF8	; 248
    6338:	ee 24       	eor	r14, r14
    633a:	ff 24       	eor	r15, r15
    633c:	df cf       	rjmp	.-66     	; 0x62fc <draw_game+0x4c>
				tulis_data_at('#',jj,ii);			
			}
		}
	}
	
}
    633e:	df 91       	pop	r29
    6340:	cf 91       	pop	r28
    6342:	1f 91       	pop	r17
    6344:	0f 91       	pop	r16
    6346:	ff 90       	pop	r15
    6348:	ef 90       	pop	r14
    634a:	08 95       	ret

0000634c <set_mario>:

void set_mario(int loc){
	if(loc==0){
    634c:	00 97       	sbiw	r24, 0x00	; 0
    634e:	29 f4       	brne	.+10     	; 0x635a <set_mario+0xe>
		mario = 0;
    6350:	10 92 3f 07 	sts	0x073F, r1
    6354:	10 92 3e 07 	sts	0x073E, r1
    6358:	08 95       	ret
	}else{
		mario = 1;
    635a:	81 e0       	ldi	r24, 0x01	; 1
    635c:	90 e0       	ldi	r25, 0x00	; 0
    635e:	90 93 3f 07 	sts	0x073F, r25
    6362:	80 93 3e 07 	sts	0x073E, r24
    6366:	08 95       	ret

00006368 <get_mario>:
	}
}

int get_mario(){
	return mario;
}
    6368:	80 91 3e 07 	lds	r24, 0x073E
    636c:	90 91 3f 07 	lds	r25, 0x073F
    6370:	08 95       	ret

00006372 <get_state>:


int get_state(){
	return play_state;
}
    6372:	80 91 3c 07 	lds	r24, 0x073C
    6376:	90 91 3d 07 	lds	r25, 0x073D
    637a:	08 95       	ret

0000637c <getpass>:

int getpass(){
	return pass;
}
    637c:	80 91 3a 07 	lds	r24, 0x073A
    6380:	90 91 3b 07 	lds	r25, 0x073B
    6384:	08 95       	ret

00006386 <set_mode>:

void set_mode(int mod){
	mode = mod;
    6386:	90 93 c3 00 	sts	0x00C3, r25
    638a:	80 93 c2 00 	sts	0x00C2, r24
}
    638e:	08 95       	ret

00006390 <__divmodhi4>:
    6390:	97 fb       	bst	r25, 7
    6392:	09 2e       	mov	r0, r25
    6394:	07 26       	eor	r0, r23
    6396:	0a d0       	rcall	.+20     	; 0x63ac <__divmodhi4_neg1>
    6398:	77 fd       	sbrc	r23, 7
    639a:	04 d0       	rcall	.+8      	; 0x63a4 <__divmodhi4_neg2>
    639c:	0c d0       	rcall	.+24     	; 0x63b6 <__udivmodhi4>
    639e:	06 d0       	rcall	.+12     	; 0x63ac <__divmodhi4_neg1>
    63a0:	00 20       	and	r0, r0
    63a2:	1a f4       	brpl	.+6      	; 0x63aa <__divmodhi4_exit>

000063a4 <__divmodhi4_neg2>:
    63a4:	70 95       	com	r23
    63a6:	61 95       	neg	r22
    63a8:	7f 4f       	sbci	r23, 0xFF	; 255

000063aa <__divmodhi4_exit>:
    63aa:	08 95       	ret

000063ac <__divmodhi4_neg1>:
    63ac:	f6 f7       	brtc	.-4      	; 0x63aa <__divmodhi4_exit>
    63ae:	90 95       	com	r25
    63b0:	81 95       	neg	r24
    63b2:	9f 4f       	sbci	r25, 0xFF	; 255
    63b4:	08 95       	ret

000063b6 <__udivmodhi4>:
    63b6:	aa 1b       	sub	r26, r26
    63b8:	bb 1b       	sub	r27, r27
    63ba:	51 e1       	ldi	r21, 0x11	; 17
    63bc:	07 c0       	rjmp	.+14     	; 0x63cc <__udivmodhi4_ep>

000063be <__udivmodhi4_loop>:
    63be:	aa 1f       	adc	r26, r26
    63c0:	bb 1f       	adc	r27, r27
    63c2:	a6 17       	cp	r26, r22
    63c4:	b7 07       	cpc	r27, r23
    63c6:	10 f0       	brcs	.+4      	; 0x63cc <__udivmodhi4_ep>
    63c8:	a6 1b       	sub	r26, r22
    63ca:	b7 0b       	sbc	r27, r23

000063cc <__udivmodhi4_ep>:
    63cc:	88 1f       	adc	r24, r24
    63ce:	99 1f       	adc	r25, r25
    63d0:	5a 95       	dec	r21
    63d2:	a9 f7       	brne	.-22     	; 0x63be <__udivmodhi4_loop>
    63d4:	80 95       	com	r24
    63d6:	90 95       	com	r25
    63d8:	bc 01       	movw	r22, r24
    63da:	cd 01       	movw	r24, r26
    63dc:	08 95       	ret

000063de <do_rand>:
    63de:	a0 e0       	ldi	r26, 0x00	; 0
    63e0:	b0 e0       	ldi	r27, 0x00	; 0
    63e2:	e5 ef       	ldi	r30, 0xF5	; 245
    63e4:	f1 e3       	ldi	r31, 0x31	; 49
    63e6:	0c 94 37 33 	jmp	0x666e	; 0x666e <__prologue_saves__+0x10>
    63ea:	ec 01       	movw	r28, r24
    63ec:	68 81       	ld	r22, Y
    63ee:	79 81       	ldd	r23, Y+1	; 0x01
    63f0:	8a 81       	ldd	r24, Y+2	; 0x02
    63f2:	9b 81       	ldd	r25, Y+3	; 0x03
    63f4:	61 15       	cp	r22, r1
    63f6:	71 05       	cpc	r23, r1
    63f8:	81 05       	cpc	r24, r1
    63fa:	91 05       	cpc	r25, r1
    63fc:	21 f4       	brne	.+8      	; 0x6406 <do_rand+0x28>
    63fe:	64 e2       	ldi	r22, 0x24	; 36
    6400:	79 ed       	ldi	r23, 0xD9	; 217
    6402:	8b e5       	ldi	r24, 0x5B	; 91
    6404:	97 e0       	ldi	r25, 0x07	; 7
    6406:	2d e1       	ldi	r18, 0x1D	; 29
    6408:	33 ef       	ldi	r19, 0xF3	; 243
    640a:	41 e0       	ldi	r20, 0x01	; 1
    640c:	50 e0       	ldi	r21, 0x00	; 0
    640e:	0e 94 14 33 	call	0x6628	; 0x6628 <__divmodsi4>
    6412:	79 01       	movw	r14, r18
    6414:	8a 01       	movw	r16, r20
    6416:	27 ea       	ldi	r18, 0xA7	; 167
    6418:	31 e4       	ldi	r19, 0x41	; 65
    641a:	40 e0       	ldi	r20, 0x00	; 0
    641c:	50 e0       	ldi	r21, 0x00	; 0
    641e:	0e 94 d3 32 	call	0x65a6	; 0x65a6 <__mulsi3>
    6422:	5b 01       	movw	r10, r22
    6424:	6c 01       	movw	r12, r24
    6426:	c8 01       	movw	r24, r16
    6428:	b7 01       	movw	r22, r14
    642a:	2c ee       	ldi	r18, 0xEC	; 236
    642c:	34 ef       	ldi	r19, 0xF4	; 244
    642e:	4f ef       	ldi	r20, 0xFF	; 255
    6430:	5f ef       	ldi	r21, 0xFF	; 255
    6432:	0e 94 d3 32 	call	0x65a6	; 0x65a6 <__mulsi3>
    6436:	6a 0d       	add	r22, r10
    6438:	7b 1d       	adc	r23, r11
    643a:	8c 1d       	adc	r24, r12
    643c:	9d 1d       	adc	r25, r13
    643e:	97 ff       	sbrs	r25, 7
    6440:	04 c0       	rjmp	.+8      	; 0x644a <do_rand+0x6c>
    6442:	61 50       	subi	r22, 0x01	; 1
    6444:	70 40       	sbci	r23, 0x00	; 0
    6446:	80 40       	sbci	r24, 0x00	; 0
    6448:	90 48       	sbci	r25, 0x80	; 128
    644a:	68 83       	st	Y, r22
    644c:	79 83       	std	Y+1, r23	; 0x01
    644e:	8a 83       	std	Y+2, r24	; 0x02
    6450:	9b 83       	std	Y+3, r25	; 0x03
    6452:	7f 77       	andi	r23, 0x7F	; 127
    6454:	cb 01       	movw	r24, r22
    6456:	cd b7       	in	r28, 0x3d	; 61
    6458:	de b7       	in	r29, 0x3e	; 62
    645a:	ea e0       	ldi	r30, 0x0A	; 10
    645c:	0c 94 53 33 	jmp	0x66a6	; 0x66a6 <__epilogue_restores__+0x10>

00006460 <rand_r>:
    6460:	0e 94 ef 31 	call	0x63de	; 0x63de <do_rand>
    6464:	08 95       	ret

00006466 <rand>:
    6466:	86 ec       	ldi	r24, 0xC6	; 198
    6468:	90 e0       	ldi	r25, 0x00	; 0
    646a:	0e 94 ef 31 	call	0x63de	; 0x63de <do_rand>
    646e:	08 95       	ret

00006470 <srand>:
    6470:	a0 e0       	ldi	r26, 0x00	; 0
    6472:	b0 e0       	ldi	r27, 0x00	; 0
    6474:	80 93 c6 00 	sts	0x00C6, r24
    6478:	90 93 c7 00 	sts	0x00C7, r25
    647c:	a0 93 c8 00 	sts	0x00C8, r26
    6480:	b0 93 c9 00 	sts	0x00C9, r27
    6484:	08 95       	ret

00006486 <memcpy>:
    6486:	fb 01       	movw	r30, r22
    6488:	dc 01       	movw	r26, r24
    648a:	02 c0       	rjmp	.+4      	; 0x6490 <memcpy+0xa>
    648c:	01 90       	ld	r0, Z+
    648e:	0d 92       	st	X+, r0
    6490:	41 50       	subi	r20, 0x01	; 1
    6492:	50 40       	sbci	r21, 0x00	; 0
    6494:	d8 f7       	brcc	.-10     	; 0x648c <memcpy+0x6>
    6496:	08 95       	ret

00006498 <memset>:
    6498:	dc 01       	movw	r26, r24
    649a:	01 c0       	rjmp	.+2      	; 0x649e <memset+0x6>
    649c:	6d 93       	st	X+, r22
    649e:	41 50       	subi	r20, 0x01	; 1
    64a0:	50 40       	sbci	r21, 0x00	; 0
    64a2:	e0 f7       	brcc	.-8      	; 0x649c <memset+0x4>
    64a4:	08 95       	ret

000064a6 <strncpy>:
    64a6:	fb 01       	movw	r30, r22
    64a8:	dc 01       	movw	r26, r24
    64aa:	41 50       	subi	r20, 0x01	; 1
    64ac:	50 40       	sbci	r21, 0x00	; 0
    64ae:	48 f0       	brcs	.+18     	; 0x64c2 <strncpy+0x1c>
    64b0:	01 90       	ld	r0, Z+
    64b2:	0d 92       	st	X+, r0
    64b4:	00 20       	and	r0, r0
    64b6:	c9 f7       	brne	.-14     	; 0x64aa <strncpy+0x4>
    64b8:	01 c0       	rjmp	.+2      	; 0x64bc <strncpy+0x16>
    64ba:	1d 92       	st	X+, r1
    64bc:	41 50       	subi	r20, 0x01	; 1
    64be:	50 40       	sbci	r21, 0x00	; 0
    64c0:	e0 f7       	brcc	.-8      	; 0x64ba <strncpy+0x14>
    64c2:	08 95       	ret

000064c4 <ltoa>:
    64c4:	fa 01       	movw	r30, r20
    64c6:	cf 93       	push	r28
    64c8:	ff 93       	push	r31
    64ca:	ef 93       	push	r30
    64cc:	22 30       	cpi	r18, 0x02	; 2
    64ce:	44 f1       	brlt	.+80     	; 0x6520 <ltoa+0x5c>
    64d0:	25 32       	cpi	r18, 0x25	; 37
    64d2:	34 f5       	brge	.+76     	; 0x6520 <ltoa+0x5c>
    64d4:	c2 2f       	mov	r28, r18
    64d6:	e8 94       	clt
    64d8:	ca 30       	cpi	r28, 0x0A	; 10
    64da:	49 f4       	brne	.+18     	; 0x64ee <ltoa+0x2a>
    64dc:	97 fb       	bst	r25, 7
    64de:	3e f4       	brtc	.+14     	; 0x64ee <ltoa+0x2a>
    64e0:	90 95       	com	r25
    64e2:	80 95       	com	r24
    64e4:	70 95       	com	r23
    64e6:	61 95       	neg	r22
    64e8:	7f 4f       	sbci	r23, 0xFF	; 255
    64ea:	8f 4f       	sbci	r24, 0xFF	; 255
    64ec:	9f 4f       	sbci	r25, 0xFF	; 255
    64ee:	2c 2f       	mov	r18, r28
    64f0:	33 27       	eor	r19, r19
    64f2:	44 27       	eor	r20, r20
    64f4:	55 27       	eor	r21, r21
    64f6:	ff 93       	push	r31
    64f8:	ef 93       	push	r30
    64fa:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <__udivmodsi4>
    64fe:	ef 91       	pop	r30
    6500:	ff 91       	pop	r31
    6502:	60 5d       	subi	r22, 0xD0	; 208
    6504:	6a 33       	cpi	r22, 0x3A	; 58
    6506:	0c f0       	brlt	.+2      	; 0x650a <ltoa+0x46>
    6508:	69 5d       	subi	r22, 0xD9	; 217
    650a:	61 93       	st	Z+, r22
    650c:	b9 01       	movw	r22, r18
    650e:	ca 01       	movw	r24, r20
    6510:	60 50       	subi	r22, 0x00	; 0
    6512:	70 40       	sbci	r23, 0x00	; 0
    6514:	80 40       	sbci	r24, 0x00	; 0
    6516:	90 40       	sbci	r25, 0x00	; 0
    6518:	51 f7       	brne	.-44     	; 0x64ee <ltoa+0x2a>
    651a:	16 f4       	brtc	.+4      	; 0x6520 <ltoa+0x5c>
    651c:	cd e2       	ldi	r28, 0x2D	; 45
    651e:	c1 93       	st	Z+, r28
    6520:	10 82       	st	Z, r1
    6522:	8f 91       	pop	r24
    6524:	9f 91       	pop	r25
    6526:	cf 91       	pop	r28
    6528:	0c 94 a2 32 	jmp	0x6544	; 0x6544 <strrev>

0000652c <__eerd_word_m32>:
    652c:	a8 e1       	ldi	r26, 0x18	; 24
    652e:	b0 e0       	ldi	r27, 0x00	; 0
    6530:	42 e0       	ldi	r20, 0x02	; 2
    6532:	50 e0       	ldi	r21, 0x00	; 0
    6534:	0c 94 b4 32 	jmp	0x6568	; 0x6568 <__eerd_blraw_m32>

00006538 <__eeupd_word_m32>:
    6538:	01 96       	adiw	r24, 0x01	; 1
    653a:	27 2f       	mov	r18, r23
    653c:	0e 94 c3 32 	call	0x6586	; 0x6586 <__eeupd_r18_m32>
    6540:	0c 94 c2 32 	jmp	0x6584	; 0x6584 <__eeupd_byte_m32>

00006544 <strrev>:
    6544:	dc 01       	movw	r26, r24
    6546:	fc 01       	movw	r30, r24
    6548:	67 2f       	mov	r22, r23
    654a:	71 91       	ld	r23, Z+
    654c:	77 23       	and	r23, r23
    654e:	e1 f7       	brne	.-8      	; 0x6548 <strrev+0x4>
    6550:	32 97       	sbiw	r30, 0x02	; 2
    6552:	04 c0       	rjmp	.+8      	; 0x655c <strrev+0x18>
    6554:	7c 91       	ld	r23, X
    6556:	6d 93       	st	X+, r22
    6558:	70 83       	st	Z, r23
    655a:	62 91       	ld	r22, -Z
    655c:	ae 17       	cp	r26, r30
    655e:	bf 07       	cpc	r27, r31
    6560:	c8 f3       	brcs	.-14     	; 0x6554 <strrev+0x10>
    6562:	08 95       	ret

00006564 <__eerd_block_m32>:
    6564:	dc 01       	movw	r26, r24
    6566:	cb 01       	movw	r24, r22

00006568 <__eerd_blraw_m32>:
    6568:	fc 01       	movw	r30, r24
    656a:	e1 99       	sbic	0x1c, 1	; 28
    656c:	fe cf       	rjmp	.-4      	; 0x656a <__eerd_blraw_m32+0x2>
    656e:	06 c0       	rjmp	.+12     	; 0x657c <__eerd_blraw_m32+0x14>
    6570:	ff bb       	out	0x1f, r31	; 31
    6572:	ee bb       	out	0x1e, r30	; 30
    6574:	e0 9a       	sbi	0x1c, 0	; 28
    6576:	31 96       	adiw	r30, 0x01	; 1
    6578:	0d b2       	in	r0, 0x1d	; 29
    657a:	0d 92       	st	X+, r0
    657c:	41 50       	subi	r20, 0x01	; 1
    657e:	50 40       	sbci	r21, 0x00	; 0
    6580:	b8 f7       	brcc	.-18     	; 0x6570 <__eerd_blraw_m32+0x8>
    6582:	08 95       	ret

00006584 <__eeupd_byte_m32>:
    6584:	26 2f       	mov	r18, r22

00006586 <__eeupd_r18_m32>:
    6586:	e1 99       	sbic	0x1c, 1	; 28
    6588:	fe cf       	rjmp	.-4      	; 0x6586 <__eeupd_r18_m32>
    658a:	9f bb       	out	0x1f, r25	; 31
    658c:	8e bb       	out	0x1e, r24	; 30
    658e:	e0 9a       	sbi	0x1c, 0	; 28
    6590:	01 97       	sbiw	r24, 0x01	; 1
    6592:	0d b2       	in	r0, 0x1d	; 29
    6594:	02 16       	cp	r0, r18
    6596:	31 f0       	breq	.+12     	; 0x65a4 <__eeupd_r18_m32+0x1e>
    6598:	2d bb       	out	0x1d, r18	; 29
    659a:	0f b6       	in	r0, 0x3f	; 63
    659c:	f8 94       	cli
    659e:	e2 9a       	sbi	0x1c, 2	; 28
    65a0:	e1 9a       	sbi	0x1c, 1	; 28
    65a2:	0f be       	out	0x3f, r0	; 63
    65a4:	08 95       	ret

000065a6 <__mulsi3>:
    65a6:	62 9f       	mul	r22, r18
    65a8:	d0 01       	movw	r26, r0
    65aa:	73 9f       	mul	r23, r19
    65ac:	f0 01       	movw	r30, r0
    65ae:	82 9f       	mul	r24, r18
    65b0:	e0 0d       	add	r30, r0
    65b2:	f1 1d       	adc	r31, r1
    65b4:	64 9f       	mul	r22, r20
    65b6:	e0 0d       	add	r30, r0
    65b8:	f1 1d       	adc	r31, r1
    65ba:	92 9f       	mul	r25, r18
    65bc:	f0 0d       	add	r31, r0
    65be:	83 9f       	mul	r24, r19
    65c0:	f0 0d       	add	r31, r0
    65c2:	74 9f       	mul	r23, r20
    65c4:	f0 0d       	add	r31, r0
    65c6:	65 9f       	mul	r22, r21
    65c8:	f0 0d       	add	r31, r0
    65ca:	99 27       	eor	r25, r25
    65cc:	72 9f       	mul	r23, r18
    65ce:	b0 0d       	add	r27, r0
    65d0:	e1 1d       	adc	r30, r1
    65d2:	f9 1f       	adc	r31, r25
    65d4:	63 9f       	mul	r22, r19
    65d6:	b0 0d       	add	r27, r0
    65d8:	e1 1d       	adc	r30, r1
    65da:	f9 1f       	adc	r31, r25
    65dc:	bd 01       	movw	r22, r26
    65de:	cf 01       	movw	r24, r30
    65e0:	11 24       	eor	r1, r1
    65e2:	08 95       	ret

000065e4 <__udivmodsi4>:
    65e4:	a1 e2       	ldi	r26, 0x21	; 33
    65e6:	1a 2e       	mov	r1, r26
    65e8:	aa 1b       	sub	r26, r26
    65ea:	bb 1b       	sub	r27, r27
    65ec:	fd 01       	movw	r30, r26
    65ee:	0d c0       	rjmp	.+26     	; 0x660a <__udivmodsi4_ep>

000065f0 <__udivmodsi4_loop>:
    65f0:	aa 1f       	adc	r26, r26
    65f2:	bb 1f       	adc	r27, r27
    65f4:	ee 1f       	adc	r30, r30
    65f6:	ff 1f       	adc	r31, r31
    65f8:	a2 17       	cp	r26, r18
    65fa:	b3 07       	cpc	r27, r19
    65fc:	e4 07       	cpc	r30, r20
    65fe:	f5 07       	cpc	r31, r21
    6600:	20 f0       	brcs	.+8      	; 0x660a <__udivmodsi4_ep>
    6602:	a2 1b       	sub	r26, r18
    6604:	b3 0b       	sbc	r27, r19
    6606:	e4 0b       	sbc	r30, r20
    6608:	f5 0b       	sbc	r31, r21

0000660a <__udivmodsi4_ep>:
    660a:	66 1f       	adc	r22, r22
    660c:	77 1f       	adc	r23, r23
    660e:	88 1f       	adc	r24, r24
    6610:	99 1f       	adc	r25, r25
    6612:	1a 94       	dec	r1
    6614:	69 f7       	brne	.-38     	; 0x65f0 <__udivmodsi4_loop>
    6616:	60 95       	com	r22
    6618:	70 95       	com	r23
    661a:	80 95       	com	r24
    661c:	90 95       	com	r25
    661e:	9b 01       	movw	r18, r22
    6620:	ac 01       	movw	r20, r24
    6622:	bd 01       	movw	r22, r26
    6624:	cf 01       	movw	r24, r30
    6626:	08 95       	ret

00006628 <__divmodsi4>:
    6628:	97 fb       	bst	r25, 7
    662a:	09 2e       	mov	r0, r25
    662c:	05 26       	eor	r0, r21
    662e:	0e d0       	rcall	.+28     	; 0x664c <__divmodsi4_neg1>
    6630:	57 fd       	sbrc	r21, 7
    6632:	04 d0       	rcall	.+8      	; 0x663c <__divmodsi4_neg2>
    6634:	d7 df       	rcall	.-82     	; 0x65e4 <__udivmodsi4>
    6636:	0a d0       	rcall	.+20     	; 0x664c <__divmodsi4_neg1>
    6638:	00 1c       	adc	r0, r0
    663a:	38 f4       	brcc	.+14     	; 0x664a <__divmodsi4_exit>

0000663c <__divmodsi4_neg2>:
    663c:	50 95       	com	r21
    663e:	40 95       	com	r20
    6640:	30 95       	com	r19
    6642:	21 95       	neg	r18
    6644:	3f 4f       	sbci	r19, 0xFF	; 255
    6646:	4f 4f       	sbci	r20, 0xFF	; 255
    6648:	5f 4f       	sbci	r21, 0xFF	; 255

0000664a <__divmodsi4_exit>:
    664a:	08 95       	ret

0000664c <__divmodsi4_neg1>:
    664c:	f6 f7       	brtc	.-4      	; 0x664a <__divmodsi4_exit>
    664e:	90 95       	com	r25
    6650:	80 95       	com	r24
    6652:	70 95       	com	r23
    6654:	61 95       	neg	r22
    6656:	7f 4f       	sbci	r23, 0xFF	; 255
    6658:	8f 4f       	sbci	r24, 0xFF	; 255
    665a:	9f 4f       	sbci	r25, 0xFF	; 255
    665c:	08 95       	ret

0000665e <__prologue_saves__>:
    665e:	2f 92       	push	r2
    6660:	3f 92       	push	r3
    6662:	4f 92       	push	r4
    6664:	5f 92       	push	r5
    6666:	6f 92       	push	r6
    6668:	7f 92       	push	r7
    666a:	8f 92       	push	r8
    666c:	9f 92       	push	r9
    666e:	af 92       	push	r10
    6670:	bf 92       	push	r11
    6672:	cf 92       	push	r12
    6674:	df 92       	push	r13
    6676:	ef 92       	push	r14
    6678:	ff 92       	push	r15
    667a:	0f 93       	push	r16
    667c:	1f 93       	push	r17
    667e:	cf 93       	push	r28
    6680:	df 93       	push	r29
    6682:	cd b7       	in	r28, 0x3d	; 61
    6684:	de b7       	in	r29, 0x3e	; 62
    6686:	ca 1b       	sub	r28, r26
    6688:	db 0b       	sbc	r29, r27
    668a:	0f b6       	in	r0, 0x3f	; 63
    668c:	f8 94       	cli
    668e:	de bf       	out	0x3e, r29	; 62
    6690:	0f be       	out	0x3f, r0	; 63
    6692:	cd bf       	out	0x3d, r28	; 61
    6694:	09 94       	ijmp

00006696 <__epilogue_restores__>:
    6696:	2a 88       	ldd	r2, Y+18	; 0x12
    6698:	39 88       	ldd	r3, Y+17	; 0x11
    669a:	48 88       	ldd	r4, Y+16	; 0x10
    669c:	5f 84       	ldd	r5, Y+15	; 0x0f
    669e:	6e 84       	ldd	r6, Y+14	; 0x0e
    66a0:	7d 84       	ldd	r7, Y+13	; 0x0d
    66a2:	8c 84       	ldd	r8, Y+12	; 0x0c
    66a4:	9b 84       	ldd	r9, Y+11	; 0x0b
    66a6:	aa 84       	ldd	r10, Y+10	; 0x0a
    66a8:	b9 84       	ldd	r11, Y+9	; 0x09
    66aa:	c8 84       	ldd	r12, Y+8	; 0x08
    66ac:	df 80       	ldd	r13, Y+7	; 0x07
    66ae:	ee 80       	ldd	r14, Y+6	; 0x06
    66b0:	fd 80       	ldd	r15, Y+5	; 0x05
    66b2:	0c 81       	ldd	r16, Y+4	; 0x04
    66b4:	1b 81       	ldd	r17, Y+3	; 0x03
    66b6:	aa 81       	ldd	r26, Y+2	; 0x02
    66b8:	b9 81       	ldd	r27, Y+1	; 0x01
    66ba:	ce 0f       	add	r28, r30
    66bc:	d1 1d       	adc	r29, r1
    66be:	0f b6       	in	r0, 0x3f	; 63
    66c0:	f8 94       	cli
    66c2:	de bf       	out	0x3e, r29	; 62
    66c4:	0f be       	out	0x3f, r0	; 63
    66c6:	cd bf       	out	0x3d, r28	; 61
    66c8:	ed 01       	movw	r28, r26
    66ca:	08 95       	ret

000066cc <_exit>:
    66cc:	f8 94       	cli

000066ce <__stop_program>:
    66ce:	ff cf       	rjmp	.-2      	; 0x66ce <__stop_program>

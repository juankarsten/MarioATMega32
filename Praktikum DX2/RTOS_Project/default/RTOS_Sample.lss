
RTOS_Sample.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006828  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ae  00800060  00006828  000068bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000698  0080010e  0080010e  0000696a  2**0
                  ALLOC
  3 .stab         00000ed0  00000000  00000000  0000696c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000403  00000000  00000000  0000783c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000178  00000000  00000000  00007c3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000716  00000000  00000000  00007db7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002d74  00000000  00000000  000084cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eca  00000000  00000000  0000b241  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002db2  00000000  00000000  0000c10b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000005e0  00000000  00000000  0000eec0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001268  00000000  00000000  0000f4a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001e18  00000000  00000000  00010708  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000465  00000000  00000000  00012520  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000a0  00000000  00000000  00012985  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 21 	jmp	0x4254	; 0x4254 <__ctors_end>
       4:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       8:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      10:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      14:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      18:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      1c:	0c 94 aa 2f 	jmp	0x5f54	; 0x5f54 <__vector_7>
      20:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      24:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      28:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      2c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      30:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      34:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      38:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      3c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      40:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      44:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      48:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      4c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      50:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>

00000054 <sample_data>:
      54:	85 85 85 83 81 81 83 85 87 8a 8b 89 88 87 85 84     ................
      64:	85 84 84 85 82 82 84 86 8a 8d 91 91 91 90 90 8f     ................
      74:	8d 8c 8b 8b 8c 8b 8a 89 89 89 87 84 82 7f 7a 76     ..............zv
      84:	75 75 77 77 78 7d 82 85 86 88 88 87 84 81 7f 7e     uuwwx}.........~
      94:	7d 7f 7f 81 85 85 87 89 8c 8d 8e 91 90 90 90 8e     }...............
      a4:	8c 8a 88 86 83 83 82 84 86 88 8b 8f 94 94 95 96     ................
      b4:	97 97 98 98 98 99 97 95 91 8d 89 84 81 80 80 80     ................
      c4:	7f 7f 80 80 7f 7f 80 82 83 85 86 8a 8e 91 93 93     ................
      d4:	93 91 90 8f 8e 8f 90 91 93 92 91 91 8e 8b 87 7f     ................
      e4:	77 70 6b 67 68 6a 6f 72 75 7a 7f 84 8a 8d 91 95     wpkghjoruz......
      f4:	97 97 98 99 99 96 90 8a 85 82 80 7e 7e 7d 79 75     ...........~~}yu
     104:	71 6f 6f 6e 6d 6e 73 79 80 87 8d 91 93 94 94 91     qoonmnsy........
     114:	89 81 78 71 6d 6b 6c 70 76 7c 82 88 8b 8c 8f 8f     ..xqmklpv|......
     124:	8d 8a 88 88 8a 89 87 86 85 87 87 87 87 8a 8b 8b     ................
     134:	88 86 85 83 81 80 7e 7e 80 81 84 88 8c 8d 8d 8d     ......~~........
     144:	8c 8a 88 86 85 85 83 82 81 80 7f 80 80 81 81 83     ................
     154:	85 86 88 8a 8a 89 89 88 85 83 82 82 84 86 8a 8d     ................
     164:	90 91 92 93 92 90 8c 88 85 82 7f 7e 7e 7e 7f 81     ...........~~~..
     174:	85 88 8b 8d 8d 8c 8c 8a 88 86 84 83 85 88 8b 8e     ................
     184:	8f 8f 8d 89 84 80 7c 7a 79 78 78 7b 7d 7f 82 83     ......|zyxx{}...
     194:	85 87 87 88 8a 8d 90 93 96 9a 9b 9b 9b 9a 9a 99     ................
     1a4:	98 96 93 91 8e 8c 8a 87 84 82 80 80 80 80 80 81     ................
     1b4:	82 83 85 84 86 88 89 87 86 86 87 86 86 86 88 8a     ................
     1c4:	8c 8d 8e 8f 8f 8d 8a 88 86 85 82 80 7f 7f 81 84     ................
     1d4:	88 8a 8e 91 93 94 95 95 93 90 8d 8c 8b 8b 8c 90     ................
     1e4:	93 96 98 99 9b 9b 96 91 8c 86 83 80 7d 7b 7c 7c     ............}{||
     1f4:	7e 81 84 88 8a 8d 8f 90 92 90 8c 8a 86 81 7c 7a     ~.............|z
     204:	78 77 76 73 73 73 75 79 7c 7f 80 82 83 83 83 81     xwvsssuy|.......
     214:	7d 79 76 74 72 73 75 77 7a 7c 7f 80 82 85 88 8b     }yvtrsuwz|......
     224:	8d 8e 8f 91 92 93 93 93 92 90 8f 8c 8b 8c 8a 8a     ................
     234:	8a 88 86 82 7c 79 76 74 74 73 73 75 79 7e 82 85     ....|yvttssuy~..
     244:	86 88 89 89 87 85 85 84 83 82 7f 7d 7b 77 75 75     ...........}{wuu
     254:	76 75 75 73 74 76 79 7c 7d 7f 81 83 84 86 86 84     vuustvy|}.......
     264:	80 7e 7d 7d 7d 7e 81 86 8b 8c 8d 8e 8e 8c 89 85     .~}}}~..........
     274:	81 7e 7b 79 77 77 78 77 7a 7e 80 84 85 85 86 86     .~{ywwxwz~......
     284:	86 86 86 84 81 80 7f 7d 7b 7b 7a 7a 7c 7d 7f 81     .......}{{zz|}..
     294:	81 80 7f 81 81 81 81 81 83 84 85 85 85 84 82 81     ................
     2a4:	81 7f 7e 7f 7e 7d 80 80 80 7f 7d 7c 7a 79 77 75     ..~.~}....}|zywu
     2b4:	76 75 76 77 79 7c 7f 83 83 82 82 82 83 81 82 83     vuvwy|..........
     2c4:	84 84 84 87 8b 8d 90 92 97 9a 9b 9b 9b 9a 95 8e     ................
     2d4:	86 81 7d 7a 75 72 70 71 71 70 71 74 77 7a 7e 81     ..}zurpqqpqtwz~.
     2e4:	84 85 86 86 85 85 85 85 86 89 8e 91 91 8f 8d 8c     ................
     2f4:	87 7f 77 6e 68 63 5f 5f 61 64 67 6b 6f 74 7b 84     ..wnhc__adgkot{.
     304:	88 87 84 81 81 83 85 85 85 85 85 86 87 88 87 85     ................
     314:	83 7f 7d 78 77 75 73 71 71 72 72 75 77 7b 80 82     ..}xwusqqrruw{..
     324:	84 85 87 87 84 81 7f 7e 80 83 86 8a 8b 8c 8d 8d     .......~........
     334:	8e 90 92 91 8c 87 84 84 82 7c 77 73 71 6f 6f 71     .........|wsqooq
     344:	75 77 74 71 70 72 75 75 77 7b 82 87 89 8c 8f 93     uwtqpruuw{......
     354:	94 91 8f 8c 87 82 7d 77 71 6c 68 64 62 62 62 66     ......}wqlhdbbbf
     364:	6c 72 77 78 7c 7f 7f 80 80 7f 7e 7f 80 81 7f 7d     lrwx|.....~....}
     374:	7b 7b 7a 77 76 77 78 79 7d 82 85 85 85 84 84 83     {{zwvwxy}.......
     384:	80 7c 78 77 77 75 72 6d 6c 6e 71 74 73 76 7c 83     .|xwwurmlnqtsv|.
     394:	8c 92 95 96 94 90 8b 87 82 7d 77 72 70 6f 6e 6e     .........}wrponn
     3a4:	6f 70 71 73 77 7c 7e 7f 80 80 7e 7d 7f 81 81 7d     opqsw|~...~}...}
     3b4:	79 78 78 79 79 7a 79 7b 80 83 84 80 7d 7c 7b 7b     yxxyyzy{....}|{{
     3c4:	7b 7d 7f 81 83 86 88 89 8a 88 88 8a 8c 8f 8f 8e     {}..............
     3d4:	8f 8e 8e 8d 8b 88 85 86 89 8a 8a 8b 8a 86 83 82     ................
     3e4:	82 81 7e 7b 79 78 7a 79 78 78 7b 7d 7e 81 85 8c     ..~{yxzyxx{}~...
     3f4:	8e 8c 8f 8f 8d 84 7d 7b 79 76 73 6f 6d 71 74 74     ......}{yvsomqtt
     404:	74 77 7b 7e 7d 7a 7e 82 82 81 80 83 84 84 84 87     tw{~}z~.........
     414:	8b 8f 90 8e 8b 89 86 82 7d 79 77 75 75 76 77 79     ........}ywuuvwy
     424:	7a 7b 7f 84 88 89 8a 8d 8f 91 94 97 99 98 98 99     z{..............
     434:	9a 98 92 8f 8d 8a 87 86 87 87 8a 88 86 85 86 89     ................
     444:	8a 8e 8f 8d 8b 8a 8b 8d 8e 8f 8f 92 95 96 94 8e     ................
     454:	89 84 7f 7c 7b 7b 7b 7b 79 78 7b 7d 7a 77 76 77     ...|{{{{yx{}zwvw
     464:	7a 7c 7d 80 86 89 89 89 88 87 85 80 7b 79 7b 7f     z|}.........{y{.
     474:	82 83 87 8a 8b 88 83 80 7e 7a 75 76 7b 80 85 8a     ........~zuv{...
     484:	90 95 96 94 90 8d 88 83 80 7e 7d 7f 7f 80 80 80     .........~}.....
     494:	81 80 80 82 83 86 8a 90 95 9b a0 a4 a3 a1 9d 99     ................
     4a4:	95 8e 85 7e 7b 7a 77 75 74 76 78 79 77 75 75 7a     ...~{zwutvxywuuz
     4b4:	80 82 84 8a 92 95 92 90 91 94 92 8e 88 83 80 7b     ...............{
     4c4:	76 73 71 6c 69 6a 6e 74 77 79 7e 87 8e 92 94 92     vsqlijntwy~.....
     4d4:	8f 8a 86 83 81 82 84 86 87 88 88 89 89 84 7d 78     ..............}x
     4e4:	77 79 77 73 6e 6c 6c 6d 70 78 82 8d 93 95 96 98     wywsnllmpx......
     4f4:	98 92 88 7e 7c 7d 7d 7c 7c 81 87 8a 88 85 84 85     ...~|}}||.......
     504:	82 7a 74 76 79 7a 7d 7f 82 88 8b 8d 8e 8f 8c 87     .ztvyz}.........
     514:	83 82 87 8a 87 81 7e 7e 80 81 81 81 83 86 8a 8c     ......~~........
     524:	8b 8a 87 83 7f 7c 76 73 72 76 7a 7a 7b 7e 85 89     .....|vsrvzz{~..
     534:	87 85 83 82 81 83 88 8b 89 86 87 89 8c 8d 8b 87     ................
     544:	87 8a 8c 8a 87 86 87 86 83 7f 7f 81 83 84 83 80     ................
     554:	7b 7b 7f 82 81 79 77 7e 85 84 80 7e 82 89 8d 90     {{...yw~...~....
     564:	90 8f 8d 8b 87 83 7e 78 72 71 70 6f 70 77 7d 7c     ......~xrqpopw}|
     574:	78 79 80 87 88 83 81 82 84 85 8a 8f 93 91 8d 8e     xy..............
     584:	92 92 89 7e 7a 7b 7b 7b 7b 79 77 77 7d 86 89 8d     ...~z{{{{yww}...
     594:	90 94 97 96 92 90 90 8c 86 80 80 86 8c 8e 8b 8b     ................
     5a4:	8e 8f 8e 8f 90 8e 89 86 89 90 92 90 8d 8b 90 8d     ................
     5b4:	85 83 81 88 7f 77 7e 87 91 8a 86 86 8a 8f 91 97     .....w~.........
     5c4:	97 95 91 8c 90 92 8c 7c 6d 6c 70 72 6d 67 65 67     .......|mlprmgeg
     5d4:	6a 6e 76 7b 7c 7d 7f 86 8b 87 80 79 78 79 72 6a     jnv{|}.....yxyrj
     5e4:	67 6a 6c 67 63 61 66 6c 6a 66 68 6d 74 77 77 7b     gjlgcafljfhmtww{
     5f4:	80 84 84 84 83 80 7d 7b 7c 7e 82 83 84 84 86 86     ......}{|~......
     604:	82 7d 7b 80 87 8e 91 93 9a a0 a3 a1 9c 97 93 90     .}{.............
     614:	8c 8a 8b 90 8e 87 82 83 88 83 79 73 77 80 87 8c     ..........ysw...
     624:	91 97 9e a2 a2 a5 a6 9f 93 8a 86 80 78 6d 65 65     ............xmee
     634:	6c 71 70 6d 6f 7a 86 8c 8f 94 99 9b 9c 9f a5 a4     lqpmoz..........
     644:	98 8c 8a 91 94 8e 82 7a 78 79 7b 7d 7e 78 71 71     .......zxy{}~xqq
     654:	7c 88 8d 85 7b 77 7c 81 7f 7b 77 76 77 77 75 78     |...{w|..{wvwwux
     664:	7f 84 85 83 84 8d 96 99 99 95 90 8d 8d 90 90 88     ................
     674:	7f 79 77 76 75 72 6d 6d 71 76 76 77 7f 8a 8e 87     .ywvurmmqvvw....
     684:	81 87 91 96 97 93 8f 8f 94 9c a0 9c 92 88 8a 94     ................
     694:	9c 9a 8f 84 80 82 84 81 7c 78 75 75 77 7a 7c 7b     ........|xuuwz|{
     6a4:	79 78 79 7f 86 88 89 8d 8f 8c 86 84 87 84 7d 75     yxy...........}u
     6b4:	72 75 78 7a 7c 7f 7f 7c 76 78 83 8c 8d 85 7f 82     ruxz|..|vx......
     6c4:	8b 8e 87 7f 7b 79 7b 7a 78 78 75 74 75 78 7d 7f     ....{y{zxxutux}.
     6d4:	7e 7d 7e 7e 7c 7c 7f 84 8a 8b 89 87 89 8b 8a 85     ~}~~||..........
     6e4:	7e 7a 79 7a 82 87 86 87 89 8c 8a 86 88 8e 91 8a     ~zyz............
     6f4:	82 81 83 86 87 85 7f 77 72 77 85 8c 88 84 85 91     .......wrw......
     704:	a0 a5 9d 8d 82 80 83 84 7d 79 7d 86 8a 89 87 88     ........}y}.....
     714:	8b 88 83 7f 80 83 84 88 90 96 98 95 92 93 93 91     ................
     724:	8f 8f 8d 87 83 84 8b 8f 89 80 7c 83 8f 97 93 88     ..........|.....
     734:	82 84 8c 92 8f 85 7a 7c 84 88 87 84 84 83 7f 82     ......z|........
     744:	89 8f 8a 82 7d 81 8a 8d 87 83 87 8d 8d 87 81 83     ....}...........
     754:	86 87 85 82 80 83 89 90 93 8e 85 85 8b 8e 8b 86     ................
     764:	84 86 88 87 87 87 84 80 82 88 8e 92 93 95 98 9a     ................
     774:	98 92 8c 85 7f 7b 7a 7a 79 79 7a 80 86 88 87 87     .....{zzyyz.....
     784:	88 90 98 99 91 88 87 8d 8e 89 87 88 89 88 8a 93     ................
     794:	9a 96 8b 83 85 8f 91 86 7a 7a 84 8a 82 7d 83 8b     ........zz...}..
     7a4:	8e 8c 8e 94 99 99 95 92 91 8c 86 80 80 84 8b 8f     ................
     7b4:	8d 8c 90 98 a0 a1 99 8e 90 97 97 8f 84 82 85 87     ................
     7c4:	85 80 80 83 86 81 74 73 81 8d 8a 7c 76 7f 88 87     ......ts...|v...
     7d4:	7d 76 76 79 7a 7d 81 83 7c 73 71 7a 81 7e 76 74     }vvyz}..|sqz.~vt
     7e4:	7c 80 80 84 8f 97 92 8a 8f 9c a2 9a 90 93 9e a4     |...............
     7f4:	9d 91 91 99 9b 8a 78 77 7e 83 81 7b 78 7a 82 8b     ......xw~..{xz..
     804:	8d 89 8c 95 97 92 8b 8d 91 8e 85 80 85 8c 8f 8c     ................
     814:	89 8d 94 95 92 8e 91 91 89 81 84 88 82 77 73 79     .............wsy
     824:	80 80 7e 81 85 85 85 8c 8d 80 7a 84 91 8c 7c 7b     ..~.......z...|{
     834:	8f a1 9f 91 8b 97 a5 9e 87 75 76 83 83 74 66 63     .........uv..tfc
     844:	6c 74 77 78 7b 7e 7c 7b 7d 88 90 8a 7b 71 73 7c     ltwx{~|{}...{qs|
     854:	7d 76 70 70 76 77 75 75 7a 7e 79 73 71 76 7a 79     }vppvwuuz~ysqvzy
     864:	7c 7e 78 6c 68 76 86 84 73 6c 78 8b 92 8e 8c 8f     |~xlhv..slx.....
     874:	94 93 8b 84 86 87 80 79 73 72 76 7b 81 85 7d 6e     .......ysrv{..}n
     884:	67 6c 79 83 7e 76 77 7d 85 8d 96 9a 8c 74 6a 7a     gly.~vw}.....tjz
     894:	93 97 89 7a 7a 85 92 9b 9a 94 8b 81 7e 7f 84 83     ...zz.......~...
     8a4:	79 6d 61 5b 60 6d 77 74 66 5d 6a 82 8c 85 7f 7f     yma[`mwtf]j.....
     8b4:	7b 78 7c 84 88 81 76 6e 72 7d 87 86 7a 71 6e 70     {x|...vnr}..zqnp
     8c4:	71 73 77 76 6f 6b 6f 74 7c 8b 98 98 8a 7f 88 9d     qswvokot|.......
     8d4:	a7 96 7e 71 70 77 81 8d 8f 83 75 72 82 99 a5 96     ..~qpw....ur....
     8e4:	79 65 6a 81 92 91 7f 6c 66 73 88 92 8e 86 81 7d     yej....lfs.....}
     8f4:	7f 8b a0 ad a1 88 79 82 95 9f 9a 89 76 70 7b 8f     ......y.....vp{.
     904:	9a 96 85 71 6a 7c 95 a0 97 84 78 78 87 9b a0 8f     ...qj|....xx....
     914:	76 6e 77 82 88 8a 8c 8a 88 8c 97 a4 ad aa 99 86     vnw.............
     924:	81 88 94 9b 92 7f 70 73 82 90 94 8a 81 7a 79 85     ......ps.....zy.
     934:	97 9a 81 62 58 6d 88 8d 7d 69 65 74 87 90 90 8c     ...bXm..}iet....
     944:	82 79 7c 8b 92 8a 81 7e 7a 70 6c 77 83 7c 65 55     .y|....~zplw.|eU
     954:	5c 74 84 7c 6b 66 6d 74 79 84 8f 89 75 6d 81 9f     \t.|kfmty...um..
     964:	a8 92 79 6f 7c 91 94 88 7b 73 74 7f 8b 8e 88 7e     ..yo|...{st....~
     974:	79 7c 7f 85 8f 92 84 6f 6f 89 a0 9d 88 7f 8a 95     y|.....oo.......
     984:	98 9b 9f 99 8a 7c 7d 91 a1 99 7d 63 63 7e 97 94     .....|}...}cc~..
     994:	7a 63 63 7b 97 9b 86 71 72 83 8f 93 95 95 91 81     zcc{...qr.......
     9a4:	76 85 9a 9d 87 66 57 60 76 86 81 6f 5c 5d 6d 7c     v....fW`v..o\]m|
     9b4:	84 87 81 6e 63 70 8c 9a 91 7a 6a 6f 87 9e 9c 8a     ...ncp...zjo....
     9c4:	75 6c 6d 7a 8e 91 78 5b 5a 77 8d 85 72 6a 6e 79     ulmz..x[Zw..rjny
     9d4:	81 84 8e 93 8b 79 72 87 9c 98 7f 6a 72 90 a1 96     .....yr....jr...
     9e4:	82 7d 8c 9d 9a 86 79 7c 83 7f 74 6a 70 7d 83 79     .}....y|..tjp}.y
     9f4:	6f 7e 96 9b 88 72 7a 97 a0 90 80 7f 88 8f 91 90     o~...rz.........
     a04:	8a 85 88 8f 90 8c 8b 8d 88 76 70 81 97 96 7c 66     .........vp...|f
     a14:	73 9a ae 9c 7c 71 86 a4 aa 95 7e 7b 89 8f 89 83     s...|q....~{....
     a24:	7f 7a 77 7d 87 85 76 6f 7b 88 87 73 5c 5d 75 8a     .zw}..vo{..s\]u.
     a34:	88 74 64 6d 86 93 88 7a 7d 85 82 78 7b 88 8a 7d     .tdm...z}..x{..}
     a44:	77 83 8f 91 8c 87 88 8d 8d 86 7e 80 88 7f 64 55     w.........~...dU
     a54:	67 82 84 6c 5f 6e 87 99 9a 90 8c 90 95 99 9f a9     g..l_n..........
     a64:	aa 9b 8b 92 a1 a0 8f 7e 7e 83 7e 73 6f 74 7d 83     .......~~.~sot}.
     a74:	7f 78 7a 83 85 83 80 7d 77 71 76 84 87 79 6d 71     .xz....}wqv..ymq
     a84:	84 96 99 8a 7a 7f 94 a0 95 84 81 86 84 7a 76 79     ....z........zvy
     a94:	79 74 72 71 6f 72 7d 85 82 79 7f 8d 8a 7d 7d 86     ytrqor}..y...}}.
     aa4:	89 7e 70 78 8e 98 8c 82 8b 97 94 8b 85 83 82 7e     .~px...........~
     ab4:	7a 75 6f 6c 71 78 79 77 75 73 79 88 92 8c 80 7d     zuolqxywusy....}
     ac4:	83 88 82 78 6b 64 6b 77 7c 76 6f 73 7c 7e 7d 85     ...xkdkw|vos|~}.
     ad4:	8c 83 71 70 80 8e 8a 80 77 73 72 73 77 7a 77 73     ..qp....wsrswzws
     ae4:	6f 6f 7b 8e 9b 98 8d 85 8e a9 bd b2 92 7c 82 9c     oo{..........|..
     af4:	ab 9c 80 6f 74 86 8b 83 7f 80 7d 73 6e 78 82 7c     ...ot.....}snx.|
     b04:	6f 67 69 71 7b 80 80 83 8c 90 8c 8c 98 a2 96 7b     ogiq{..........{
     b14:	74 87 96 8e 7a 6e 74 7f 7b 6b 63 6b 75 6f 60 68     t...znt.{kckuo`h
     b24:	81 8b 7b 69 6b 79 83 89 8e 8c 7f 7b 85 92 96 8a     ..{iky.....{....
     b34:	7d 77 77 7e 83 7f 71 66 6c 7e 8b 85 76 73 80 8d     }ww~..qfl~..vs..
     b44:	8d 83 79 78 81 85 7e 79 83 90 89 78 74 83 98 99     ..yx..~y...xt...
     b54:	8a 84 92 a2 9e 92 91 9b a1 95 85 82 86 87 7e 74     ..............~t
     b64:	71 77 81 85 7e 78 83 91 91 87 86 92 99 93 86 83     qw..~x..........
     b74:	8c 94 8c 78 6d 74 82 87 85 89 8b 86 7f 81 93 a5     ...xmt..........
     b84:	a4 94 8a 92 a1 a6 9a 86 7b 84 93 98 8f 81 80 8c     ........{.......
     b94:	94 8f 82 7c 7c 78 73 73 7a 7e 81 85 85 7f 7b 7f     ...||xssz~....{.
     ba4:	8b 98 96 88 7e 83 8f 95 91 8e 94 92 87 81 89 97     ....~...........
     bb4:	95 84 7e 87 90 90 83 72 71 82 90 8c 7b 6f 73 82     ..~....rq...{os.
     bc4:	93 9b 95 88 7b 77 81 8a 87 7c 6f 6c 77 88 90 8c     ....{w...|olw...
     bd4:	83 7e 87 99 a7 a7 9a 8e 95 a6 af a5 93 8c 8c 8f     .~..............
     be4:	93 95 8b 75 65 6a 7f 8b 82 72 70 80 93 93 89 87     ...uej...rp.....
     bf4:	8f 91 88 85 88 7e 71 6d 77 85 86 78 6d 6d 78 85     .....~qmw..xmmx.
     c04:	87 7d 75 7b 88 92 94 8d 84 83 8a 8a 80 70 6e 82     .}u{.........pn.
     c14:	91 87 72 6f 7f 88 83 80 84 86 7e 72 6e 72 7c 7b     ..ro......~rnr|{
     c24:	73 6b 68 6e 77 7c 80 82 81 7e 81 86 81 79 7a 81     skhnw|...~...yz.
     c34:	83 7b 76 79 7f 7f 7a 7e 89 8c 84 79 77 7d 82 82     .{vy..z~...yw}..
     c44:	7a 74 71 6e 73 7e 88 82 71 6d 77 7c 78 76 79 7e     ztqns~..qmw|xvy~
     c54:	80 82 83 82 8a 95 95 8a 82 87 8f 8b 83 84 8c 8f     ................
     c64:	85 77 73 75 7d 7d 73 6b 70 7a 81 88 8b 87 7f 7c     .wsu}}skpz.....|
     c74:	87 94 8e 7f 7d 8e 9e 98 85 77 73 79 7f 81 7d 74     ....}....wsy..}t
     c84:	72 7a 8b 9a 9c 93 88 85 87 89 88 86 7d 69 63 79     rz..........}icy
     c94:	91 89 6c 63 77 87 86 7a 73 79 81 85 87 88 8d 92     ..lcw..zsy......
     ca4:	8b 7f 7f 88 8d 87 77 77 87 8f 8f 84 81 87 8b 8a     ......ww........
     cb4:	81 74 70 83 9d a2 91 84 91 a5 a8 9a 8d 87 7f 71     .tp............q
     cc4:	6e 7c 89 87 75 6b 80 a3 af 99 86 8f a7 ae 9a 83     n|..uk..........
     cd4:	81 91 9c 94 7e 6e 70 80 90 8c 7a 6d 6e 7e 8c 8a     ....~np...zmn~..
     ce4:	7f 77 7c 88 93 95 90 8a 86 89 94 96 8a 7f 7a 80     .w|...........z.
     cf4:	90 9a 92 7d 69 6f 87 93 88 70 69 7c 92 8d 76 6c     ...}io...pi|..vl
     d04:	7c 92 8e 78 72 83 96 97 88 7b 80 8c 91 86 7d 7f     |..xr....{....}.
     d14:	80 80 7f 7d 7b 78 71 6c 69 6e 7b 7f 73 6d 7a 8d     ...}{xqlin{.smz.
     d24:	92 8a 7f 80 8c 93 8f 84 7e 8c 98 8b 6e 63 75 95     ........~...ncu.
     d34:	9b 7f 6a 6e 82 8f 83 72 71 7d 86 7c 76 85 97 93     ..jn...rq}.|v...
     d44:	7e 72 79 85 84 74 6b 6e 76 79 7a 80 85 8a 89 80     ~ry..tknvyz.....
     d54:	79 7b 88 89 7c 6f 73 85 95 98 92 8f 8f 95 a2 a6     y{..|os.........
     d64:	9b 8d 8d 93 8e 85 8a 91 89 74 69 73 83 88 80 74     .........tis...t
     d74:	72 79 88 8e 89 86 88 88 8b 95 98 87 7b 85 96 97     ry..........{...
     d84:	83 74 73 79 81 85 7a 64 58 69 88 8e 75 56 53 6f     .tsy..zdXi..uVSo
     d94:	85 81 71 6e 76 7f 88 93 96 8a 7a 76 84 98 9f 92     ..qnv.....zv....
     da4:	80 80 93 9f 91 7d 7d 8b 8f 7b 65 6c 83 8a 7c 6d     .....}}..{el..|m
     db4:	6f 76 78 7e 8f 99 8c 77 79 97 b2 b0 9c 8a 8e a3     ovx~...wy.......
     dc4:	ab a0 96 92 93 8e 82 82 91 9b 92 81 76 73 77 7d     ............vsw}
     dd4:	7c 75 6d 67 6b 75 80 89 8e 8a 87 98 ad b1 a1 8f     |umgku..........
     de4:	8b 8d 87 7c 79 7e 81 75 5c 4e 5f 7f 83 63 49 5e     ...|y~.u\N_..cI^
     df4:	84 8b 7e 80 94 9c 88 76 8b ab a8 82 64 66 80 90     ..~....v....df..
     e04:	86 7c 80 89 86 7f 80 8e 93 83 6a 5d 64 77 83 77     .|........j]dw.w
     e14:	5c 50 61 7a 85 82 7a 71 6a 6e 83 98 98 86 77 78     \Paz..zqjn....wx
     e24:	8c 9a 97 91 92 95 8c 78 70 80 98 94 77 56 52 80     .......xp...wVR.
     e34:	b5 be 8b 4e 4b 7f a3 96 74 5f 65 6c 75 8d ad ac     ...NK...t_elu...
     e44:	81 58 64 a2 cc b2 72 50 69 94 a0 8c 74 71 7e 86     .Xd...rPi...tq~.
     e54:	8d 9d a1 8f 77 78 90 9f 8d 77 71 75 79 79 85 8a     ....wx...wquyy..
     e64:	7f 73 81 a0 a6 96 84 86 95 9d 96 86 75 6c 7e 8f     .s..........ul~.
     e74:	88 70 5f 61 72 7f 7b 78 78 7b 7d 85 91 9e 9d 87     .p_ar.{xx{}.....
     e84:	73 7a 9e b5 a9 85 71 7b 92 a1 93 75 63 76 99 a9     sz....q{...ucv..
     e94:	90 72 73 8a 94 88 7e 86 93 8a 77 73 8c a1 95 75     .rs...~...ws...u
     ea4:	68 85 a7 ae 93 7b 87 aa b4 9e 8a 8f a3 a3 92 89     h....{..........
     eb4:	90 92 89 7b 7a 86 8e 8d 7d 73 72 7c 84 8a 8a 85     ...{z...}sr|....
     ec4:	82 82 88 8c 8b 94 9d 9a 93 93 9d a6 9d 82 6c 72     ..............lr
     ed4:	7d 7c 72 6a 72 80 7e 7c 88 9f ad a3 8d 87 95 a1     }|rjr.~|........
     ee4:	9d 8d 85 89 88 87 8f 9f 9f 8b 75 75 8c a3 9d 79     ..........uu...y
     ef4:	5c 5b 77 91 90 77 67 71 85 95 9b 9c 92 7f 70 71     \[w..wgq......pq
     f04:	88 a0 9d 7c 66 73 93 a3 98 8e 8d 89 82 84 8f 8e     ...|fs..........
     f14:	7c 6b 65 65 6d 7e 83 6e 53 55 71 85 82 74 68 64     |keem~.nSUq..thd
     f24:	68 6f 75 7a 7a 7a 7c 7e 8d a4 ac 96 76 73 88 90     houzzz|~....vs..
     f34:	81 6e 6c 70 70 73 7c 7f 76 70 7c 8c 8a 82 88 95     .nlpps|.vp|.....
     f44:	96 88 7c 89 9c a0 97 8e 93 a2 a4 96 8e 8f 92 8d     ..|.............
     f54:	85 84 87 81 70 68 70 76 75 72 6f 70 6f 72 86 95     ....phpvuropor..
     f64:	8e 84 88 9b a9 a1 91 8f 9d a4 9f 95 91 90 8e 8f     ................
     f74:	96 95 86 75 70 77 7a 73 70 75 7f 86 82 7c 7e 85     ...upwzspu...|~.
     f84:	8a 84 7e 88 95 95 88 81 8b 97 96 88 82 87 86 82     ..~.............
     f94:	84 8c 92 8e 84 7c 7a 82 8b 8c 7a 6a 6f 85 9f a4     .....|z...zjo...
     fa4:	8e 7e 86 9c a5 95 83 80 81 82 87 94 9a 94 88 81     .~..............
     fb4:	8b 97 9c 97 86 7a 80 88 85 77 66 63 6d 78 7c 7c     .....z...wfcmx||
     fc4:	7e 81 86 8a 89 8b 89 88 8d 92 9a a3 9f 91 84 84     ~...............
     fd4:	97 a3 96 7f 74 7b 88 86 75 68 68 75 82 7e 78 7a     ....t{..uhhu.~xz
     fe4:	84 8d 8c 88 83 85 8f 97 90 8a 90 95 93 8a 80 82     ................
     ff4:	85 82 84 8a 82 70 69 72 7d 7a 6a 5c 58 63 75 7f     .....pir}zj\Xcu.
    1004:	7e 76 70 71 72 77 81 83 75 69 71 81 88 7c 70 75     ~vpqrw..uiq..|pu
    1014:	80 83 80 85 89 81 74 71 75 7b 75 6c 6f 75 82 8f     ......tqu{ulou..
    1024:	95 92 8e 8e 8c 8d 8e 8e 8c 84 84 84 7c 7c 87 97     ............||..
    1034:	9b 8f 8b 99 a5 9f 8d 86 93 9a 8b 7a 74 85 98 92     ...........zt...
    1044:	80 7a 88 9c a0 95 8e 91 93 8c 85 86 88 7c 6e 71     .z...........|nq
    1054:	7e 88 87 7c 77 77 7b 87 8b 82 76 78 86 8c 86 79     ~..|ww{...vx...y
    1064:	74 7b 80 81 7a 76 7c 84 84 7a 71 75 80 86 87 7c     t{..zv|..zqu...|
    1074:	75 79 7f 85 81 7f 84 89 89 84 80 83 88 8c 84 7d     uy.............}
    1084:	81 8d 91 8a 88 8e 99 92 82 7e 88 8d 83 71 6b 79     .........~...qky
    1094:	86 83 7a 74 7c 8a 92 90 8b 90 9c a3 9d 93 90 8f     ..zt|...........
    10a4:	90 8e 83 82 88 8b 8b 8b 8c 8b 88 84 86 8c 88 7e     ...............~
    10b4:	78 7d 8a 95 90 88 8e 97 99 95 90 91 94 94 94 93     x}..............
    10c4:	8f 89 86 85 81 76 69 63 6b 78 7b 79 7a 85 90 94     .....vickx{yz...
    10d4:	91 8a 86 81 83 86 88 87 82 81 8a 8e 85 7c 78 7d     .............|x}
    10e4:	8a 96 98 93 92 9a a2 a0 97 88 7e 7a 74 6c 65 62     ..........~ztleb
    10f4:	62 62 5f 61 69 6f 6e 6d 6b 6d 6d 65 5d 5d 63 64     bb_aionmkmme]]cd
    1104:	5d 5a 60 68 64 59 53 59 64 6a 6a 68 69 71 79 7d     ]Z`hdYSYdjjhiqy}
    1114:	80 83 86 86 88 8a 8d 8f 8d 8d 8e 8e 8e 8d 8b 87     ................
    1124:	82 7c 79 77 74 72 77 7e 86 88 85 88 93 9a 9a 94     .|ywtrw~........
    1134:	8f 8f 8e 87 7e 79 79 7c 7b 76 72 72 72 6e 6a 6a     ....~yy|{vrrrnjj
    1144:	6b 67 61 60 66 6d 70 71 73 77 7f 85 8d 8e 86 80     kga`fmpqsw......
    1154:	7f 7e 7a 73 6a 67 69 6f 73 72 71 75 7b 7d 7c 7d     .~zsjgiosrqu{}|}
    1164:	81 80 7a 74 76 7d 80 7e 7b 7a 7e 84 88 8a 8d 92     ..ztv}.~{z~.....
    1174:	99 9d 9e 9f a1 a1 9c 9a 9b 9a 97 91 8c 89 85 80     ................
    1184:	7c 79 74 70 70 70 6d 6e 72 78 7d 80 84 8c 97 9b     |ytpppmnrx}.....
    1194:	9a 99 98 98 98 95 93 8f 8a 8a 8d 90 92 90 8a 85     ................
    11a4:	84 85 80 78 71 70 70 70 77 79 78 78 7e 85 87 85     ...xqpppwyxx~...
    11b4:	82 83 83 84 83 81 85 86 87 8a 8c 90 91 92 93 95     ................
    11c4:	93 8e 8d 91 96 91 84 7a 79 7f 7e 78 75 74 75 77     .......zy.~xutuw
    11d4:	7a 7e 81 83 84 83 85 86 85 82 81 82 82 7f 7d 7d     z~............}}
    11e4:	7e 7c 76 73 72 71 6d 68 64 5e 5b 5e 63 67 69 6c     ~|vsrqmhd^[^cgil
    11f4:	70 76 7e 84 86 88 8a 8b 8d 8c 8c 87 82 7d 76 70     pv~..........}vp
    1204:	6c 6a 68 65 62 5e 5d 61 65 69 6c 6e 6d 6d 6e 70     ljheb^]aeilnmmnp
    1214:	72 70 6e 70 74 7c 83 85 88 8b 8f 90 90 90 90 8f     rpnpt|..........
    1224:	8c 88 86 82 7d 7a 78 76 74 72 73 74 75 76 76 76     ....}zxvtrstuvvv
    1234:	77 79 79 7a 7c 7f 7f 7f 7c 79 79 7b 7d 7f 81 84     wyyz|...|yy{}...
    1244:	87 88 8a 8b 8a 86 7c 75 72 70 6f 6e 6b 6c 6d 6e     ......|urponklmn
    1254:	71 73 73 76 79 7b 7d 7f 7f 7f 7f 7e 7d 7e 81 82     qssvy{}....~}~..
    1264:	85 88 8a 89 87 83 82 80 7f 7c 77 74 73 74 71 6e     .........|wtstqn
    1274:	6c 6d 6e 71 76 7b 80 85 8a 8d 8d 8d 8c 89 86 81     lmnqv{..........
    1284:	7e 7b 79 78 7a 7e 81 82 82 81 7f 7c 77 75 74 73     ~{yxz~.....|wuts
    1294:	72 75 78 7e 82 86 8e 96 9d a1 a3 a3 a2 a0 9c 97     rux~............
    12a4:	94 91 8d 87 84 85 87 8a 8a 8b 8c 8c 8b 8c 8e 90     ................
    12b4:	93 93 91 91 91 8f 8f 92 93 95 97 9d a2 a3 a3 a4     ................
    12c4:	a3 9f 98 91 8a 83 7d 7a 77 74 75 7a 7f 83 83 84     ......}zwtuz....
    12d4:	85 85 84 85 89 8e 95 9a 9f a3 a2 a0 99 8f 88 82     ................
    12e4:	7c 76 73 74 79 7f 83 88 8d 8f 90 90 8e 8d 89 83     |vsty...........
    12f4:	7e 78 76 73 6f 6f 71 74 76 79 7d 7e 7f 7f 7d 7b     ~xvsooqtvy}~..}{
    1304:	76 72 71 70 6f 6e 72 77 7b 7d 79 78 78 76 73 6f     vrqponrw{}yxxvso
    1314:	6c 6c 6c 6a 66 62 61 5f 5e 61 67 6d 72 77 7c 82     llljfba_^agmrw|.
    1324:	83 81 7f 7c 7a 79 79 77 74 74 73 72 71 6d 6b 69     ...|zyywttsrqmki
    1334:	67 66 65 66 68 65 64 65 68 69 68 69 6b 6d 6d 6d     gfefhedehihikmmm
    1344:	70 73 74 72 70 70 70 6c 69 6b 6e 6f 6b 68 69 6b     pstrpppliknokhik
    1354:	6b 68 66 63 65 65 61 60 63 66 6a 6c 6e 76 81 87     khfceea`cfjlnv..
    1364:	89 88 88 8b 8b 8a 8a 8c 90 94 98 9c a3 a8 aa ac     ................
    1374:	ac ad ae ae ae b3 b8 be c3 c6 c9 cd d0 cf cc c8     ................
    1384:	c4 c2 c3 c2 c2 c2 c4 c7 c8 cb ce d3 d3 d3 d5 d4     ................
    1394:	d3 cf cb ca c9 c7 c5 c5 c4 c3 c0 bc b9 b5 b2 af     ................
    13a4:	aa a8 a6 a4 a3 a3 a7 aa ac af b4 b9 bb b9 b6 b4     ................
    13b4:	b1 ab a7 a3 9f 9a 96 90 8d 8b 8a 87 86 86 85 84     ................
    13c4:	83 83 86 89 89 8a 8d 8f 8f 8d 8b 8a 87 82 7c 76     ..............|v
    13d4:	71 6b 63 5e 59 53 4e 4d 4b 4a 45 41 41 3e 3a 34     qkc^YSNMKJEAA>:4
    13e4:	30 30 2f 2b 27 25 23 1f 18 15 13 11 10 0e 0d 0f     00/+'%#.........
    13f4:	13 14 0f 09 03 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1410:	00 00 00 01 01 01 02 00 18 51 8e d3 fc fe fe fe     .........Q......
    1420:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1430:	ff ff fe ff f7 d6 bc a5 94 86 79 6d 66 63 63 64     ..........ymfccd
    1440:	64 63 64 64 5f 54 46 35 21 0a 00 00 00 00 00 00     dcdd_TF5!.......
	...
    1458:	00 01 00 02 00 0a 35 5f 88 b0 d7 f8 ff fe ff ff     ......5_........
    1468:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1478:	ff ff ff ff ff ff ff ff ff ff ff fe ff f6 e1 d0     ................
    1488:	bf ab 94 7b 61 48 30 17 04 00 01 00 01 00 00 00     ...{aH0.........
    1498:	01 11 27 3d 55 6d 89 a4 c1 dc f4 ff fe ff ff ff     ..'=Um..........
    14a8:	ff ff ff ff ff ff ff ff ff ff ff ff f3 e8 e5 e5     ................
    14b8:	e5 e7 ea ee f1 f1 f0 f0 ee ed ea e7 e4 de d4 c8     ................
    14c8:	bd b1 a3 94 84 74 67 5d 56 51 4d 4c 4a 46 46 47     .....tg]VQMLJFFG
    14d8:	49 4b 4f 54 5c 65 6d 75 7e 87 8d 90 91 91 92 92     IKOT\emu~.......
    14e8:	91 8d 89 87 81 77 6b 5b 4b 39 27 16 05 00 00 00     .....wk[K9'.....
	...
    1518:	00 01 01 02 00 03 00 12 66 c6 fe fe fe fe fe fe     ........f.......
    1528:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff fd ff     ................
    1538:	f1 b5 81 57 38 21 12 09 06 08 10 1c 29 34 40 4d     ...W8!......)4@M
    1548:	55 59 57 4f 41 2e 15 02 00 00 00 00 00 00 00 00     UYWOA...........
    1558:	00 00 00 00 00 00 01 01 02 00 06 37 71 a4 dc fe     ...........7q...
    1568:	fe fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1578:	ff ff ff ff fe ef e2 d7 ce c6 bf bb ba bb ba b9     ................
    1588:	b6 b3 ad a2 98 89 73 57 38 17 02 00 00 00 00 00     ......sW8.......
    1598:	00 00 00 00 00 00 00 01 01 01 1d 46 6d 97 bc e3     ...........Fm...
    15a8:	fd fe fe ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15c8:	fe ff f8 e5 d0 b8 a2 8d 77 5f 47 31 23 17 0c 05     ........w_G1#...
    15d8:	01 00 02 0c 17 22 33 47 5c 71 87 98 ab ba c5 cd     ....."3G\q......
    15e8:	ce cd ca c6 c1 bb b6 b2 af ae ab ab aa a9 a9 aa     ................
    15f8:	ad ae ae b0 b3 b6 b7 b7 b5 b0 a9 a0 93 85 74 60     ..............t`
    1608:	4a 33 1c 07 00 00 00 00 00 00 00 00 00 00 00 00     J3..............
	...
    1630:	00 01 01 01 00 03 00 33 ae fa ff fe fe fe fe ff     .......3........
    1640:	ff ff ff ff ff ff ff ff ff ff fe fe fe fe fc c2     ................
    1650:	78 3c 0a 00 02 01 02 01 00 01 00 08 25 3a 4c 58     x<..........%:LX
    1660:	5c 56 45 2b 0c 00 00 00 00 00 00 00 00 00 00 00     \VE+............
    1670:	00 00 00 00 02 01 02 00 06 48 9a e7 ff fc ff fd     .........H......
    1680:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1690:	ff ff ff ff ff ff ff ff fc fa f9 f7 f1 e8 da c8     ................
    16a0:	b2 95 74 50 25 03 00 01 00 00 00 00 00 00 00 00     ..tP%...........
    16b0:	00 00 00 01 01 01 01 01 29 5e 8e bf ef ff fd fe     ........)^......
    16c0:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16e0:	ff fe ff f8 e1 ce ba a4 8e 79 65 53 43 36 2d 29     .........yeSC6-)
    16f0:	27 25 26 29 2e 36 3e 48 55 67 7c 93 aa c1 d5 e8     '%&).6>HUg|.....
    1700:	f7 fe ff ff ff ff fb f0 e8 de d4 cc c3 ba b2 ad     ................
    1710:	a9 a4 a0 9d 98 94 93 90 8d 8a 88 85 81 7d 77 72     .............}wr
    1720:	6b 63 59 4e 41 32 24 17 08 00 00 00 00 00 00 00     kcYNA2$.........
	...
    1750:	00 01 01 02 00 02 00 0e 8b f6 fe fe fe fe fe fe     ................
    1760:	ff ff ff ff ff ff ff ff ff ff ff fe fe fe fe ff     ................
    1770:	d3 93 64 3e 25 15 0d 08 0d 1d 31 46 57 62 67 66     ..d>%.....1FWbgf
    1780:	57 3f 19 00 00 00 00 00 00 00 00 00 00 00 00 00     W?..............
    1790:	00 00 00 01 00 02 00 08 49 8d ce fc fe fe fe fe     ........I.......
    17a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17b0:	ff ff ff ff ff ff ff ff ff fe ff f7 d6 b5 92 6a     ...............j
    17c0:	44 19 00 01 00 01 00 00 00 00 00 00 00 00 00 00     D...............
    17d0:	00 00 00 00 00 01 00 07 24 3f 5f 81 a0 c0 df fa     ........$?_.....
    17e0:	ff fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17f0:	ff ff ff ff ff ff ff ff fe ff f7 db c7 b5 a8 9e     ................
    1800:	97 95 95 97 9c a2 a5 a6 a6 a5 a6 a2 9b 97 94 91     ................
    1810:	8d 87 7e 77 6f 66 60 5c 5a 5b 5d 62 6c 77 82 8d     ..~wof`\Z[]blw..
    1820:	98 a3 ae b8 c2 cd d6 dc e0 e3 e3 e3 e2 df dd d9     ................
    1830:	d4 d0 cc ca c7 c4 c0 be bb b6 b2 ae aa a6 a3 a0     ................
    1840:	9f 9c 97 91 8a 81 75 67 58 47 36 22 0f 01 00 00     ......ugXG6"....
	...
    1874:	01 01 02 00 04 00 31 c7 ff fc ff fd fe fe ff ff     ......1.........
    1884:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1894:	fe e5 d2 c8 c1 bb b7 b7 b7 b7 b0 a2 89 67 3c 0d     .............g<.
    18a4:	00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18b4:	00 00 01 01 02 00 21 5c 8d bc e9 ff fd fe fe ff     ......!\........
    18c4:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    18d4:	ff ff ff ff ff ff fe ff fe fe fc d8 ac 81 53 26     ..............S&
    18e4:	04 01 01 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
    18f4:	00 00 00 00 00 00 01 00 02 00 0a 2e 52 79 a0 c5     ............Ry..
    1904:	ea fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1914:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1924:	ff ff ff ff fe ff f4 db c7 b1 99 81 6d 5b 4b 40     ............m[K@
    1934:	39 35 36 37 38 3e 46 4f 57 60 6a 76 80 86 89 8c     95678>FOW`jv....
    1944:	8d 8c 8a 84 7d 77 72 6e 6b 6c 70 79 84 8d 99 a7     ....}wrnklpy....
    1954:	b5 c3 cf dc e7 ed f1 f3 f2 f0 ea e0 d3 c3 b2 a0     ................
    1964:	8f 7d 6c 61 59 55 53 54 55 57 58 55 51 4b 43 3d     .}laYUSTUWXUQKC=
    1974:	36 2b 20 11 04 00 00 00 00 00 00 00 00 00 00 00     6+ .............
	...
    1998:	00 01 01 01 01 01 01 07 87 fb fd ff fe fe fe fe     ................
    19a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    19b8:	ff ff ff ff ff ff ff ff fe fe fd ff f9 ca 91 52     ...............R
    19c8:	10 00 02 01 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    19e0:	01 00 0b 2f 4c 65 79 89 99 aa bf d9 f7 ff fe ff     .../Ley.........
    19f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a00:	ff ff ff ff ff fe ff f4 dd c8 b0 96 7b 61 46 2c     ............{aF,
    1a10:	0f 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1a20:	00 00 01 00 01 00 08 33 57 72 86 94 9f a7 ab ad     .......3Wr......
    1a30:	b1 b7 be c8 d3 e0 f0 fe ff ff ff ff ff ff ff ff     ................
    1a40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a50:	ff ff ff ff ff ff ff fc ed e0 d4 c7 ba aa 9b 89     ................
    1a60:	77 68 59 4c 42 39 31 2a 25 21 1d 1d 1d 1d 1d 1d     whYLB91*%!......
    1a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4250:	1d 1d 1d 1d                                         ....

00004254 <__ctors_end>:
    4254:	11 24       	eor	r1, r1
    4256:	1f be       	out	0x3f, r1	; 63
    4258:	cf e5       	ldi	r28, 0x5F	; 95
    425a:	d8 e0       	ldi	r29, 0x08	; 8
    425c:	de bf       	out	0x3e, r29	; 62
    425e:	cd bf       	out	0x3d, r28	; 61

00004260 <__do_copy_data>:
    4260:	11 e0       	ldi	r17, 0x01	; 1
    4262:	a0 e6       	ldi	r26, 0x60	; 96
    4264:	b0 e0       	ldi	r27, 0x00	; 0
    4266:	e8 e2       	ldi	r30, 0x28	; 40
    4268:	f8 e6       	ldi	r31, 0x68	; 104
    426a:	02 c0       	rjmp	.+4      	; 0x4270 <__do_copy_data+0x10>
    426c:	05 90       	lpm	r0, Z+
    426e:	0d 92       	st	X+, r0
    4270:	ae 30       	cpi	r26, 0x0E	; 14
    4272:	b1 07       	cpc	r27, r17
    4274:	d9 f7       	brne	.-10     	; 0x426c <__do_copy_data+0xc>

00004276 <__do_clear_bss>:
    4276:	17 e0       	ldi	r17, 0x07	; 7
    4278:	ae e0       	ldi	r26, 0x0E	; 14
    427a:	b1 e0       	ldi	r27, 0x01	; 1
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <.do_clear_bss_start>

0000427e <.do_clear_bss_loop>:
    427e:	1d 92       	st	X+, r1

00004280 <.do_clear_bss_start>:
    4280:	a6 3a       	cpi	r26, 0xA6	; 166
    4282:	b1 07       	cpc	r27, r17
    4284:	e1 f7       	brne	.-8      	; 0x427e <.do_clear_bss_loop>
    4286:	0e 94 4b 24 	call	0x4896	; 0x4896 <main>
    428a:	0c 94 12 34 	jmp	0x6824	; 0x6824 <_exit>

0000428e <__bad_interrupt>:
    428e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00004292 <vPutarServoTask>:
		vTaskDelay(20 * TICKS_PER_MS);
	}	
	
}

void vPutarServoTask(void* pvParameters) {
    4292:	0f 93       	push	r16
    4294:	1f 93       	push	r17
    4296:	cf 93       	push	r28
    4298:	df 93       	push	r29
	int i, j, k;
	DDRC = 0b11110011;
    429a:	83 ef       	ldi	r24, 0xF3	; 243
    429c:	84 bb       	out	0x14, r24	; 20
	//TCCR2 = 0x07;
	//ASSR = 0x00;
	while (1) {
		if (current_state == LOADING) {
    429e:	80 91 c3 00 	lds	r24, 0x00C3
    42a2:	90 91 c4 00 	lds	r25, 0x00C4
    42a6:	81 30       	cpi	r24, 0x01	; 1
    42a8:	91 05       	cpc	r25, r1
    42aa:	81 f5       	brne	.+96     	; 0x430c <vPutarServoTask+0x7a>
    42ac:	c8 e2       	ldi	r28, 0x28	; 40
    42ae:	d0 e0       	ldi	r29, 0x00	; 0
			i = 1;
			for (k = 0; k < 40; k++) {
				PORTC |= 0b00010000;
    42b0:	ac 9a       	sbi	0x15, 4	; 21
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    42b2:	81 e0       	ldi	r24, 0x01	; 1
    42b4:	90 e0       	ldi	r25, 0x00	; 0
    42b6:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    42ba:	81 e0       	ldi	r24, 0x01	; 1
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
				}
				PORTC &= 0b11101111;
    42c2:	ac 98       	cbi	0x15, 4	; 21
		
				vTaskDelay(10 * TICKS_PER_MS);
    42c4:	82 e3       	ldi	r24, 0x32	; 50
    42c6:	90 e0       	ldi	r25, 0x00	; 0
    42c8:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    42cc:	21 97       	sbiw	r28, 0x01	; 1
	//TCCR2 = 0x07;
	//ASSR = 0x00;
	while (1) {
		if (current_state == LOADING) {
			i = 1;
			for (k = 0; k < 40; k++) {
    42ce:	81 f7       	brne	.-32     	; 0x42b0 <vPutarServoTask+0x1e>
				}
				PORTC &= 0b11101111;
		
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    42d0:	81 e0       	ldi	r24, 0x01	; 1
    42d2:	90 e0       	ldi	r25, 0x00	; 0
    42d4:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		
			i = 45;
			for (k = 0; k < 40; k++) {
    42d8:	c0 e0       	ldi	r28, 0x00	; 0
    42da:	d0 e0       	ldi	r29, 0x00	; 0
				PORTC |= 0b00010000;
    42dc:	ac 9a       	sbi	0x15, 4	; 21
				PORTC &= 0b11101111;
    42de:	ac 98       	cbi	0x15, 4	; 21
    42e0:	0e e2       	ldi	r16, 0x2E	; 46
    42e2:	10 e0       	ldi	r17, 0x00	; 0
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    42e4:	81 e0       	ldi	r24, 0x01	; 1
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    42ec:	01 50       	subi	r16, 0x01	; 1
    42ee:	10 40       	sbci	r17, 0x00	; 0
		
			i = 45;
			for (k = 0; k < 40; k++) {
				PORTC |= 0b00010000;
				PORTC &= 0b11101111;
				for (j = 0; j <= i; j++) {
    42f0:	c9 f7       	brne	.-14     	; 0x42e4 <vPutarServoTask+0x52>
					vTaskDelay(1);
				}
				PORTC &= 0b11101111;
    42f2:	ac 98       	cbi	0x15, 4	; 21
			
				vTaskDelay(10 * TICKS_PER_MS);
    42f4:	82 e3       	ldi	r24, 0x32	; 50
    42f6:	90 e0       	ldi	r25, 0x00	; 0
    42f8:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
    42fc:	21 96       	adiw	r28, 0x01	; 1
    42fe:	c8 32       	cpi	r28, 0x28	; 40
    4300:	d1 05       	cpc	r29, r1
    4302:	61 f7       	brne	.-40     	; 0x42dc <vPutarServoTask+0x4a>
				}
				PORTC &= 0b11101111;
			
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    4304:	81 e0       	ldi	r24, 0x01	; 1
    4306:	90 e0       	ldi	r25, 0x00	; 0
    4308:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		}
		vTaskDelay(1);		
    430c:	81 e0       	ldi	r24, 0x01	; 1
    430e:	90 e0       	ldi	r25, 0x00	; 0
    4310:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	}	
    4314:	c4 cf       	rjmp	.-120    	; 0x429e <vPutarServoTask+0xc>

00004316 <vLEDTask>:
	}
}



void vLEDTask ( void * pvParameters ) {
    4316:	ef 92       	push	r14
    4318:	ff 92       	push	r15
    431a:	0f 93       	push	r16
    431c:	1f 93       	push	r17
    431e:	cf 93       	push	r28
    4320:	df 93       	push	r29
	int current = 0;
	// Set PORTB as LED output //
	DDRD = 0xFF;
    4322:	8f ef       	ldi	r24, 0xFF	; 255
    4324:	81 bb       	out	0x11, r24	; 17
	PORTD = current;
    4326:	12 ba       	out	0x12, r1	; 18
	led_current_state = LED_START;
    4328:	81 e0       	ldi	r24, 0x01	; 1
    432a:	90 e0       	ldi	r25, 0x00	; 0
    432c:	90 93 11 01 	sts	0x0111, r25
    4330:	80 93 10 01 	sts	0x0110, r24
}



void vLEDTask ( void * pvParameters ) {
	int current = 0;
    4334:	c0 e0       	ldi	r28, 0x00	; 0
    4336:	d0 e0       	ldi	r29, 0x00	; 0
			}else{
				current = current >> 1;
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
			if (current == 0b11100000){
				led_current_state = LED_MOVE_LEFT;
    4338:	02 e0       	ldi	r16, 0x02	; 2
    433a:	10 e0       	ldi	r17, 0x00	; 0
		}else if(led_current_state == LED_START){
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
			if (current == 0b00000111){
				led_current_state = LED_MOVE_RIGHT;
    433c:	23 e0       	ldi	r18, 0x03	; 3
    433e:	e2 2e       	mov	r14, r18
    4340:	f1 2c       	mov	r15, r1
	// Set PORTB as LED output //
	DDRD = 0xFF;
	PORTD = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
    4342:	80 91 10 01 	lds	r24, 0x0110
    4346:	90 91 11 01 	lds	r25, 0x0111
    434a:	84 30       	cpi	r24, 0x04	; 4
    434c:	91 05       	cpc	r25, r1
    434e:	31 f1       	breq	.+76     	; 0x439c <vLEDTask+0x86>
			current = 0;	
		}else if(led_current_state == LED_START){
    4350:	81 30       	cpi	r24, 0x01	; 1
    4352:	91 05       	cpc	r25, r1
    4354:	39 f4       	brne	.+14     	; 0x4364 <vLEDTask+0x4e>
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
    4356:	10 93 11 01 	sts	0x0111, r17
    435a:	00 93 10 01 	sts	0x0110, r16
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
		}else if(led_current_state == LED_START){
			current = 0b11100000;
    435e:	c0 ee       	ldi	r28, 0xE0	; 224
    4360:	d0 e0       	ldi	r29, 0x00	; 0
    4362:	1e c0       	rjmp	.+60     	; 0x43a0 <vLEDTask+0x8a>
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
    4364:	82 30       	cpi	r24, 0x02	; 2
    4366:	91 05       	cpc	r25, r1
    4368:	59 f4       	brne	.+22     	; 0x4380 <vLEDTask+0x6a>
			if (current == 0b00000111){
    436a:	c7 30       	cpi	r28, 0x07	; 7
    436c:	d1 05       	cpc	r29, r1
    436e:	29 f4       	brne	.+10     	; 0x437a <vLEDTask+0x64>
				led_current_state = LED_MOVE_RIGHT;
    4370:	f0 92 11 01 	sts	0x0111, r15
    4374:	e0 92 10 01 	sts	0x0110, r14
    4378:	13 c0       	rjmp	.+38     	; 0x43a0 <vLEDTask+0x8a>
			}else{
				current = current >> 1;
    437a:	d5 95       	asr	r29
    437c:	c7 95       	ror	r28
    437e:	10 c0       	rjmp	.+32     	; 0x43a0 <vLEDTask+0x8a>
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
    4380:	83 30       	cpi	r24, 0x03	; 3
    4382:	91 05       	cpc	r25, r1
    4384:	69 f4       	brne	.+26     	; 0x43a0 <vLEDTask+0x8a>
			if (current == 0b11100000){
    4386:	c0 3e       	cpi	r28, 0xE0	; 224
    4388:	d1 05       	cpc	r29, r1
    438a:	29 f4       	brne	.+10     	; 0x4396 <vLEDTask+0x80>
				led_current_state = LED_MOVE_LEFT;
    438c:	10 93 11 01 	sts	0x0111, r17
    4390:	00 93 10 01 	sts	0x0110, r16
    4394:	05 c0       	rjmp	.+10     	; 0x43a0 <vLEDTask+0x8a>
			}else{
				current = current << 1;
    4396:	cc 0f       	add	r28, r28
    4398:	dd 1f       	adc	r29, r29
    439a:	02 c0       	rjmp	.+4      	; 0x43a0 <vLEDTask+0x8a>
	DDRD = 0xFF;
	PORTD = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
    439c:	c0 e0       	ldi	r28, 0x00	; 0
    439e:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_MOVE_LEFT;
			}else{
				current = current << 1;
			}
		}
		PORTD = current ^ 0b11111111;
    43a0:	9e 01       	movw	r18, r28
    43a2:	20 95       	com	r18
    43a4:	22 bb       	out	0x12, r18	; 18
		vTaskDelay(20 * TICKS_PER_MS);
    43a6:	84 e6       	ldi	r24, 0x64	; 100
    43a8:	90 e0       	ldi	r25, 0x00	; 0
    43aa:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	}
    43ae:	c9 cf       	rjmp	.-110    	; 0x4342 <vLEDTask+0x2c>

000043b0 <vMusicTask>:


/** 	
This task plays a series of musical notes in order to produce a "song"
*/
void vMusicTask( void * pvParameters ){
    43b0:	cf 93       	push	r28
    43b2:	df 93       	push	r29
	int i;
	//DDRB = 0x11111100;
	DDRB = 0xFF;
    43b4:	8f ef       	ldi	r24, 0xFF	; 255
    43b6:	87 bb       	out	0x17, r24	; 23
	Timer/Counter 0
	Clock value = 11.719 KHz
	Mode = CTC top=OCR0
	OC0 output: Toggle on compare match
	*/
	TCCR0=0x1A;
    43b8:	8a e1       	ldi	r24, 0x1A	; 26
    43ba:	83 bf       	out	0x33, r24	; 51
	TCNT0=0x00;
    43bc:	12 be       	out	0x32, r1	; 50
	OCR0=0x00;
    43be:	1c be       	out	0x3c, r1	; 60

	while(1){
		for(i=0; i<16; i++){
    43c0:	c0 e0       	ldi	r28, 0x00	; 0
    43c2:	d0 e0       	ldi	r29, 0x00	; 0
			// Set the new desired frequency
			OCR0 = notes[song3[i]+8];
    43c4:	fe 01       	movw	r30, r28
    43c6:	ee 0f       	add	r30, r30
    43c8:	ff 1f       	adc	r31, r31
    43ca:	e9 53       	subi	r30, 0x39	; 57
    43cc:	ff 4f       	sbci	r31, 0xFF	; 255
    43ce:	01 90       	ld	r0, Z+
    43d0:	f0 81       	ld	r31, Z
    43d2:	e0 2d       	mov	r30, r0
    43d4:	e9 51       	subi	r30, 0x19	; 25
    43d6:	ff 4f       	sbci	r31, 0xFF	; 255
    43d8:	80 85       	ldd	r24, Z+8	; 0x08
    43da:	8c bf       	out	0x3c, r24	; 60

			// Delay for half a second
			vTaskDelay(10 * TICKS_PER_MS);
    43dc:	82 e3       	ldi	r24, 0x32	; 50
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	TCCR0=0x1A;
	TCNT0=0x00;
	OCR0=0x00;

	while(1){
		for(i=0; i<16; i++){
    43e4:	21 96       	adiw	r28, 0x01	; 1
    43e6:	c0 31       	cpi	r28, 0x10	; 16
    43e8:	d1 05       	cpc	r29, r1
    43ea:	54 f7       	brge	.-44     	; 0x43c0 <vMusicTask+0x10>
    43ec:	eb cf       	rjmp	.-42     	; 0x43c4 <vMusicTask+0x14>

000043ee <vMainGameTask>:
		vTaskDelay(1);		
	}	
}


void vMainGameTask(void *pvParameters){
    43ee:	8f 92       	push	r8
    43f0:	9f 92       	push	r9
    43f2:	af 92       	push	r10
    43f4:	bf 92       	push	r11
    43f6:	cf 92       	push	r12
    43f8:	df 92       	push	r13
    43fa:	ef 92       	push	r14
    43fc:	ff 92       	push	r15
    43fe:	0f 93       	push	r16
    4400:	1f 93       	push	r17
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
    second = 0;
    4406:	10 92 0f 01 	sts	0x010F, r1
    440a:	10 92 0e 01 	sts	0x010E, r1
	current_state = STARTSCREEN;
    440e:	10 92 c4 00 	sts	0x00C4, r1
    4412:	10 92 c3 00 	sts	0x00C3, r1
	int firstloading = 1;
    4416:	c1 e0       	ldi	r28, 0x01	; 1
    4418:	d0 e0       	ldi	r29, 0x00	; 0
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
				led_current_state = LED_STOP;
    441a:	74 e0       	ldi	r23, 0x04	; 4
    441c:	e7 2e       	mov	r14, r23
    441e:	f1 2c       	mov	r15, r1
				current_lcd_state = LCD_WRITE;
    4420:	62 e0       	ldi	r22, 0x02	; 2
    4422:	c6 2e       	mov	r12, r22
    4424:	d1 2c       	mov	r13, r1
				current_state = RESULT;
    4426:	53 e0       	ldi	r21, 0x03	; 3
    4428:	a5 2e       	mov	r10, r21
    442a:	b1 2c       	mov	r11, r1
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    442c:	01 e0       	ldi	r16, 0x01	; 1
    442e:	10 e0       	ldi	r17, 0x00	; 0
			}else{
				set_mode(SLOW_MODE);
				led_current_state = LED_STOP;
			}
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
    4430:	4d ed       	ldi	r20, 0xDD	; 221
    4432:	84 2e       	mov	r8, r20
    4434:	91 2c       	mov	r9, r1
    second = 0;
	current_state = STARTSCREEN;
	int firstloading = 1;
	
	while(1){
		if(current_state == STARTSCREEN){
    4436:	80 91 c3 00 	lds	r24, 0x00C3
    443a:	90 91 c4 00 	lds	r25, 0x00C4
    443e:	00 97       	sbiw	r24, 0x00	; 0
    4440:	81 f4       	brne	.+32     	; 0x4462 <vMainGameTask+0x74>
			if(firstloading){
    4442:	20 97       	sbiw	r28, 0x00	; 0
    4444:	09 f4       	brne	.+2      	; 0x4448 <vMainGameTask+0x5a>
    4446:	93 c0       	rjmp	.+294    	; 0x456e <vMainGameTask+0x180>
				led_current_state = LED_START;
    4448:	10 93 11 01 	sts	0x0111, r17
    444c:	00 93 10 01 	sts	0x0110, r16
				current_lcd_state = LCD_START;
    4450:	10 93 c6 00 	sts	0x00C6, r17
    4454:	00 93 c5 00 	sts	0x00C5, r16
				firstloading = 0;
				second = 0;
    4458:	10 92 0f 01 	sts	0x010F, r1
    445c:	10 92 0e 01 	sts	0x010E, r1
    4460:	84 c0       	rjmp	.+264    	; 0x456a <vMainGameTask+0x17c>
			}
		}else if(current_state == LOADING){
    4462:	81 30       	cpi	r24, 0x01	; 1
    4464:	91 05       	cpc	r25, r1
    4466:	39 f5       	brne	.+78     	; 0x44b6 <vMainGameTask+0xc8>
			if(firstloading){
    4468:	20 97       	sbiw	r28, 0x00	; 0
    446a:	61 f0       	breq	.+24     	; 0x4484 <vMainGameTask+0x96>
				led_current_state = LED_START;
    446c:	90 93 11 01 	sts	0x0111, r25
    4470:	80 93 10 01 	sts	0x0110, r24
				current_lcd_state = LCD_START;
    4474:	90 93 c6 00 	sts	0x00C6, r25
    4478:	80 93 c5 00 	sts	0x00C5, r24
				firstloading = 0;
				second = 0;
    447c:	10 92 0f 01 	sts	0x010F, r1
    4480:	10 92 0e 01 	sts	0x010E, r1
			}

			if(second > LOADING_INTERVAL){
    4484:	80 91 0e 01 	lds	r24, 0x010E
    4488:	90 91 0f 01 	lds	r25, 0x010F
    448c:	8b 30       	cpi	r24, 0x0B	; 11
    448e:	91 05       	cpc	r25, r1
    4490:	0c f4       	brge	.+2      	; 0x4494 <vMainGameTask+0xa6>
    4492:	6b c0       	rjmp	.+214    	; 0x456a <vMainGameTask+0x17c>
				second = 0;
    4494:	10 92 0f 01 	sts	0x010F, r1
    4498:	10 92 0e 01 	sts	0x010E, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    449c:	f0 92 11 01 	sts	0x0111, r15
    44a0:	e0 92 10 01 	sts	0x0110, r14
				current_lcd_state = LCD_EMPTY;
    44a4:	b0 92 c6 00 	sts	0x00C6, r11
    44a8:	a0 92 c5 00 	sts	0x00C5, r10
				current_state = GAME;
    44ac:	d0 92 c4 00 	sts	0x00C4, r13
    44b0:	c0 92 c3 00 	sts	0x00C3, r12
    44b4:	57 c0       	rjmp	.+174    	; 0x4564 <vMainGameTask+0x176>
			}
		}else if(current_state == GAME){
    44b6:	82 30       	cpi	r24, 0x02	; 2
    44b8:	91 05       	cpc	r25, r1
    44ba:	09 f0       	breq	.+2      	; 0x44be <vMainGameTask+0xd0>
    44bc:	58 c0       	rjmp	.+176    	; 0x456e <vMainGameTask+0x180>
			current_lcd_state = LCD_WRITE;
    44be:	90 93 c6 00 	sts	0x00C6, r25
    44c2:	80 93 c5 00 	sts	0x00C5, r24
			if(firstloading){
    44c6:	20 97       	sbiw	r28, 0x00	; 0
    44c8:	31 f0       	breq	.+12     	; 0x44d6 <vMainGameTask+0xe8>
				init_game();
    44ca:	0e 94 f9 30 	call	0x61f2	; 0x61f2 <init_game>
				firstloading = 0;
				second = 0;
    44ce:	10 92 0f 01 	sts	0x010F, r1
    44d2:	10 92 0e 01 	sts	0x010E, r1
			}

			//switchinput = PORTD;
			update_game();
    44d6:	0e 94 64 31 	call	0x62c8	; 0x62c8 <update_game>
			
			if (global_sonar_cm<10){
    44da:	80 91 12 01 	lds	r24, 0x0112
    44de:	90 91 13 01 	lds	r25, 0x0113
    44e2:	8a 30       	cpi	r24, 0x0A	; 10
    44e4:	91 05       	cpc	r25, r1
    44e6:	4c f4       	brge	.+18     	; 0x44fa <vMainGameTask+0x10c>
				set_mode(FAST_MODE);
    44e8:	82 e0       	ldi	r24, 0x02	; 2
    44ea:	90 e0       	ldi	r25, 0x00	; 0
    44ec:	0e 94 6f 32 	call	0x64de	; 0x64de <set_mode>
				led_current_state = LED_START;
    44f0:	10 93 11 01 	sts	0x0111, r17
    44f4:	00 93 10 01 	sts	0x0110, r16
    44f8:	08 c0       	rjmp	.+16     	; 0x450a <vMainGameTask+0x11c>
			}else{
				set_mode(SLOW_MODE);
    44fa:	81 e0       	ldi	r24, 0x01	; 1
    44fc:	90 e0       	ldi	r25, 0x00	; 0
    44fe:	0e 94 6f 32 	call	0x64de	; 0x64de <set_mode>
				led_current_state = LED_STOP;
    4502:	f0 92 11 01 	sts	0x0111, r15
    4506:	e0 92 10 01 	sts	0x0110, r14
			}
			if(!firstsrand){
    450a:	80 91 14 01 	lds	r24, 0x0114
    450e:	90 91 15 01 	lds	r25, 0x0115
    4512:	00 97       	sbiw	r24, 0x00	; 0
    4514:	91 f4       	brne	.+36     	; 0x453a <vMainGameTask+0x14c>
				srand(global_sonar_cm*17*13);
    4516:	80 91 12 01 	lds	r24, 0x0112
    451a:	90 91 13 01 	lds	r25, 0x0113
    451e:	9c 01       	movw	r18, r24
    4520:	28 9d       	mul	r18, r8
    4522:	c0 01       	movw	r24, r0
    4524:	29 9d       	mul	r18, r9
    4526:	90 0d       	add	r25, r0
    4528:	38 9d       	mul	r19, r8
    452a:	90 0d       	add	r25, r0
    452c:	11 24       	eor	r1, r1
    452e:	0e 94 e4 32 	call	0x65c8	; 0x65c8 <srand>
				firstsrand=1;
    4532:	10 93 15 01 	sts	0x0115, r17
    4536:	00 93 14 01 	sts	0x0114, r16
			}

			if(get_state() == GAME_FINAL){
    453a:	0e 94 65 32 	call	0x64ca	; 0x64ca <get_state>
    453e:	81 30       	cpi	r24, 0x01	; 1
    4540:	91 05       	cpc	r25, r1
    4542:	99 f4       	brne	.+38     	; 0x456a <vMainGameTask+0x17c>
				second = 0;
    4544:	10 92 0f 01 	sts	0x010F, r1
    4548:	10 92 0e 01 	sts	0x010E, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    454c:	f0 92 11 01 	sts	0x0111, r15
    4550:	e0 92 10 01 	sts	0x0110, r14
				current_lcd_state = LCD_WRITE;
    4554:	d0 92 c6 00 	sts	0x00C6, r13
    4558:	c0 92 c5 00 	sts	0x00C5, r12
				current_state = RESULT;
    455c:	b0 92 c4 00 	sts	0x00C4, r11
    4560:	a0 92 c3 00 	sts	0x00C3, r10
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    4564:	c1 e0       	ldi	r28, 0x01	; 1
    4566:	d0 e0       	ldi	r29, 0x00	; 0
    4568:	02 c0       	rjmp	.+4      	; 0x456e <vMainGameTask+0x180>
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
    456a:	c0 e0       	ldi	r28, 0x00	; 0
    456c:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_STOP;
				current_lcd_state = LCD_WRITE;
				current_state = RESULT;
			}
		}
		second++;
    456e:	80 91 0e 01 	lds	r24, 0x010E
    4572:	90 91 0f 01 	lds	r25, 0x010F
    4576:	01 96       	adiw	r24, 0x01	; 1
    4578:	90 93 0f 01 	sts	0x010F, r25
    457c:	80 93 0e 01 	sts	0x010E, r24
		vTaskDelay(20 * TICKS_PER_MS);
    4580:	84 e6       	ldi	r24, 0x64	; 100
    4582:	90 e0       	ldi	r25, 0x00	; 0
    4584:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	}	
    4588:	56 cf       	rjmp	.-340    	; 0x4436 <vMainGameTask+0x48>

0000458a <vInputTask>:
		vTaskDelay(20 * TICKS_PER_MS);
	}
}


void vInputTask(void *pvParameters){
    458a:	0f 93       	push	r16
    458c:	1f 93       	push	r17
    458e:	cf 93       	push	r28
    4590:	df 93       	push	r29
	DDRC = 0x11110011;
    4592:	81 e1       	ldi	r24, 0x11	; 17
    4594:	84 bb       	out	0x14, r24	; 20
			}else if(((~input) & 0b00001000) > 0){
				set_mario(0);
			}
		}else if(current_state==RESULT && (((~input) & 0b00000100) > 0)){
			clear_lcd();
			led_current_state = LED_STOP;
    4596:	c4 e0       	ldi	r28, 0x04	; 4
    4598:	d0 e0       	ldi	r29, 0x00	; 0


void vInputTask(void *pvParameters){
	DDRC = 0x11110011;
	while(1){
		int input = PINC;
    459a:	83 b3       	in	r24, 0x13	; 19
    459c:	90 e0       	ldi	r25, 0x00	; 0
		if(current_state == STARTSCREEN){
    459e:	00 91 c3 00 	lds	r16, 0x00C3
    45a2:	10 91 c4 00 	lds	r17, 0x00C4
    45a6:	01 15       	cp	r16, r1
    45a8:	11 05       	cpc	r17, r1
    45aa:	b1 f4       	brne	.+44     	; 0x45d8 <vInputTask+0x4e>
			if(((~input) & 0b00000100) > 0){
    45ac:	80 95       	com	r24
    45ae:	90 95       	com	r25
    45b0:	82 ff       	sbrs	r24, 2
    45b2:	09 c0       	rjmp	.+18     	; 0x45c6 <vInputTask+0x3c>
				clear_lcd();
    45b4:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
				current_state = LOADING;
    45b8:	81 e0       	ldi	r24, 0x01	; 1
    45ba:	90 e0       	ldi	r25, 0x00	; 0
    45bc:	90 93 c4 00 	sts	0x00C4, r25
    45c0:	80 93 c3 00 	sts	0x00C3, r24
    45c4:	3d c0       	rjmp	.+122    	; 0x4640 <vInputTask+0xb6>
				second = 0;
				
			}else if(((~input) & 0b00001000) > 0){
    45c6:	83 ff       	sbrs	r24, 3
    45c8:	3f c0       	rjmp	.+126    	; 0x4648 <vInputTask+0xbe>
				clear_lcd();
    45ca:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
				current_state = HISCORESCREEN;
    45ce:	d0 93 c4 00 	sts	0x00C4, r29
    45d2:	c0 93 c3 00 	sts	0x00C3, r28
    45d6:	38 c0       	rjmp	.+112    	; 0x4648 <vInputTask+0xbe>
			}
		}else if(current_state == HISCORESCREEN){
    45d8:	04 30       	cpi	r16, 0x04	; 4
    45da:	11 05       	cpc	r17, r1
    45dc:	59 f4       	brne	.+22     	; 0x45f4 <vInputTask+0x6a>
			if(((~input) & 0b00000100) > 0){
    45de:	80 95       	com	r24
    45e0:	90 95       	com	r25
    45e2:	82 ff       	sbrs	r24, 2
    45e4:	31 c0       	rjmp	.+98     	; 0x4648 <vInputTask+0xbe>
				clear_lcd();
    45e6:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
				current_state = STARTSCREEN;
    45ea:	10 92 c4 00 	sts	0x00C4, r1
    45ee:	10 92 c3 00 	sts	0x00C3, r1
    45f2:	2a c0       	rjmp	.+84     	; 0x4648 <vInputTask+0xbe>
			}
		}else if(current_state == GAME){
    45f4:	02 30       	cpi	r16, 0x02	; 2
    45f6:	11 05       	cpc	r17, r1
    45f8:	71 f4       	brne	.+28     	; 0x4616 <vInputTask+0x8c>
			if(((~input) & 0b00000100) > 0){
    45fa:	80 95       	com	r24
    45fc:	90 95       	com	r25
    45fe:	82 ff       	sbrs	r24, 2
    4600:	03 c0       	rjmp	.+6      	; 0x4608 <vInputTask+0x7e>
				set_mario(1);
    4602:	81 e0       	ldi	r24, 0x01	; 1
    4604:	90 e0       	ldi	r25, 0x00	; 0
    4606:	04 c0       	rjmp	.+8      	; 0x4610 <vInputTask+0x86>
			}else if(((~input) & 0b00001000) > 0){
    4608:	83 ff       	sbrs	r24, 3
    460a:	1e c0       	rjmp	.+60     	; 0x4648 <vInputTask+0xbe>
				set_mario(0);
    460c:	80 e0       	ldi	r24, 0x00	; 0
    460e:	90 e0       	ldi	r25, 0x00	; 0
    4610:	0e 94 52 32 	call	0x64a4	; 0x64a4 <set_mario>
    4614:	19 c0       	rjmp	.+50     	; 0x4648 <vInputTask+0xbe>
			}
		}else if(current_state==RESULT && (((~input) & 0b00000100) > 0)){
    4616:	03 30       	cpi	r16, 0x03	; 3
    4618:	11 05       	cpc	r17, r1
    461a:	b1 f4       	brne	.+44     	; 0x4648 <vInputTask+0xbe>
    461c:	80 95       	com	r24
    461e:	90 95       	com	r25
    4620:	82 ff       	sbrs	r24, 2
    4622:	12 c0       	rjmp	.+36     	; 0x4648 <vInputTask+0xbe>
			clear_lcd();
    4624:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
			led_current_state = LED_STOP;
    4628:	d0 93 11 01 	sts	0x0111, r29
    462c:	c0 93 10 01 	sts	0x0110, r28
			current_lcd_state = LCD_EMPTY;
    4630:	10 93 c6 00 	sts	0x00C6, r17
    4634:	00 93 c5 00 	sts	0x00C5, r16
			current_state = STARTSCREEN;
    4638:	10 92 c4 00 	sts	0x00C4, r1
    463c:	10 92 c3 00 	sts	0x00C3, r1
			second = 0;
    4640:	10 92 0f 01 	sts	0x010F, r1
    4644:	10 92 0e 01 	sts	0x010E, r1
		}
		
		vTaskDelay(3 * TICKS_PER_MS);
    4648:	8f e0       	ldi	r24, 0x0F	; 15
    464a:	90 e0       	ldi	r25, 0x00	; 0
    464c:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	}
    4650:	a4 cf       	rjmp	.-184    	; 0x459a <vInputTask+0x10>

00004652 <vLCDTask>:
	}
}



void vLCDTask( void * pvParameters) {
    4652:	af 92       	push	r10
    4654:	bf 92       	push	r11
    4656:	cf 92       	push	r12
    4658:	df 92       	push	r13
    465a:	ef 92       	push	r14
    465c:	ff 92       	push	r15
    465e:	0f 93       	push	r16
    4660:	1f 93       	push	r17
    4662:	df 93       	push	r29
    4664:	cf 93       	push	r28
    4666:	cd b7       	in	r28, 0x3d	; 61
    4668:	de b7       	in	r29, 0x3e	; 62
    466a:	60 97       	sbiw	r28, 0x10	; 16
    466c:	0f b6       	in	r0, 0x3f	; 63
    466e:	f8 94       	cli
    4670:	de bf       	out	0x3e, r29	; 62
    4672:	0f be       	out	0x3f, r0	; 63
    4674:	cd bf       	out	0x3d, r28	; 61
	init_lcd();
    4676:	0e 94 4b 30 	call	0x6096	; 0x6096 <init_lcd>
				eeprom_update_word((uint16_t*)46,pas);
			}else{
				tulis_string("SCORE: ",1,0);
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    467a:	7e 01       	movw	r14, r28
    467c:	08 94       	sec
    467e:	e1 1c       	adc	r14, r1
    4680:	f1 1c       	adc	r15, r1
		}else if(current_state == STARTSCREEN){
			tulis_string("0.START",0,0);
			tulis_string("1.HISKOR",0,1);
		}else if(current_state == LOADING){
			if(current_lcd_state == LCD_START){	
				current_lcd_state = LCD_WRITE;
    4682:	e2 e0       	ldi	r30, 0x02	; 2
    4684:	ae 2e       	mov	r10, r30
    4686:	b1 2c       	mov	r11, r1
	tulis_data_ram_lcd(0x20); 		// Tulis spasi
	*/
	
	int ii = 0;
	while (1){
		if (current_lcd_state == LCD_EMPTY){
    4688:	20 91 c5 00 	lds	r18, 0x00C5
    468c:	30 91 c6 00 	lds	r19, 0x00C6
    4690:	23 30       	cpi	r18, 0x03	; 3
    4692:	31 05       	cpc	r19, r1
    4694:	21 f4       	brne	.+8      	; 0x469e <vLCDTask+0x4c>
			kirim_perintah_lcd(0x01);
    4696:	81 e0       	ldi	r24, 0x01	; 1
    4698:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
    469c:	92 c0       	rjmp	.+292    	; 0x47c2 <vLCDTask+0x170>
		}else if(current_state == HISCORESCREEN){
    469e:	80 91 c3 00 	lds	r24, 0x00C3
    46a2:	90 91 c4 00 	lds	r25, 0x00C4
    46a6:	84 30       	cpi	r24, 0x04	; 4
    46a8:	91 05       	cpc	r25, r1
    46aa:	09 f5       	brne	.+66     	; 0x46ee <vLCDTask+0x9c>
			
			int highscore = eeprom_read_word((uint16_t*)46);
    46ac:	8e e2       	ldi	r24, 0x2E	; 46
    46ae:	90 e0       	ldi	r25, 0x00	; 0
    46b0:	0e 94 42 33 	call	0x6684	; 0x6684 <__eerd_word_m32>
			if(highscore<0){
				highscore=0;
			}
			char lcdstr[16];
			ltoa(highscore, lcdstr, 10);
    46b4:	68 2f       	mov	r22, r24
    46b6:	79 2f       	mov	r23, r25
    46b8:	77 ff       	sbrs	r23, 7
    46ba:	02 c0       	rjmp	.+4      	; 0x46c0 <vLCDTask+0x6e>
    46bc:	60 e0       	ldi	r22, 0x00	; 0
    46be:	70 e0       	ldi	r23, 0x00	; 0
    46c0:	88 27       	eor	r24, r24
    46c2:	77 fd       	sbrc	r23, 7
    46c4:	80 95       	com	r24
    46c6:	98 2f       	mov	r25, r24
    46c8:	a7 01       	movw	r20, r14
    46ca:	2a e0       	ldi	r18, 0x0A	; 10
    46cc:	30 e0       	ldi	r19, 0x00	; 0
    46ce:	0e 94 0e 33 	call	0x661c	; 0x661c <ltoa>
			tulis_string(lcdstr,3,1);
    46d2:	c7 01       	movw	r24, r14
    46d4:	63 e0       	ldi	r22, 0x03	; 3
    46d6:	70 e0       	ldi	r23, 0x00	; 0
    46d8:	41 e0       	ldi	r20, 0x01	; 1
    46da:	50 e0       	ldi	r21, 0x00	; 0
    46dc:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>
			//tulis_string("HISCORE",0,0);
			tulis_string("HISCORE",0,0);
    46e0:	80 e6       	ldi	r24, 0x60	; 96
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	60 e0       	ldi	r22, 0x00	; 0
    46e6:	70 e0       	ldi	r23, 0x00	; 0
    46e8:	40 e0       	ldi	r20, 0x00	; 0
    46ea:	50 e0       	ldi	r21, 0x00	; 0
    46ec:	68 c0       	rjmp	.+208    	; 0x47be <vLCDTask+0x16c>
		}else if(current_state == STARTSCREEN){
    46ee:	00 97       	sbiw	r24, 0x00	; 0
    46f0:	69 f4       	brne	.+26     	; 0x470c <vLCDTask+0xba>
			tulis_string("0.START",0,0);
    46f2:	88 e6       	ldi	r24, 0x68	; 104
    46f4:	90 e0       	ldi	r25, 0x00	; 0
    46f6:	60 e0       	ldi	r22, 0x00	; 0
    46f8:	70 e0       	ldi	r23, 0x00	; 0
    46fa:	40 e0       	ldi	r20, 0x00	; 0
    46fc:	50 e0       	ldi	r21, 0x00	; 0
    46fe:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>
			tulis_string("1.HISKOR",0,1);
    4702:	80 e7       	ldi	r24, 0x70	; 112
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	60 e0       	ldi	r22, 0x00	; 0
    4708:	70 e0       	ldi	r23, 0x00	; 0
    470a:	57 c0       	rjmp	.+174    	; 0x47ba <vLCDTask+0x168>
		}else if(current_state == LOADING){
    470c:	81 30       	cpi	r24, 0x01	; 1
    470e:	91 05       	cpc	r25, r1
    4710:	c9 f4       	brne	.+50     	; 0x4744 <vLCDTask+0xf2>
			if(current_lcd_state == LCD_START){	
    4712:	21 30       	cpi	r18, 0x01	; 1
    4714:	31 05       	cpc	r19, r1
    4716:	29 f4       	brne	.+10     	; 0x4722 <vLCDTask+0xd0>
				current_lcd_state = LCD_WRITE;
    4718:	b0 92 c6 00 	sts	0x00C6, r11
    471c:	a0 92 c5 00 	sts	0x00C5, r10
    4720:	50 c0       	rjmp	.+160    	; 0x47c2 <vLCDTask+0x170>
			}else if (current_lcd_state == LCD_WRITE){
    4722:	22 30       	cpi	r18, 0x02	; 2
    4724:	31 05       	cpc	r19, r1
    4726:	09 f0       	breq	.+2      	; 0x472a <vLCDTask+0xd8>
    4728:	4c c0       	rjmp	.+152    	; 0x47c2 <vLCDTask+0x170>
				tulis_string("LOADING.",0,0);
    472a:	89 e7       	ldi	r24, 0x79	; 121
    472c:	90 e0       	ldi	r25, 0x00	; 0
    472e:	60 e0       	ldi	r22, 0x00	; 0
    4730:	70 e0       	ldi	r23, 0x00	; 0
    4732:	40 e0       	ldi	r20, 0x00	; 0
    4734:	50 e0       	ldi	r21, 0x00	; 0
    4736:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>
				tulis_string("GAME...",1,1);
    473a:	82 e8       	ldi	r24, 0x82	; 130
    473c:	90 e0       	ldi	r25, 0x00	; 0
    473e:	61 e0       	ldi	r22, 0x01	; 1
    4740:	70 e0       	ldi	r23, 0x00	; 0
    4742:	3b c0       	rjmp	.+118    	; 0x47ba <vLCDTask+0x168>
			}
		}else if(current_state == GAME){
    4744:	82 30       	cpi	r24, 0x02	; 2
    4746:	91 05       	cpc	r25, r1
    4748:	29 f4       	brne	.+10     	; 0x4754 <vLCDTask+0x102>
			clear_lcd();
    474a:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
			draw_game();
    474e:	0e 94 04 32 	call	0x6408	; 0x6408 <draw_game>
    4752:	37 c0       	rjmp	.+110    	; 0x47c2 <vLCDTask+0x170>
			//tulis_string("MULAI",0,0);
		}else if(current_state == RESULT){
    4754:	83 30       	cpi	r24, 0x03	; 3
    4756:	91 05       	cpc	r25, r1
    4758:	a1 f5       	brne	.+104    	; 0x47c2 <vLCDTask+0x170>
			clear_lcd();
    475a:	0e 94 64 30 	call	0x60c8	; 0x60c8 <clear_lcd>
			
			int highscore = eeprom_read_word((uint16_t*)46);
    475e:	8e e2       	ldi	r24, 0x2E	; 46
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	0e 94 42 33 	call	0x6684	; 0x6684 <__eerd_word_m32>
    4766:	6c 01       	movw	r12, r24
			int pas = getpass();
    4768:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <getpass>
    476c:	8c 01       	movw	r16, r24
			if(pas>=highscore){
    476e:	8c 15       	cp	r24, r12
    4770:	9d 05       	cpc	r25, r13
    4772:	74 f0       	brlt	.+28     	; 0x4790 <vLCDTask+0x13e>
				tulis_string("HISCORE: ",0,0);
    4774:	8a e8       	ldi	r24, 0x8A	; 138
    4776:	90 e0       	ldi	r25, 0x00	; 0
    4778:	60 e0       	ldi	r22, 0x00	; 0
    477a:	70 e0       	ldi	r23, 0x00	; 0
    477c:	40 e0       	ldi	r20, 0x00	; 0
    477e:	50 e0       	ldi	r21, 0x00	; 0
    4780:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>
				eeprom_update_word((uint16_t*)46,pas);
    4784:	8e e2       	ldi	r24, 0x2E	; 46
    4786:	90 e0       	ldi	r25, 0x00	; 0
    4788:	b8 01       	movw	r22, r16
    478a:	0e 94 48 33 	call	0x6690	; 0x6690 <__eeupd_word_m32>
    478e:	08 c0       	rjmp	.+16     	; 0x47a0 <vLCDTask+0x14e>
			}else{
				tulis_string("SCORE: ",1,0);
    4790:	84 e9       	ldi	r24, 0x94	; 148
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	61 e0       	ldi	r22, 0x01	; 1
    4796:	70 e0       	ldi	r23, 0x00	; 0
    4798:	40 e0       	ldi	r20, 0x00	; 0
    479a:	50 e0       	ldi	r21, 0x00	; 0
    479c:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    47a0:	b8 01       	movw	r22, r16
    47a2:	88 27       	eor	r24, r24
    47a4:	77 fd       	sbrc	r23, 7
    47a6:	80 95       	com	r24
    47a8:	98 2f       	mov	r25, r24
    47aa:	a7 01       	movw	r20, r14
    47ac:	2a e0       	ldi	r18, 0x0A	; 10
    47ae:	30 e0       	ldi	r19, 0x00	; 0
    47b0:	0e 94 0e 33 	call	0x661c	; 0x661c <ltoa>
			tulis_string(lcdstr,3,1);
    47b4:	c7 01       	movw	r24, r14
    47b6:	63 e0       	ldi	r22, 0x03	; 3
    47b8:	70 e0       	ldi	r23, 0x00	; 0
    47ba:	41 e0       	ldi	r20, 0x01	; 1
    47bc:	50 e0       	ldi	r21, 0x00	; 0
    47be:	0e 94 ad 30 	call	0x615a	; 0x615a <tulis_string>

			
		}	
		
		vTaskDelay(20 * TICKS_PER_MS);
    47c2:	84 e6       	ldi	r24, 0x64	; 100
    47c4:	90 e0       	ldi	r25, 0x00	; 0
    47c6:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		
		
	}
    47ca:	5e cf       	rjmp	.-324    	; 0x4688 <vLCDTask+0x36>

000047cc <vSonarTask>:
This task measures distance using the SRF08 every 100 ms 
and display the result in cm to LCD
*/
static int global_sonar_cm = 0;
void vSonarTask( void * pvParameters )
{
    47cc:	ef 92       	push	r14
    47ce:	ff 92       	push	r15
    47d0:	cf 93       	push	r28
    47d2:	df 93       	push	r29
    char lcd[16];
	int i = 0;
	init_lcd();
    47d4:	0e 94 4b 30 	call	0x6096	; 0x6096 <init_lcd>
	
	while(1){
		unsigned int data = 0;
		// Send command to start measurement
 		i2c_transmit(0xE0, 0, 81);
    47d8:	80 ee       	ldi	r24, 0xE0	; 224
    47da:	60 e0       	ldi	r22, 0x00	; 0
    47dc:	41 e5       	ldi	r20, 0x51	; 81
    47de:	0e 94 e6 2f 	call	0x5fcc	; 0x5fcc <i2c_transmit>
		// Wait for the measurement to be done
		vTaskDelay(70 * TICKS_PER_MS);
    47e2:	8e e5       	ldi	r24, 0x5E	; 94
    47e4:	91 e0       	ldi	r25, 0x01	; 1
    47e6:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		// Read the 16 bit result
		data = i2cRead(0xE0, 2) << 8;
    47ea:	80 ee       	ldi	r24, 0xE0	; 224
    47ec:	62 e0       	ldi	r22, 0x02	; 2
    47ee:	0e 94 00 30 	call	0x6000	; 0x6000 <i2cRead>
    47f2:	98 2f       	mov	r25, r24
    47f4:	80 e0       	ldi	r24, 0x00	; 0
    47f6:	ec 01       	movw	r28, r24
		data |= i2cRead(0xE0, 3);
    47f8:	80 ee       	ldi	r24, 0xE0	; 224
    47fa:	63 e0       	ldi	r22, 0x03	; 3
    47fc:	0e 94 00 30 	call	0x6000	; 0x6000 <i2cRead>
    4800:	90 e0       	ldi	r25, 0x00	; 0
    4802:	8c 2b       	or	r24, r28
    4804:	9d 2b       	or	r25, r29
		global_sonar_cm = data;
    4806:	90 93 13 01 	sts	0x0113, r25
    480a:	80 93 12 01 	sts	0x0112, r24
		
		
		// Delay for another 100 ms
		vTaskDelay(20 * TICKS_PER_MS);
    480e:	84 e6       	ldi	r24, 0x64	; 100
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    4816:	e0 cf       	rjmp	.-64     	; 0x47d8 <vSonarTask+0xc>

00004818 <vServoTask>:
	}

}


void vServoTask(void *pvParameters){
    4818:	0f 93       	push	r16
    481a:	1f 93       	push	r17
    481c:	cf 93       	push	r28
    481e:	df 93       	push	r29
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
    4820:	80 91 c3 00 	lds	r24, 0x00C3
    4824:	90 91 c4 00 	lds	r25, 0x00C4
    4828:	82 30       	cpi	r24, 0x02	; 2
    482a:	91 05       	cpc	r25, r1
    482c:	79 f5       	brne	.+94     	; 0x488c <vServoTask+0x74>
    482e:	c8 e2       	ldi	r28, 0x28	; 40
    4830:	d0 e0       	ldi	r29, 0x00	; 0
			i = 1;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
    4832:	c0 9a       	sbi	0x18, 0	; 24
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    4834:	81 e0       	ldi	r24, 0x01	; 1
    4836:	90 e0       	ldi	r25, 0x00	; 0
    4838:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    483c:	81 e0       	ldi	r24, 0x01	; 1
    483e:	90 e0       	ldi	r25, 0x00	; 0
    4840:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
				}
				PORTB &= 0b11111110;
    4844:	c0 98       	cbi	0x18, 0	; 24
		
				vTaskDelay(10 * TICKS_PER_MS);
    4846:	82 e3       	ldi	r24, 0x32	; 50
    4848:	90 e0       	ldi	r25, 0x00	; 0
    484a:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    484e:	21 97       	sbiw	r28, 0x01	; 1
void vServoTask(void *pvParameters){
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
			i = 1;
			for (k = 0; k < 40; k++) {
    4850:	81 f7       	brne	.-32     	; 0x4832 <vServoTask+0x1a>
				}
				PORTB &= 0b11111110;
		
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    4852:	81 e0       	ldi	r24, 0x01	; 1
    4854:	90 e0       	ldi	r25, 0x00	; 0
    4856:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		
			i = 45;
			for (k = 0; k < 40; k++) {
    485a:	c0 e0       	ldi	r28, 0x00	; 0
    485c:	d0 e0       	ldi	r29, 0x00	; 0
				PORTB |= 0b00000001;
    485e:	c0 9a       	sbi	0x18, 0	; 24
    4860:	0e e2       	ldi	r16, 0x2E	; 46
    4862:	10 e0       	ldi	r17, 0x00	; 0
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    4864:	81 e0       	ldi	r24, 0x01	; 1
    4866:	90 e0       	ldi	r25, 0x00	; 0
    4868:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
    486c:	01 50       	subi	r16, 0x01	; 1
    486e:	10 40       	sbci	r17, 0x00	; 0
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
				for (j = 0; j <= i; j++) {
    4870:	c9 f7       	brne	.-14     	; 0x4864 <vServoTask+0x4c>
					vTaskDelay(1);
				}
				PORTB &= 0b11111110;
    4872:	c0 98       	cbi	0x18, 0	; 24
			
				vTaskDelay(10 * TICKS_PER_MS);
    4874:	82 e3       	ldi	r24, 0x32	; 50
    4876:	90 e0       	ldi	r25, 0x00	; 0
    4878:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
    487c:	21 96       	adiw	r28, 0x01	; 1
    487e:	c8 32       	cpi	r28, 0x28	; 40
    4880:	d1 05       	cpc	r29, r1
    4882:	69 f7       	brne	.-38     	; 0x485e <vServoTask+0x46>
				}
				PORTB &= 0b11111110;
			
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    4884:	81 e0       	ldi	r24, 0x01	; 1
    4886:	90 e0       	ldi	r25, 0x00	; 0
    4888:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
		}
		vTaskDelay(1);		
    488c:	81 e0       	ldi	r24, 0x01	; 1
    488e:	90 e0       	ldi	r25, 0x00	; 0
    4890:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <vTaskDelay>
	}	
    4894:	c5 cf       	rjmp	.-118    	; 0x4820 <vServoTask+0x8>

00004896 <main>:
	}	
}



int main(){
    4896:	af 92       	push	r10
    4898:	bf 92       	push	r11
    489a:	cf 92       	push	r12
    489c:	df 92       	push	r13
    489e:	ef 92       	push	r14
    48a0:	ff 92       	push	r15
    48a2:	0f 93       	push	r16
    48a4:	df 93       	push	r29
    48a6:	cf 93       	push	r28
    48a8:	cd b7       	in	r28, 0x3d	; 61
    48aa:	de b7       	in	r29, 0x3e	; 62
    48ac:	2e 97       	sbiw	r28, 0x0e	; 14
    48ae:	0f b6       	in	r0, 0x3f	; 63
    48b0:	f8 94       	cli
    48b2:	de bf       	out	0x3e, r29	; 62
    48b4:	0f be       	out	0x3f, r0	; 63
    48b6:	cd bf       	out	0x3d, r28	; 61
	xTaskHandle xSonarTaskHandle, xMusicTaskHandle, xSoundTaskHandle, xLEDTaskHandle, xLCDTaskHandle, xMainGameTaskHandle;
	xTaskHandle xInputTaskHandle, xPutarServoTaskHandle ;
	
	/* set the I2C bit rate generator to 100 kb/s */
	
	TWSR &= ~0x03;
    48b8:	81 b1       	in	r24, 0x01	; 1
    48ba:	8c 7f       	andi	r24, 0xFC	; 252
    48bc:	81 b9       	out	0x01, r24	; 1
	TWBR  = 28;
    48be:	8c e1       	ldi	r24, 0x1C	; 28
    48c0:	80 b9       	out	0x00, r24	; 0
	TWCR |= _BV(TWEN);
    48c2:	86 b7       	in	r24, 0x36	; 54
    48c4:	84 60       	ori	r24, 0x04	; 4
    48c6:	86 bf       	out	0x36, r24	; 54

	LCD_CONTROL_DDR	 = _BV(LCD_RS_BIT) | _BV(LCD_EN_BIT) | _BV(LCD_RW_BIT);
    48c8:	80 ee       	ldi	r24, 0xE0	; 224
    48ca:	87 bb       	out	0x17, r24	; 23
	DDRA = 0xFF;
    48cc:	8f ef       	ldi	r24, 0xFF	; 255
    48ce:	8a bb       	out	0x1a, r24	; 26
	

	/*
	Create the tasks
	*/
	xTaskCreate( vMainGameTask, "GAME", 100, NULL, tskIDLE_PRIORITY, &xMainGameTaskHandle);
    48d0:	87 ef       	ldi	r24, 0xF7	; 247
    48d2:	91 e2       	ldi	r25, 0x21	; 33
    48d4:	6c e9       	ldi	r22, 0x9C	; 156
    48d6:	70 e0       	ldi	r23, 0x00	; 0
    48d8:	44 e6       	ldi	r20, 0x64	; 100
    48da:	50 e0       	ldi	r21, 0x00	; 0
    48dc:	20 e0       	ldi	r18, 0x00	; 0
    48de:	30 e0       	ldi	r19, 0x00	; 0
    48e0:	00 e0       	ldi	r16, 0x00	; 0
    48e2:	a9 e0       	ldi	r26, 0x09	; 9
    48e4:	ea 2e       	mov	r14, r26
    48e6:	f1 2c       	mov	r15, r1
    48e8:	ec 0e       	add	r14, r28
    48ea:	fd 1e       	adc	r15, r29
    48ec:	cc 24       	eor	r12, r12
    48ee:	dd 24       	eor	r13, r13
    48f0:	aa 24       	eor	r10, r10
    48f2:	bb 24       	eor	r11, r11
    48f4:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vLCDTask, "LCD", 100, NULL, tskIDLE_PRIORITY, &xLCDTaskHandle);
    48f8:	89 e2       	ldi	r24, 0x29	; 41
    48fa:	93 e2       	ldi	r25, 0x23	; 35
    48fc:	61 ea       	ldi	r22, 0xA1	; 161
    48fe:	70 e0       	ldi	r23, 0x00	; 0
    4900:	44 e6       	ldi	r20, 0x64	; 100
    4902:	50 e0       	ldi	r21, 0x00	; 0
    4904:	20 e0       	ldi	r18, 0x00	; 0
    4906:	30 e0       	ldi	r19, 0x00	; 0
    4908:	f7 e0       	ldi	r31, 0x07	; 7
    490a:	ef 2e       	mov	r14, r31
    490c:	f1 2c       	mov	r15, r1
    490e:	ec 0e       	add	r14, r28
    4910:	fd 1e       	adc	r15, r29
    4912:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vLEDTask, "LED", 100, NULL, tskIDLE_PRIORITY, &xLEDTaskHandle);
    4916:	8b e8       	ldi	r24, 0x8B	; 139
    4918:	91 e2       	ldi	r25, 0x21	; 33
    491a:	65 ea       	ldi	r22, 0xA5	; 165
    491c:	70 e0       	ldi	r23, 0x00	; 0
    491e:	44 e6       	ldi	r20, 0x64	; 100
    4920:	50 e0       	ldi	r21, 0x00	; 0
    4922:	20 e0       	ldi	r18, 0x00	; 0
    4924:	30 e0       	ldi	r19, 0x00	; 0
    4926:	e5 e0       	ldi	r30, 0x05	; 5
    4928:	ee 2e       	mov	r14, r30
    492a:	f1 2c       	mov	r15, r1
    492c:	ec 0e       	add	r14, r28
    492e:	fd 1e       	adc	r15, r29
    4930:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vSonarTask, "Sonar", 100, NULL , tskIDLE_PRIORITY, &xSonarTaskHandle );
    4934:	86 ee       	ldi	r24, 0xE6	; 230
    4936:	93 e2       	ldi	r25, 0x23	; 35
    4938:	69 ea       	ldi	r22, 0xA9	; 169
    493a:	70 e0       	ldi	r23, 0x00	; 0
    493c:	44 e6       	ldi	r20, 0x64	; 100
    493e:	50 e0       	ldi	r21, 0x00	; 0
    4940:	20 e0       	ldi	r18, 0x00	; 0
    4942:	30 e0       	ldi	r19, 0x00	; 0
    4944:	7e 01       	movw	r14, r28
    4946:	08 94       	sec
    4948:	e1 1c       	adc	r14, r1
    494a:	f1 1c       	adc	r15, r1
    494c:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vInputTask, "Input", 100, NULL , tskIDLE_PRIORITY, &xInputTaskHandle );
    4950:	85 ec       	ldi	r24, 0xC5	; 197
    4952:	92 e2       	ldi	r25, 0x22	; 34
    4954:	6f ea       	ldi	r22, 0xAF	; 175
    4956:	70 e0       	ldi	r23, 0x00	; 0
    4958:	44 e6       	ldi	r20, 0x64	; 100
    495a:	50 e0       	ldi	r21, 0x00	; 0
    495c:	20 e0       	ldi	r18, 0x00	; 0
    495e:	30 e0       	ldi	r19, 0x00	; 0
    4960:	bb e0       	ldi	r27, 0x0B	; 11
    4962:	eb 2e       	mov	r14, r27
    4964:	f1 2c       	mov	r15, r1
    4966:	ec 0e       	add	r14, r28
    4968:	fd 1e       	adc	r15, r29
    496a:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vMusicTask, "Sound", 100, NULL , tskIDLE_PRIORITY, &xMusicTaskHandle );
    496e:	88 ed       	ldi	r24, 0xD8	; 216
    4970:	91 e2       	ldi	r25, 0x21	; 33
    4972:	65 eb       	ldi	r22, 0xB5	; 181
    4974:	70 e0       	ldi	r23, 0x00	; 0
    4976:	44 e6       	ldi	r20, 0x64	; 100
    4978:	50 e0       	ldi	r21, 0x00	; 0
    497a:	20 e0       	ldi	r18, 0x00	; 0
    497c:	30 e0       	ldi	r19, 0x00	; 0
    497e:	a3 e0       	ldi	r26, 0x03	; 3
    4980:	ea 2e       	mov	r14, r26
    4982:	f1 2c       	mov	r15, r1
    4984:	ec 0e       	add	r14, r28
    4986:	fd 1e       	adc	r15, r29
    4988:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
	xTaskCreate( vPutarServoTask, "Servo", 100, NULL , tskIDLE_PRIORITY, &xPutarServoTaskHandle );
    498c:	89 e4       	ldi	r24, 0x49	; 73
    498e:	91 e2       	ldi	r25, 0x21	; 33
    4990:	6b eb       	ldi	r22, 0xBB	; 187
    4992:	70 e0       	ldi	r23, 0x00	; 0
    4994:	44 e6       	ldi	r20, 0x64	; 100
    4996:	50 e0       	ldi	r21, 0x00	; 0
    4998:	20 e0       	ldi	r18, 0x00	; 0
    499a:	30 e0       	ldi	r19, 0x00	; 0
    499c:	fd e0       	ldi	r31, 0x0D	; 13
    499e:	ef 2e       	mov	r14, r31
    49a0:	f1 2c       	mov	r15, r1
    49a2:	ec 0e       	add	r14, r28
    49a4:	fd 1e       	adc	r15, r29
    49a6:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>

	// Start the scheduler
	vTaskStartScheduler();
    49aa:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskStartScheduler>
}
    49ae:	80 e0       	ldi	r24, 0x00	; 0
    49b0:	90 e0       	ldi	r25, 0x00	; 0
    49b2:	2e 96       	adiw	r28, 0x0e	; 14
    49b4:	0f b6       	in	r0, 0x3f	; 63
    49b6:	f8 94       	cli
    49b8:	de bf       	out	0x3e, r29	; 62
    49ba:	0f be       	out	0x3f, r0	; 63
    49bc:	cd bf       	out	0x3d, r28	; 61
    49be:	cf 91       	pop	r28
    49c0:	df 91       	pop	r29
    49c2:	0f 91       	pop	r16
    49c4:	ff 90       	pop	r15
    49c6:	ef 90       	pop	r14
    49c8:	df 90       	pop	r13
    49ca:	cf 90       	pop	r12
    49cc:	bf 90       	pop	r11
    49ce:	af 90       	pop	r10
    49d0:	08 95       	ret

000049d2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    49d2:	af 92       	push	r10
    49d4:	bf 92       	push	r11
    49d6:	cf 92       	push	r12
    49d8:	df 92       	push	r13
    49da:	ef 92       	push	r14
    49dc:	ff 92       	push	r15
    49de:	0f 93       	push	r16
    49e0:	1f 93       	push	r17
    49e2:	cf 93       	push	r28
    49e4:	df 93       	push	r29
    49e6:	6c 01       	movw	r12, r24
    49e8:	b6 2e       	mov	r11, r22
    49ea:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    49ec:	8a e1       	ldi	r24, 0x1A	; 26
    49ee:	90 e0       	ldi	r25, 0x00	; 0
    49f0:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <pvPortMalloc>
    49f4:	e8 2e       	mov	r14, r24
    49f6:	e7 01       	movw	r28, r14
    49f8:	7e 01       	movw	r14, r28
    49fa:	f9 2e       	mov	r15, r25
    49fc:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    49fe:	20 97       	sbiw	r28, 0x00	; 0
    4a00:	09 f4       	brne	.+2      	; 0x4a04 <xCoRoutineCreate+0x32>
    4a02:	5e c0       	rjmp	.+188    	; 0x4ac0 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    4a04:	80 91 16 01 	lds	r24, 0x0116
    4a08:	90 91 17 01 	lds	r25, 0x0117
    4a0c:	00 97       	sbiw	r24, 0x00	; 0
    4a0e:	21 f5       	brne	.+72     	; 0x4a58 <xCoRoutineCreate+0x86>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4a10:	f0 92 17 01 	sts	0x0117, r15
    4a14:	e0 92 16 01 	sts	0x0116, r14
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    4a18:	82 e2       	ldi	r24, 0x22	; 34
    4a1a:	91 e0       	ldi	r25, 0x01	; 1
    4a1c:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
    4a20:	8b e2       	ldi	r24, 0x2B	; 43
    4a22:	91 e0       	ldi	r25, 0x01	; 1
    4a24:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    4a28:	5e e3       	ldi	r21, 0x3E	; 62
    4a2a:	e5 2e       	mov	r14, r21
    4a2c:	51 e0       	ldi	r21, 0x01	; 1
    4a2e:	f5 2e       	mov	r15, r21
    4a30:	c7 01       	movw	r24, r14
    4a32:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    4a36:	07 e4       	ldi	r16, 0x47	; 71
    4a38:	11 e0       	ldi	r17, 0x01	; 1
    4a3a:	c8 01       	movw	r24, r16
    4a3c:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    4a40:	88 e1       	ldi	r24, 0x18	; 24
    4a42:	91 e0       	ldi	r25, 0x01	; 1
    4a44:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    4a48:	f0 92 3b 01 	sts	0x013B, r15
    4a4c:	e0 92 3a 01 	sts	0x013A, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    4a50:	10 93 3d 01 	sts	0x013D, r17
    4a54:	00 93 3c 01 	sts	0x013C, r16
    4a58:	bb 20       	and	r11, r11
    4a5a:	11 f0       	breq	.+4      	; 0x4a60 <xCoRoutineCreate+0x8e>
    4a5c:	bb 24       	eor	r11, r11
    4a5e:	b3 94       	inc	r11
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4a60:	19 8e       	std	Y+25, r1	; 0x19
    4a62:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4a64:	be 8a       	std	Y+22, r11	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4a66:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4a68:	fe 01       	movw	r30, r28
    4a6a:	c1 92       	st	Z+, r12
    4a6c:	d1 92       	st	Z+, r13
    4a6e:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4a70:	cf 01       	movw	r24, r30
    4a72:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    4a76:	ce 01       	movw	r24, r28
    4a78:	0c 96       	adiw	r24, 0x0c	; 12
    4a7a:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4a7e:	d9 87       	std	Y+9, r29	; 0x09
    4a80:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    4a82:	db 8b       	std	Y+19, r29	; 0x13
    4a84:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4a86:	84 e0       	ldi	r24, 0x04	; 4
    4a88:	90 e0       	ldi	r25, 0x00	; 0
    4a8a:	8b 19       	sub	r24, r11
    4a8c:	91 09       	sbc	r25, r1
    4a8e:	9d 87       	std	Y+13, r25	; 0x0d
    4a90:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    4a92:	2e 89       	ldd	r18, Y+22	; 0x16
    4a94:	80 91 21 01 	lds	r24, 0x0121
    4a98:	82 17       	cp	r24, r18
    4a9a:	10 f4       	brcc	.+4      	; 0x4aa0 <xCoRoutineCreate+0xce>
    4a9c:	20 93 21 01 	sts	0x0121, r18
    4aa0:	30 e0       	ldi	r19, 0x00	; 0
    4aa2:	c9 01       	movw	r24, r18
    4aa4:	43 e0       	ldi	r20, 0x03	; 3
    4aa6:	88 0f       	add	r24, r24
    4aa8:	99 1f       	adc	r25, r25
    4aaa:	4a 95       	dec	r20
    4aac:	e1 f7       	brne	.-8      	; 0x4aa6 <xCoRoutineCreate+0xd4>
    4aae:	82 0f       	add	r24, r18
    4ab0:	93 1f       	adc	r25, r19
    4ab2:	8e 5d       	subi	r24, 0xDE	; 222
    4ab4:	9e 4f       	sbci	r25, 0xFE	; 254
    4ab6:	b8 01       	movw	r22, r16
    4ab8:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>

		xReturn = pdPASS;
    4abc:	81 e0       	ldi	r24, 0x01	; 1
    4abe:	01 c0       	rjmp	.+2      	; 0x4ac2 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4ac0:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    4ac2:	df 91       	pop	r29
    4ac4:	cf 91       	pop	r28
    4ac6:	1f 91       	pop	r17
    4ac8:	0f 91       	pop	r16
    4aca:	ff 90       	pop	r15
    4acc:	ef 90       	pop	r14
    4ace:	df 90       	pop	r13
    4ad0:	cf 90       	pop	r12
    4ad2:	bf 90       	pop	r11
    4ad4:	af 90       	pop	r10
    4ad6:	08 95       	ret

00004ad8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    4ad8:	0f 93       	push	r16
    4ada:	1f 93       	push	r17
    4adc:	cf 93       	push	r28
    4ade:	df 93       	push	r29
    4ae0:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    4ae2:	00 91 38 01 	lds	r16, 0x0138
    4ae6:	10 91 39 01 	lds	r17, 0x0139
    4aea:	08 0f       	add	r16, r24
    4aec:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4aee:	80 91 16 01 	lds	r24, 0x0116
    4af2:	90 91 17 01 	lds	r25, 0x0117
    4af6:	02 96       	adiw	r24, 0x02	; 2
    4af8:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    4afc:	60 91 16 01 	lds	r22, 0x0116
    4b00:	70 91 17 01 	lds	r23, 0x0117
    4b04:	fb 01       	movw	r30, r22
    4b06:	13 83       	std	Z+3, r17	; 0x03
    4b08:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    4b0a:	80 91 38 01 	lds	r24, 0x0138
    4b0e:	90 91 39 01 	lds	r25, 0x0139
    4b12:	6e 5f       	subi	r22, 0xFE	; 254
    4b14:	7f 4f       	sbci	r23, 0xFF	; 255
    4b16:	08 17       	cp	r16, r24
    4b18:	19 07       	cpc	r17, r25
    4b1a:	28 f4       	brcc	.+10     	; 0x4b26 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4b1c:	80 91 3c 01 	lds	r24, 0x013C
    4b20:	90 91 3d 01 	lds	r25, 0x013D
    4b24:	04 c0       	rjmp	.+8      	; 0x4b2e <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4b26:	80 91 3a 01 	lds	r24, 0x013A
    4b2a:	90 91 3b 01 	lds	r25, 0x013B
    4b2e:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <vListInsert>
	}

	if( pxEventList )
    4b32:	20 97       	sbiw	r28, 0x00	; 0
    4b34:	49 f0       	breq	.+18     	; 0x4b48 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4b36:	60 91 16 01 	lds	r22, 0x0116
    4b3a:	70 91 17 01 	lds	r23, 0x0117
    4b3e:	64 5f       	subi	r22, 0xF4	; 244
    4b40:	7f 4f       	sbci	r23, 0xFF	; 255
    4b42:	ce 01       	movw	r24, r28
    4b44:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <vListInsert>
	}
}
    4b48:	df 91       	pop	r29
    4b4a:	cf 91       	pop	r28
    4b4c:	1f 91       	pop	r17
    4b4e:	0f 91       	pop	r16
    4b50:	08 95       	ret

00004b52 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    4b52:	0f 93       	push	r16
    4b54:	1f 93       	push	r17
    4b56:	cf 93       	push	r28
    4b58:	df 93       	push	r29
    4b5a:	27 c0       	rjmp	.+78     	; 0x4baa <vCoRoutineSchedule+0x58>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    4b5c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4b5e:	e0 91 1d 01 	lds	r30, 0x011D
    4b62:	f0 91 1e 01 	lds	r31, 0x011E
    4b66:	c6 81       	ldd	r28, Z+6	; 0x06
    4b68:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4b6a:	ce 01       	movw	r24, r28
    4b6c:	0c 96       	adiw	r24, 0x0c	; 12
    4b6e:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4b72:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4b74:	8e 01       	movw	r16, r28
    4b76:	0e 5f       	subi	r16, 0xFE	; 254
    4b78:	1f 4f       	sbci	r17, 0xFF	; 255
    4b7a:	c8 01       	movw	r24, r16
    4b7c:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4b80:	2e 89       	ldd	r18, Y+22	; 0x16
    4b82:	80 91 21 01 	lds	r24, 0x0121
    4b86:	82 17       	cp	r24, r18
    4b88:	10 f4       	brcc	.+4      	; 0x4b8e <vCoRoutineSchedule+0x3c>
    4b8a:	20 93 21 01 	sts	0x0121, r18
    4b8e:	30 e0       	ldi	r19, 0x00	; 0
    4b90:	c9 01       	movw	r24, r18
    4b92:	f3 e0       	ldi	r31, 0x03	; 3
    4b94:	88 0f       	add	r24, r24
    4b96:	99 1f       	adc	r25, r25
    4b98:	fa 95       	dec	r31
    4b9a:	e1 f7       	brne	.-8      	; 0x4b94 <vCoRoutineSchedule+0x42>
    4b9c:	82 0f       	add	r24, r18
    4b9e:	93 1f       	adc	r25, r19
    4ba0:	8e 5d       	subi	r24, 0xDE	; 222
    4ba2:	9e 4f       	sbci	r25, 0xFE	; 254
    4ba4:	b8 01       	movw	r22, r16
    4ba6:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4baa:	80 91 18 01 	lds	r24, 0x0118
    4bae:	88 23       	and	r24, r24
    4bb0:	a9 f6       	brne	.-86     	; 0x4b5c <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4bb2:	0e 94 e2 2b 	call	0x57c4	; 0x57c4 <xTaskGetTickCount>
    4bb6:	20 91 34 01 	lds	r18, 0x0134
    4bba:	30 91 35 01 	lds	r19, 0x0135
    4bbe:	82 1b       	sub	r24, r18
    4bc0:	93 0b       	sbc	r25, r19
    4bc2:	90 93 37 01 	sts	0x0137, r25
    4bc6:	80 93 36 01 	sts	0x0136, r24
    4bca:	59 c0       	rjmp	.+178    	; 0x4c7e <vCoRoutineSchedule+0x12c>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4bcc:	01 96       	adiw	r24, 0x01	; 1
    4bce:	90 93 39 01 	sts	0x0139, r25
    4bd2:	80 93 38 01 	sts	0x0138, r24
		xPassedTicks--;
    4bd6:	21 50       	subi	r18, 0x01	; 1
    4bd8:	30 40       	sbci	r19, 0x00	; 0
    4bda:	30 93 37 01 	sts	0x0137, r19
    4bde:	20 93 36 01 	sts	0x0136, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    4be2:	00 97       	sbiw	r24, 0x00	; 0
    4be4:	09 f0       	breq	.+2      	; 0x4be8 <vCoRoutineSchedule+0x96>
    4be6:	44 c0       	rjmp	.+136    	; 0x4c70 <vCoRoutineSchedule+0x11e>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    4be8:	80 91 3a 01 	lds	r24, 0x013A
    4bec:	90 91 3b 01 	lds	r25, 0x013B
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4bf0:	20 91 3c 01 	lds	r18, 0x013C
    4bf4:	30 91 3d 01 	lds	r19, 0x013D
    4bf8:	30 93 3b 01 	sts	0x013B, r19
    4bfc:	20 93 3a 01 	sts	0x013A, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    4c00:	90 93 3d 01 	sts	0x013D, r25
    4c04:	80 93 3c 01 	sts	0x013C, r24
    4c08:	33 c0       	rjmp	.+102    	; 0x4c70 <vCoRoutineSchedule+0x11e>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4c0a:	05 80       	ldd	r0, Z+5	; 0x05
    4c0c:	f6 81       	ldd	r31, Z+6	; 0x06
    4c0e:	e0 2d       	mov	r30, r0
    4c10:	c6 81       	ldd	r28, Z+6	; 0x06
    4c12:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4c14:	20 91 38 01 	lds	r18, 0x0138
    4c18:	30 91 39 01 	lds	r19, 0x0139
    4c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c20:	28 17       	cp	r18, r24
    4c22:	39 07       	cpc	r19, r25
    4c24:	60 f1       	brcs	.+88     	; 0x4c7e <vCoRoutineSchedule+0x12c>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4c26:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4c28:	8e 01       	movw	r16, r28
    4c2a:	0e 5f       	subi	r16, 0xFE	; 254
    4c2c:	1f 4f       	sbci	r17, 0xFF	; 255
    4c2e:	c8 01       	movw	r24, r16
    4c30:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4c34:	8c 89       	ldd	r24, Y+20	; 0x14
    4c36:	9d 89       	ldd	r25, Y+21	; 0x15
    4c38:	00 97       	sbiw	r24, 0x00	; 0
    4c3a:	21 f0       	breq	.+8      	; 0x4c44 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4c3c:	ce 01       	movw	r24, r28
    4c3e:	0c 96       	adiw	r24, 0x0c	; 12
    4c40:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4c44:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    4c46:	2e 89       	ldd	r18, Y+22	; 0x16
    4c48:	80 91 21 01 	lds	r24, 0x0121
    4c4c:	82 17       	cp	r24, r18
    4c4e:	10 f4       	brcc	.+4      	; 0x4c54 <vCoRoutineSchedule+0x102>
    4c50:	20 93 21 01 	sts	0x0121, r18
    4c54:	30 e0       	ldi	r19, 0x00	; 0
    4c56:	c9 01       	movw	r24, r18
    4c58:	e3 e0       	ldi	r30, 0x03	; 3
    4c5a:	88 0f       	add	r24, r24
    4c5c:	99 1f       	adc	r25, r25
    4c5e:	ea 95       	dec	r30
    4c60:	e1 f7       	brne	.-8      	; 0x4c5a <vCoRoutineSchedule+0x108>
    4c62:	82 0f       	add	r24, r18
    4c64:	93 1f       	adc	r25, r19
    4c66:	8e 5d       	subi	r24, 0xDE	; 222
    4c68:	9e 4f       	sbci	r25, 0xFE	; 254
    4c6a:	b8 01       	movw	r22, r16
    4c6c:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4c70:	e0 91 3a 01 	lds	r30, 0x013A
    4c74:	f0 91 3b 01 	lds	r31, 0x013B
    4c78:	80 81       	ld	r24, Z
    4c7a:	88 23       	and	r24, r24
    4c7c:	31 f6       	brne	.-116    	; 0x4c0a <vCoRoutineSchedule+0xb8>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4c7e:	20 91 36 01 	lds	r18, 0x0136
    4c82:	30 91 37 01 	lds	r19, 0x0137
    4c86:	80 91 38 01 	lds	r24, 0x0138
    4c8a:	90 91 39 01 	lds	r25, 0x0139
    4c8e:	21 15       	cp	r18, r1
    4c90:	31 05       	cpc	r19, r1
    4c92:	09 f0       	breq	.+2      	; 0x4c96 <vCoRoutineSchedule+0x144>
    4c94:	9b cf       	rjmp	.-202    	; 0x4bcc <vCoRoutineSchedule+0x7a>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    4c96:	90 93 35 01 	sts	0x0135, r25
    4c9a:	80 93 34 01 	sts	0x0134, r24
    4c9e:	40 91 21 01 	lds	r20, 0x0121

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4ca2:	06 c0       	rjmp	.+12     	; 0x4cb0 <vCoRoutineSchedule+0x15e>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4ca4:	44 23       	and	r20, r20
    4ca6:	19 f4       	brne	.+6      	; 0x4cae <vCoRoutineSchedule+0x15c>
    4ca8:	10 92 21 01 	sts	0x0121, r1
    4cac:	40 c0       	rjmp	.+128    	; 0x4d2e <vCoRoutineSchedule+0x1dc>
    4cae:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4cb0:	84 2f       	mov	r24, r20
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	9c 01       	movw	r18, r24
    4cb6:	73 e0       	ldi	r23, 0x03	; 3
    4cb8:	22 0f       	add	r18, r18
    4cba:	33 1f       	adc	r19, r19
    4cbc:	7a 95       	dec	r23
    4cbe:	e1 f7       	brne	.-8      	; 0x4cb8 <vCoRoutineSchedule+0x166>
    4cc0:	28 0f       	add	r18, r24
    4cc2:	39 1f       	adc	r19, r25
    4cc4:	f9 01       	movw	r30, r18
    4cc6:	ee 5d       	subi	r30, 0xDE	; 222
    4cc8:	fe 4f       	sbci	r31, 0xFE	; 254
    4cca:	50 81       	ld	r21, Z
    4ccc:	55 23       	and	r21, r21
    4cce:	51 f3       	breq	.-44     	; 0x4ca4 <vCoRoutineSchedule+0x152>
    4cd0:	40 93 21 01 	sts	0x0121, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4cd4:	a1 81       	ldd	r26, Z+1	; 0x01
    4cd6:	b2 81       	ldd	r27, Z+2	; 0x02
    4cd8:	12 96       	adiw	r26, 0x02	; 2
    4cda:	0d 90       	ld	r0, X+
    4cdc:	bc 91       	ld	r27, X
    4cde:	a0 2d       	mov	r26, r0
    4ce0:	b2 83       	std	Z+2, r27	; 0x02
    4ce2:	a1 83       	std	Z+1, r26	; 0x01
    4ce4:	2b 5d       	subi	r18, 0xDB	; 219
    4ce6:	3e 4f       	sbci	r19, 0xFE	; 254
    4ce8:	a2 17       	cp	r26, r18
    4cea:	b3 07       	cpc	r27, r19
    4cec:	31 f4       	brne	.+12     	; 0x4cfa <vCoRoutineSchedule+0x1a8>
    4cee:	12 96       	adiw	r26, 0x02	; 2
    4cf0:	2d 91       	ld	r18, X+
    4cf2:	3c 91       	ld	r19, X
    4cf4:	13 97       	sbiw	r26, 0x03	; 3
    4cf6:	32 83       	std	Z+2, r19	; 0x02
    4cf8:	21 83       	std	Z+1, r18	; 0x01
    4cfa:	fc 01       	movw	r30, r24
    4cfc:	63 e0       	ldi	r22, 0x03	; 3
    4cfe:	ee 0f       	add	r30, r30
    4d00:	ff 1f       	adc	r31, r31
    4d02:	6a 95       	dec	r22
    4d04:	e1 f7       	brne	.-8      	; 0x4cfe <vCoRoutineSchedule+0x1ac>
    4d06:	e8 0f       	add	r30, r24
    4d08:	f9 1f       	adc	r31, r25
    4d0a:	ee 5d       	subi	r30, 0xDE	; 222
    4d0c:	fe 4f       	sbci	r31, 0xFE	; 254
    4d0e:	01 80       	ldd	r0, Z+1	; 0x01
    4d10:	f2 81       	ldd	r31, Z+2	; 0x02
    4d12:	e0 2d       	mov	r30, r0
    4d14:	a6 81       	ldd	r26, Z+6	; 0x06
    4d16:	b7 81       	ldd	r27, Z+7	; 0x07
    4d18:	b0 93 17 01 	sts	0x0117, r27
    4d1c:	a0 93 16 01 	sts	0x0116, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    4d20:	ed 91       	ld	r30, X+
    4d22:	fc 91       	ld	r31, X
    4d24:	11 97       	sbiw	r26, 0x01	; 1
    4d26:	cd 01       	movw	r24, r26
    4d28:	57 96       	adiw	r26, 0x17	; 23
    4d2a:	6c 91       	ld	r22, X
    4d2c:	09 95       	icall

	return;
}
    4d2e:	df 91       	pop	r29
    4d30:	cf 91       	pop	r28
    4d32:	1f 91       	pop	r17
    4d34:	0f 91       	pop	r16
    4d36:	08 95       	ret

00004d38 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    4d38:	0f 93       	push	r16
    4d3a:	1f 93       	push	r17
    4d3c:	cf 93       	push	r28
    4d3e:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4d40:	dc 01       	movw	r26, r24
    4d42:	15 96       	adiw	r26, 0x05	; 5
    4d44:	ed 91       	ld	r30, X+
    4d46:	fc 91       	ld	r31, X
    4d48:	16 97       	sbiw	r26, 0x06	; 6
    4d4a:	c6 81       	ldd	r28, Z+6	; 0x06
    4d4c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4d4e:	8e 01       	movw	r16, r28
    4d50:	04 5f       	subi	r16, 0xF4	; 244
    4d52:	1f 4f       	sbci	r17, 0xFF	; 255
    4d54:	c8 01       	movw	r24, r16
    4d56:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    4d5a:	88 e1       	ldi	r24, 0x18	; 24
    4d5c:	91 e0       	ldi	r25, 0x01	; 1
    4d5e:	b8 01       	movw	r22, r16
    4d60:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    4d64:	e0 91 16 01 	lds	r30, 0x0116
    4d68:	f0 91 17 01 	lds	r31, 0x0117
	{
		xReturn = pdTRUE;
    4d6c:	81 e0       	ldi	r24, 0x01	; 1
    4d6e:	2e 89       	ldd	r18, Y+22	; 0x16
    4d70:	96 89       	ldd	r25, Z+22	; 0x16
    4d72:	29 17       	cp	r18, r25
    4d74:	08 f4       	brcc	.+2      	; 0x4d78 <xCoRoutineRemoveFromEventList+0x40>
    4d76:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    4d78:	df 91       	pop	r29
    4d7a:	cf 91       	pop	r28
    4d7c:	1f 91       	pop	r17
    4d7e:	0f 91       	pop	r16
    4d80:	08 95       	ret

00004d82 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4d82:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    4d84:	03 96       	adiw	r24, 0x03	; 3
    4d86:	92 83       	std	Z+2, r25	; 0x02
    4d88:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4d8a:	2f ef       	ldi	r18, 0xFF	; 255
    4d8c:	3f ef       	ldi	r19, 0xFF	; 255
    4d8e:	34 83       	std	Z+4, r19	; 0x04
    4d90:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    4d92:	96 83       	std	Z+6, r25	; 0x06
    4d94:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    4d96:	90 87       	std	Z+8, r25	; 0x08
    4d98:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    4d9a:	10 82       	st	Z, r1
}
    4d9c:	08 95       	ret

00004d9e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    4d9e:	fc 01       	movw	r30, r24
    4da0:	11 86       	std	Z+9, r1	; 0x09
    4da2:	10 86       	std	Z+8, r1	; 0x08
}
    4da4:	08 95       	ret

00004da6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4da6:	cf 93       	push	r28
    4da8:	df 93       	push	r29
    4daa:	fc 01       	movw	r30, r24
    4dac:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    4dae:	21 81       	ldd	r18, Z+1	; 0x01
    4db0:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    4db2:	e9 01       	movw	r28, r18
    4db4:	8a 81       	ldd	r24, Y+2	; 0x02
    4db6:	9b 81       	ldd	r25, Y+3	; 0x03
    4db8:	13 96       	adiw	r26, 0x03	; 3
    4dba:	9c 93       	st	X, r25
    4dbc:	8e 93       	st	-X, r24
    4dbe:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4dc0:	15 96       	adiw	r26, 0x05	; 5
    4dc2:	3c 93       	st	X, r19
    4dc4:	2e 93       	st	-X, r18
    4dc6:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dca:	9b 81       	ldd	r25, Y+3	; 0x03
    4dcc:	ec 01       	movw	r28, r24
    4dce:	7d 83       	std	Y+5, r23	; 0x05
    4dd0:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    4dd2:	e9 01       	movw	r28, r18
    4dd4:	7b 83       	std	Y+3, r23	; 0x03
    4dd6:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4dd8:	72 83       	std	Z+2, r23	; 0x02
    4dda:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4ddc:	19 96       	adiw	r26, 0x09	; 9
    4dde:	fc 93       	st	X, r31
    4de0:	ee 93       	st	-X, r30
    4de2:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    4de4:	80 81       	ld	r24, Z
    4de6:	8f 5f       	subi	r24, 0xFF	; 255
    4de8:	80 83       	st	Z, r24
}
    4dea:	df 91       	pop	r29
    4dec:	cf 91       	pop	r28
    4dee:	08 95       	ret

00004df0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    4df0:	cf 93       	push	r28
    4df2:	df 93       	push	r29
    4df4:	ac 01       	movw	r20, r24
    4df6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    4df8:	88 81       	ld	r24, Y
    4dfa:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4dfc:	2f ef       	ldi	r18, 0xFF	; 255
    4dfe:	8f 3f       	cpi	r24, 0xFF	; 255
    4e00:	92 07       	cpc	r25, r18
    4e02:	21 f4       	brne	.+8      	; 0x4e0c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    4e04:	fa 01       	movw	r30, r20
    4e06:	a7 81       	ldd	r26, Z+7	; 0x07
    4e08:	b0 85       	ldd	r27, Z+8	; 0x08
    4e0a:	11 c0       	rjmp	.+34     	; 0x4e2e <vListInsert+0x3e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    4e0c:	da 01       	movw	r26, r20
    4e0e:	13 96       	adiw	r26, 0x03	; 3
    4e10:	04 c0       	rjmp	.+8      	; 0x4e1a <vListInsert+0x2a>
    4e12:	12 96       	adiw	r26, 0x02	; 2
    4e14:	0d 90       	ld	r0, X+
    4e16:	bc 91       	ld	r27, X
    4e18:	a0 2d       	mov	r26, r0
    4e1a:	12 96       	adiw	r26, 0x02	; 2
    4e1c:	2d 91       	ld	r18, X+
    4e1e:	3c 91       	ld	r19, X
    4e20:	13 97       	sbiw	r26, 0x03	; 3
    4e22:	f9 01       	movw	r30, r18
    4e24:	20 81       	ld	r18, Z
    4e26:	31 81       	ldd	r19, Z+1	; 0x01
    4e28:	82 17       	cp	r24, r18
    4e2a:	93 07       	cpc	r25, r19
    4e2c:	90 f7       	brcc	.-28     	; 0x4e12 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4e2e:	12 96       	adiw	r26, 0x02	; 2
    4e30:	8d 91       	ld	r24, X+
    4e32:	9c 91       	ld	r25, X
    4e34:	13 97       	sbiw	r26, 0x03	; 3
    4e36:	9b 83       	std	Y+3, r25	; 0x03
    4e38:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4e3a:	fc 01       	movw	r30, r24
    4e3c:	d5 83       	std	Z+5, r29	; 0x05
    4e3e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4e40:	bd 83       	std	Y+5, r27	; 0x05
    4e42:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    4e44:	13 96       	adiw	r26, 0x03	; 3
    4e46:	dc 93       	st	X, r29
    4e48:	ce 93       	st	-X, r28
    4e4a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4e4c:	59 87       	std	Y+9, r21	; 0x09
    4e4e:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    4e50:	fa 01       	movw	r30, r20
    4e52:	80 81       	ld	r24, Z
    4e54:	8f 5f       	subi	r24, 0xFF	; 255
    4e56:	80 83       	st	Z, r24
}
    4e58:	df 91       	pop	r29
    4e5a:	cf 91       	pop	r28
    4e5c:	08 95       	ret

00004e5e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4e5e:	cf 93       	push	r28
    4e60:	df 93       	push	r29
    4e62:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4e64:	a2 81       	ldd	r26, Z+2	; 0x02
    4e66:	b3 81       	ldd	r27, Z+3	; 0x03
    4e68:	84 81       	ldd	r24, Z+4	; 0x04
    4e6a:	95 81       	ldd	r25, Z+5	; 0x05
    4e6c:	15 96       	adiw	r26, 0x05	; 5
    4e6e:	9c 93       	st	X, r25
    4e70:	8e 93       	st	-X, r24
    4e72:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4e74:	c4 81       	ldd	r28, Z+4	; 0x04
    4e76:	d5 81       	ldd	r29, Z+5	; 0x05
    4e78:	bb 83       	std	Y+3, r27	; 0x03
    4e7a:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    4e7c:	a0 85       	ldd	r26, Z+8	; 0x08
    4e7e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4e80:	11 96       	adiw	r26, 0x01	; 1
    4e82:	8d 91       	ld	r24, X+
    4e84:	9c 91       	ld	r25, X
    4e86:	12 97       	sbiw	r26, 0x02	; 2
    4e88:	8e 17       	cp	r24, r30
    4e8a:	9f 07       	cpc	r25, r31
    4e8c:	21 f4       	brne	.+8      	; 0x4e96 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    4e8e:	12 96       	adiw	r26, 0x02	; 2
    4e90:	dc 93       	st	X, r29
    4e92:	ce 93       	st	-X, r28
    4e94:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    4e96:	11 86       	std	Z+9, r1	; 0x09
    4e98:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4e9a:	8c 91       	ld	r24, X
    4e9c:	81 50       	subi	r24, 0x01	; 1
    4e9e:	8c 93       	st	X, r24
}
    4ea0:	df 91       	pop	r29
    4ea2:	cf 91       	pop	r28
    4ea4:	08 95       	ret

00004ea6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4ea6:	0f 93       	push	r16
    4ea8:	1f 93       	push	r17
    4eaa:	cf 93       	push	r28
    4eac:	df 93       	push	r29
    4eae:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4eb0:	0f b6       	in	r0, 0x3f	; 63
    4eb2:	f8 94       	cli
    4eb4:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4eb6:	8c 01       	movw	r16, r24
    4eb8:	0f 5e       	subi	r16, 0xEF	; 239
    4eba:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4ebc:	0d c0       	rjmp	.+26     	; 0x4ed8 <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4ebe:	89 89       	ldd	r24, Y+17	; 0x11
    4ec0:	88 23       	and	r24, r24
    4ec2:	69 f0       	breq	.+26     	; 0x4ede <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4ec4:	c8 01       	movw	r24, r16
    4ec6:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    4eca:	88 23       	and	r24, r24
    4ecc:	11 f0       	breq	.+4      	; 0x4ed2 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4ece:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    4ed2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4ed4:	81 50       	subi	r24, 0x01	; 1
    4ed6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4ed8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4eda:	18 16       	cp	r1, r24
    4edc:	84 f3       	brlt	.-32     	; 0x4ebe <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4ede:	8f ef       	ldi	r24, 0xFF	; 255
    4ee0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4ee2:	0f 90       	pop	r0
    4ee4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4ee6:	0f b6       	in	r0, 0x3f	; 63
    4ee8:	f8 94       	cli
    4eea:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4eec:	8e 01       	movw	r16, r28
    4eee:	08 5f       	subi	r16, 0xF8	; 248
    4ef0:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4ef2:	0d c0       	rjmp	.+26     	; 0x4f0e <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4ef4:	88 85       	ldd	r24, Y+8	; 0x08
    4ef6:	88 23       	and	r24, r24
    4ef8:	69 f0       	breq	.+26     	; 0x4f14 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4efa:	c8 01       	movw	r24, r16
    4efc:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    4f00:	88 23       	and	r24, r24
    4f02:	11 f0       	breq	.+4      	; 0x4f08 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    4f04:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4f08:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4f0a:	81 50       	subi	r24, 0x01	; 1
    4f0c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4f0e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4f10:	18 16       	cp	r1, r24
    4f12:	84 f3       	brlt	.-32     	; 0x4ef4 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4f14:	8f ef       	ldi	r24, 0xFF	; 255
    4f16:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4f18:	0f 90       	pop	r0
    4f1a:	0f be       	out	0x3f, r0	; 63
}
    4f1c:	df 91       	pop	r29
    4f1e:	cf 91       	pop	r28
    4f20:	1f 91       	pop	r17
    4f22:	0f 91       	pop	r16
    4f24:	08 95       	ret

00004f26 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    4f26:	af 92       	push	r10
    4f28:	bf 92       	push	r11
    4f2a:	cf 92       	push	r12
    4f2c:	df 92       	push	r13
    4f2e:	ef 92       	push	r14
    4f30:	ff 92       	push	r15
    4f32:	0f 93       	push	r16
    4f34:	1f 93       	push	r17
    4f36:	cf 93       	push	r28
    4f38:	df 93       	push	r29
    4f3a:	b8 2e       	mov	r11, r24
    4f3c:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4f3e:	88 23       	and	r24, r24
    4f40:	09 f4       	brne	.+2      	; 0x4f44 <xQueueCreate+0x1e>
    4f42:	43 c0       	rjmp	.+134    	; 0x4fca <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4f44:	8f e1       	ldi	r24, 0x1F	; 31
    4f46:	90 e0       	ldi	r25, 0x00	; 0
    4f48:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <pvPortMalloc>
    4f4c:	e8 2e       	mov	r14, r24
    4f4e:	e7 01       	movw	r28, r14
    4f50:	7e 01       	movw	r14, r28
    4f52:	f9 2e       	mov	r15, r25
    4f54:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    4f56:	20 97       	sbiw	r28, 0x00	; 0
    4f58:	c1 f1       	breq	.+112    	; 0x4fca <xQueueCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4f5a:	0b 2d       	mov	r16, r11
    4f5c:	10 e0       	ldi	r17, 0x00	; 0
    4f5e:	ca 2c       	mov	r12, r10
    4f60:	dd 24       	eor	r13, r13
    4f62:	c0 9e       	mul	r12, r16
    4f64:	70 01       	movw	r14, r0
    4f66:	c1 9e       	mul	r12, r17
    4f68:	f0 0c       	add	r15, r0
    4f6a:	d0 9e       	mul	r13, r16
    4f6c:	f0 0c       	add	r15, r0
    4f6e:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4f70:	c7 01       	movw	r24, r14
    4f72:	01 96       	adiw	r24, 0x01	; 1
    4f74:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <pvPortMalloc>
    4f78:	99 83       	std	Y+1, r25	; 0x01
    4f7a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    4f7c:	00 97       	sbiw	r24, 0x00	; 0
    4f7e:	11 f1       	breq	.+68     	; 0x4fc4 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4f80:	e8 0e       	add	r14, r24
    4f82:	f9 1e       	adc	r15, r25
    4f84:	fb 82       	std	Y+3, r15	; 0x03
    4f86:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4f88:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    4f8a:	9d 83       	std	Y+5, r25	; 0x05
    4f8c:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    4f8e:	01 50       	subi	r16, 0x01	; 1
    4f90:	10 40       	sbci	r17, 0x00	; 0
    4f92:	0c 9d       	mul	r16, r12
    4f94:	a0 01       	movw	r20, r0
    4f96:	0d 9d       	mul	r16, r13
    4f98:	50 0d       	add	r21, r0
    4f9a:	1c 9d       	mul	r17, r12
    4f9c:	50 0d       	add	r21, r0
    4f9e:	11 24       	eor	r1, r1
    4fa0:	48 0f       	add	r20, r24
    4fa2:	59 1f       	adc	r21, r25
    4fa4:	5f 83       	std	Y+7, r21	; 0x07
    4fa6:	4e 83       	std	Y+6, r20	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    4fa8:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    4faa:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    4fac:	8f ef       	ldi	r24, 0xFF	; 255
    4fae:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    4fb0:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4fb2:	ce 01       	movw	r24, r28
    4fb4:	08 96       	adiw	r24, 0x08	; 8
    4fb6:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4fba:	ce 01       	movw	r24, r28
    4fbc:	41 96       	adiw	r24, 0x11	; 17
    4fbe:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
    4fc2:	05 c0       	rjmp	.+10     	; 0x4fce <xQueueCreate+0xa8>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    4fc4:	ce 01       	movw	r24, r28
    4fc6:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4fca:	c0 e0       	ldi	r28, 0x00	; 0
    4fcc:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    4fce:	ce 01       	movw	r24, r28
    4fd0:	df 91       	pop	r29
    4fd2:	cf 91       	pop	r28
    4fd4:	1f 91       	pop	r17
    4fd6:	0f 91       	pop	r16
    4fd8:	ff 90       	pop	r15
    4fda:	ef 90       	pop	r14
    4fdc:	df 90       	pop	r13
    4fde:	cf 90       	pop	r12
    4fe0:	bf 90       	pop	r11
    4fe2:	af 90       	pop	r10
    4fe4:	08 95       	ret

00004fe6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4fe6:	7f 92       	push	r7
    4fe8:	8f 92       	push	r8
    4fea:	9f 92       	push	r9
    4fec:	af 92       	push	r10
    4fee:	bf 92       	push	r11
    4ff0:	cf 92       	push	r12
    4ff2:	df 92       	push	r13
    4ff4:	ef 92       	push	r14
    4ff6:	ff 92       	push	r15
    4ff8:	0f 93       	push	r16
    4ffa:	1f 93       	push	r17
    4ffc:	df 93       	push	r29
    4ffe:	cf 93       	push	r28
    5000:	00 d0       	rcall	.+0      	; 0x5002 <xQueueGenericSend+0x1c>
    5002:	00 d0       	rcall	.+0      	; 0x5004 <xQueueGenericSend+0x1e>
    5004:	0f 92       	push	r0
    5006:	cd b7       	in	r28, 0x3d	; 61
    5008:	de b7       	in	r29, 0x3e	; 62
    500a:	8c 01       	movw	r16, r24
    500c:	6b 01       	movw	r12, r22
    500e:	5d 83       	std	Y+5, r21	; 0x05
    5010:	4c 83       	std	Y+4, r20	; 0x04
    5012:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5014:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5016:	7e 01       	movw	r14, r28
    5018:	08 94       	sec
    501a:	e1 1c       	adc	r14, r1
    501c:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    501e:	94 e0       	ldi	r25, 0x04	; 4
    5020:	a9 2e       	mov	r10, r25
    5022:	b1 2c       	mov	r11, r1
    5024:	ac 0e       	add	r10, r28
    5026:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5028:	88 e0       	ldi	r24, 0x08	; 8
    502a:	88 2e       	mov	r8, r24
    502c:	91 2c       	mov	r9, r1
    502e:	80 0e       	add	r8, r16
    5030:	91 1e       	adc	r9, r17
    5032:	01 c0       	rjmp	.+2      	; 0x5036 <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5034:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5036:	0f b6       	in	r0, 0x3f	; 63
    5038:	f8 94       	cli
    503a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    503c:	f8 01       	movw	r30, r16
    503e:	92 8d       	ldd	r25, Z+26	; 0x1a
    5040:	83 8d       	ldd	r24, Z+27	; 0x1b
    5042:	98 17       	cp	r25, r24
    5044:	08 f0       	brcs	.+2      	; 0x5048 <xQueueGenericSend+0x62>
    5046:	4e c0       	rjmp	.+156    	; 0x50e4 <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    5048:	44 8d       	ldd	r20, Z+28	; 0x1c
    504a:	44 23       	and	r20, r20
    504c:	c1 f1       	breq	.+112    	; 0x50be <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    504e:	77 20       	and	r7, r7
    5050:	c1 f4       	brne	.+48     	; 0x5082 <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5052:	84 81       	ldd	r24, Z+4	; 0x04
    5054:	95 81       	ldd	r25, Z+5	; 0x05
    5056:	b6 01       	movw	r22, r12
    5058:	50 e0       	ldi	r21, 0x00	; 0
    505a:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    505e:	f8 01       	movw	r30, r16
    5060:	24 8d       	ldd	r18, Z+28	; 0x1c
    5062:	84 81       	ldd	r24, Z+4	; 0x04
    5064:	95 81       	ldd	r25, Z+5	; 0x05
    5066:	82 0f       	add	r24, r18
    5068:	91 1d       	adc	r25, r1
    506a:	95 83       	std	Z+5, r25	; 0x05
    506c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    506e:	22 81       	ldd	r18, Z+2	; 0x02
    5070:	33 81       	ldd	r19, Z+3	; 0x03
    5072:	82 17       	cp	r24, r18
    5074:	93 07       	cpc	r25, r19
    5076:	18 f1       	brcs	.+70     	; 0x50be <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    5078:	80 81       	ld	r24, Z
    507a:	91 81       	ldd	r25, Z+1	; 0x01
    507c:	95 83       	std	Z+5, r25	; 0x05
    507e:	84 83       	std	Z+4, r24	; 0x04
    5080:	1e c0       	rjmp	.+60     	; 0x50be <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5082:	f8 01       	movw	r30, r16
    5084:	86 81       	ldd	r24, Z+6	; 0x06
    5086:	97 81       	ldd	r25, Z+7	; 0x07
    5088:	b6 01       	movw	r22, r12
    508a:	50 e0       	ldi	r21, 0x00	; 0
    508c:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    5090:	f8 01       	movw	r30, r16
    5092:	24 8d       	ldd	r18, Z+28	; 0x1c
    5094:	30 e0       	ldi	r19, 0x00	; 0
    5096:	30 95       	com	r19
    5098:	21 95       	neg	r18
    509a:	3f 4f       	sbci	r19, 0xFF	; 255
    509c:	86 81       	ldd	r24, Z+6	; 0x06
    509e:	97 81       	ldd	r25, Z+7	; 0x07
    50a0:	82 0f       	add	r24, r18
    50a2:	93 1f       	adc	r25, r19
    50a4:	97 83       	std	Z+7, r25	; 0x07
    50a6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    50a8:	40 81       	ld	r20, Z
    50aa:	51 81       	ldd	r21, Z+1	; 0x01
    50ac:	84 17       	cp	r24, r20
    50ae:	95 07       	cpc	r25, r21
    50b0:	30 f4       	brcc	.+12     	; 0x50be <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    50b2:	82 81       	ldd	r24, Z+2	; 0x02
    50b4:	93 81       	ldd	r25, Z+3	; 0x03
    50b6:	82 0f       	add	r24, r18
    50b8:	93 1f       	adc	r25, r19
    50ba:	97 83       	std	Z+7, r25	; 0x07
    50bc:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    50be:	f8 01       	movw	r30, r16
    50c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    50c2:	8f 5f       	subi	r24, 0xFF	; 255
    50c4:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    50c6:	81 89       	ldd	r24, Z+17	; 0x11
    50c8:	88 23       	and	r24, r24
    50ca:	41 f0       	breq	.+16     	; 0x50dc <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    50cc:	c8 01       	movw	r24, r16
    50ce:	41 96       	adiw	r24, 0x11	; 17
    50d0:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    50d4:	81 30       	cpi	r24, 0x01	; 1
    50d6:	11 f4       	brne	.+4      	; 0x50dc <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    50d8:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    50dc:	0f 90       	pop	r0
    50de:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    50e0:	81 e0       	ldi	r24, 0x01	; 1
    50e2:	4c c0       	rjmp	.+152    	; 0x517c <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    50e4:	8c 81       	ldd	r24, Y+4	; 0x04
    50e6:	9d 81       	ldd	r25, Y+5	; 0x05
    50e8:	00 97       	sbiw	r24, 0x00	; 0
    50ea:	19 f4       	brne	.+6      	; 0x50f2 <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    50ec:	0f 90       	pop	r0
    50ee:	0f be       	out	0x3f, r0	; 63
    50f0:	44 c0       	rjmp	.+136    	; 0x517a <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    50f2:	22 23       	and	r18, r18
    50f4:	19 f4       	brne	.+6      	; 0x50fc <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    50f6:	c7 01       	movw	r24, r14
    50f8:	0e 94 2c 2e 	call	0x5c58	; 0x5c58 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    50fc:	0f 90       	pop	r0
    50fe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5100:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5104:	0f b6       	in	r0, 0x3f	; 63
    5106:	f8 94       	cli
    5108:	0f 92       	push	r0
    510a:	f8 01       	movw	r30, r16
    510c:	85 8d       	ldd	r24, Z+29	; 0x1d
    510e:	8f 3f       	cpi	r24, 0xFF	; 255
    5110:	09 f4       	brne	.+2      	; 0x5114 <xQueueGenericSend+0x12e>
    5112:	15 8e       	std	Z+29, r1	; 0x1d
    5114:	f8 01       	movw	r30, r16
    5116:	86 8d       	ldd	r24, Z+30	; 0x1e
    5118:	8f 3f       	cpi	r24, 0xFF	; 255
    511a:	09 f4       	brne	.+2      	; 0x511e <xQueueGenericSend+0x138>
    511c:	16 8e       	std	Z+30, r1	; 0x1e
    511e:	0f 90       	pop	r0
    5120:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5122:	c7 01       	movw	r24, r14
    5124:	b5 01       	movw	r22, r10
    5126:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <xTaskCheckForTimeOut>
    512a:	88 23       	and	r24, r24
    512c:	09 f5       	brne	.+66     	; 0x5170 <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    512e:	0f b6       	in	r0, 0x3f	; 63
    5130:	f8 94       	cli
    5132:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5134:	f8 01       	movw	r30, r16
    5136:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5138:	0f 90       	pop	r0
    513a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    513c:	f8 01       	movw	r30, r16
    513e:	83 8d       	ldd	r24, Z+27	; 0x1b
    5140:	98 17       	cp	r25, r24
    5142:	81 f4       	brne	.+32     	; 0x5164 <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5144:	6c 81       	ldd	r22, Y+4	; 0x04
    5146:	7d 81       	ldd	r23, Y+5	; 0x05
    5148:	c4 01       	movw	r24, r8
    514a:	0e 94 cd 2d 	call	0x5b9a	; 0x5b9a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    514e:	c8 01       	movw	r24, r16
    5150:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5154:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
    5158:	88 23       	and	r24, r24
    515a:	09 f0       	breq	.+2      	; 0x515e <xQueueGenericSend+0x178>
    515c:	6b cf       	rjmp	.-298    	; 0x5034 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    515e:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
    5162:	68 cf       	rjmp	.-304    	; 0x5034 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5164:	c8 01       	movw	r24, r16
    5166:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    516a:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
    516e:	62 cf       	rjmp	.-316    	; 0x5034 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5170:	c8 01       	movw	r24, r16
    5172:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5176:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    517a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    517c:	0f 90       	pop	r0
    517e:	0f 90       	pop	r0
    5180:	0f 90       	pop	r0
    5182:	0f 90       	pop	r0
    5184:	0f 90       	pop	r0
    5186:	cf 91       	pop	r28
    5188:	df 91       	pop	r29
    518a:	1f 91       	pop	r17
    518c:	0f 91       	pop	r16
    518e:	ff 90       	pop	r15
    5190:	ef 90       	pop	r14
    5192:	df 90       	pop	r13
    5194:	cf 90       	pop	r12
    5196:	bf 90       	pop	r11
    5198:	af 90       	pop	r10
    519a:	9f 90       	pop	r9
    519c:	8f 90       	pop	r8
    519e:	7f 90       	pop	r7
    51a0:	08 95       	ret

000051a2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    51a2:	0f 93       	push	r16
    51a4:	1f 93       	push	r17
    51a6:	cf 93       	push	r28
    51a8:	df 93       	push	r29
    51aa:	ec 01       	movw	r28, r24
    51ac:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    51ae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    51b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    51b2:	98 17       	cp	r25, r24
    51b4:	08 f0       	brcs	.+2      	; 0x51b8 <xQueueGenericSendFromISR+0x16>
    51b6:	4c c0       	rjmp	.+152    	; 0x5250 <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    51b8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    51ba:	44 23       	and	r20, r20
    51bc:	99 f1       	breq	.+102    	; 0x5224 <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    51be:	22 23       	and	r18, r18
    51c0:	b1 f4       	brne	.+44     	; 0x51ee <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    51c2:	8c 81       	ldd	r24, Y+4	; 0x04
    51c4:	9d 81       	ldd	r25, Y+5	; 0x05
    51c6:	50 e0       	ldi	r21, 0x00	; 0
    51c8:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    51cc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    51ce:	8c 81       	ldd	r24, Y+4	; 0x04
    51d0:	9d 81       	ldd	r25, Y+5	; 0x05
    51d2:	82 0f       	add	r24, r18
    51d4:	91 1d       	adc	r25, r1
    51d6:	9d 83       	std	Y+5, r25	; 0x05
    51d8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    51da:	2a 81       	ldd	r18, Y+2	; 0x02
    51dc:	3b 81       	ldd	r19, Y+3	; 0x03
    51de:	82 17       	cp	r24, r18
    51e0:	93 07       	cpc	r25, r19
    51e2:	00 f1       	brcs	.+64     	; 0x5224 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    51e4:	88 81       	ld	r24, Y
    51e6:	99 81       	ldd	r25, Y+1	; 0x01
    51e8:	9d 83       	std	Y+5, r25	; 0x05
    51ea:	8c 83       	std	Y+4, r24	; 0x04
    51ec:	1b c0       	rjmp	.+54     	; 0x5224 <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    51ee:	8e 81       	ldd	r24, Y+6	; 0x06
    51f0:	9f 81       	ldd	r25, Y+7	; 0x07
    51f2:	50 e0       	ldi	r21, 0x00	; 0
    51f4:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    51f8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    51fa:	30 e0       	ldi	r19, 0x00	; 0
    51fc:	30 95       	com	r19
    51fe:	21 95       	neg	r18
    5200:	3f 4f       	sbci	r19, 0xFF	; 255
    5202:	8e 81       	ldd	r24, Y+6	; 0x06
    5204:	9f 81       	ldd	r25, Y+7	; 0x07
    5206:	82 0f       	add	r24, r18
    5208:	93 1f       	adc	r25, r19
    520a:	9f 83       	std	Y+7, r25	; 0x07
    520c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    520e:	48 81       	ld	r20, Y
    5210:	59 81       	ldd	r21, Y+1	; 0x01
    5212:	84 17       	cp	r24, r20
    5214:	95 07       	cpc	r25, r21
    5216:	30 f4       	brcc	.+12     	; 0x5224 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    5218:	8a 81       	ldd	r24, Y+2	; 0x02
    521a:	9b 81       	ldd	r25, Y+3	; 0x03
    521c:	82 0f       	add	r24, r18
    521e:	93 1f       	adc	r25, r19
    5220:	9f 83       	std	Y+7, r25	; 0x07
    5222:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    5224:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5226:	8f 5f       	subi	r24, 0xFF	; 255
    5228:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    522a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    522c:	8f 3f       	cpi	r24, 0xFF	; 255
    522e:	69 f4       	brne	.+26     	; 0x524a <xQueueGenericSendFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5230:	89 89       	ldd	r24, Y+17	; 0x11
    5232:	88 23       	and	r24, r24
    5234:	79 f0       	breq	.+30     	; 0x5254 <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5236:	ce 01       	movw	r24, r28
    5238:	41 96       	adiw	r24, 0x11	; 17
    523a:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    523e:	88 23       	and	r24, r24
    5240:	49 f0       	breq	.+18     	; 0x5254 <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    5242:	81 e0       	ldi	r24, 0x01	; 1
    5244:	f8 01       	movw	r30, r16
    5246:	80 83       	st	Z, r24
    5248:	06 c0       	rjmp	.+12     	; 0x5256 <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    524a:	8f 5f       	subi	r24, 0xFF	; 255
    524c:	8e 8f       	std	Y+30, r24	; 0x1e
    524e:	02 c0       	rjmp	.+4      	; 0x5254 <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5250:	80 e0       	ldi	r24, 0x00	; 0
    5252:	01 c0       	rjmp	.+2      	; 0x5256 <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    5254:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5256:	df 91       	pop	r29
    5258:	cf 91       	pop	r28
    525a:	1f 91       	pop	r17
    525c:	0f 91       	pop	r16
    525e:	08 95       	ret

00005260 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    5260:	7f 92       	push	r7
    5262:	8f 92       	push	r8
    5264:	9f 92       	push	r9
    5266:	af 92       	push	r10
    5268:	bf 92       	push	r11
    526a:	cf 92       	push	r12
    526c:	df 92       	push	r13
    526e:	ef 92       	push	r14
    5270:	ff 92       	push	r15
    5272:	0f 93       	push	r16
    5274:	1f 93       	push	r17
    5276:	df 93       	push	r29
    5278:	cf 93       	push	r28
    527a:	00 d0       	rcall	.+0      	; 0x527c <xQueueGenericReceive+0x1c>
    527c:	00 d0       	rcall	.+0      	; 0x527e <xQueueGenericReceive+0x1e>
    527e:	0f 92       	push	r0
    5280:	cd b7       	in	r28, 0x3d	; 61
    5282:	de b7       	in	r29, 0x3e	; 62
    5284:	8c 01       	movw	r16, r24
    5286:	86 2e       	mov	r8, r22
    5288:	77 2e       	mov	r7, r23
    528a:	5d 83       	std	Y+5, r21	; 0x05
    528c:	4c 83       	std	Y+4, r20	; 0x04
    528e:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5290:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5292:	7e 01       	movw	r14, r28
    5294:	08 94       	sec
    5296:	e1 1c       	adc	r14, r1
    5298:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    529a:	44 e0       	ldi	r20, 0x04	; 4
    529c:	c4 2e       	mov	r12, r20
    529e:	d1 2c       	mov	r13, r1
    52a0:	cc 0e       	add	r12, r28
    52a2:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    52a4:	31 e1       	ldi	r19, 0x11	; 17
    52a6:	a3 2e       	mov	r10, r19
    52a8:	b1 2c       	mov	r11, r1
    52aa:	a8 0e       	add	r10, r24
    52ac:	b9 1e       	adc	r11, r25
    52ae:	01 c0       	rjmp	.+2      	; 0x52b2 <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    52b0:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    52b2:	0f b6       	in	r0, 0x3f	; 63
    52b4:	f8 94       	cli
    52b6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    52b8:	f8 01       	movw	r30, r16
    52ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    52bc:	88 23       	and	r24, r24
    52be:	09 f4       	brne	.+2      	; 0x52c2 <xQueueGenericReceive+0x62>
    52c0:	3d c0       	rjmp	.+122    	; 0x533c <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    52c2:	e6 80       	ldd	r14, Z+6	; 0x06
    52c4:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    52c6:	80 81       	ld	r24, Z
    52c8:	91 81       	ldd	r25, Z+1	; 0x01
    52ca:	00 97       	sbiw	r24, 0x00	; 0
    52cc:	a9 f0       	breq	.+42     	; 0x52f8 <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    52ce:	44 8d       	ldd	r20, Z+28	; 0x1c
    52d0:	97 01       	movw	r18, r14
    52d2:	24 0f       	add	r18, r20
    52d4:	31 1d       	adc	r19, r1
    52d6:	37 83       	std	Z+7, r19	; 0x07
    52d8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    52da:	62 81       	ldd	r22, Z+2	; 0x02
    52dc:	73 81       	ldd	r23, Z+3	; 0x03
    52de:	26 17       	cp	r18, r22
    52e0:	37 07       	cpc	r19, r23
    52e2:	10 f0       	brcs	.+4      	; 0x52e8 <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    52e4:	97 83       	std	Z+7, r25	; 0x07
    52e6:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    52e8:	f8 01       	movw	r30, r16
    52ea:	66 81       	ldd	r22, Z+6	; 0x06
    52ec:	77 81       	ldd	r23, Z+7	; 0x07
    52ee:	88 2d       	mov	r24, r8
    52f0:	97 2d       	mov	r25, r7
    52f2:	50 e0       	ldi	r21, 0x00	; 0
    52f4:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    52f8:	99 20       	and	r9, r9
    52fa:	71 f4       	brne	.+28     	; 0x5318 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    52fc:	f8 01       	movw	r30, r16
    52fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    5300:	81 50       	subi	r24, 0x01	; 1
    5302:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5304:	80 85       	ldd	r24, Z+8	; 0x08
    5306:	88 23       	and	r24, r24
    5308:	a9 f0       	breq	.+42     	; 0x5334 <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    530a:	c8 01       	movw	r24, r16
    530c:	08 96       	adiw	r24, 0x08	; 8
    530e:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    5312:	81 30       	cpi	r24, 0x01	; 1
    5314:	79 f4       	brne	.+30     	; 0x5334 <xQueueGenericReceive+0xd4>
    5316:	0c c0       	rjmp	.+24     	; 0x5330 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5318:	f8 01       	movw	r30, r16
    531a:	f7 82       	std	Z+7, r15	; 0x07
    531c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    531e:	81 89       	ldd	r24, Z+17	; 0x11
    5320:	88 23       	and	r24, r24
    5322:	41 f0       	breq	.+16     	; 0x5334 <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5324:	c8 01       	movw	r24, r16
    5326:	41 96       	adiw	r24, 0x11	; 17
    5328:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    532c:	88 23       	and	r24, r24
    532e:	11 f0       	breq	.+4      	; 0x5334 <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    5330:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    5334:	0f 90       	pop	r0
    5336:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5338:	81 e0       	ldi	r24, 0x01	; 1
    533a:	4a c0       	rjmp	.+148    	; 0x53d0 <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    533c:	8c 81       	ldd	r24, Y+4	; 0x04
    533e:	9d 81       	ldd	r25, Y+5	; 0x05
    5340:	00 97       	sbiw	r24, 0x00	; 0
    5342:	19 f4       	brne	.+6      	; 0x534a <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5344:	0f 90       	pop	r0
    5346:	0f be       	out	0x3f, r0	; 63
    5348:	42 c0       	rjmp	.+132    	; 0x53ce <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    534a:	22 23       	and	r18, r18
    534c:	19 f4       	brne	.+6      	; 0x5354 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    534e:	c7 01       	movw	r24, r14
    5350:	0e 94 2c 2e 	call	0x5c58	; 0x5c58 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    5354:	0f 90       	pop	r0
    5356:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5358:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    535c:	0f b6       	in	r0, 0x3f	; 63
    535e:	f8 94       	cli
    5360:	0f 92       	push	r0
    5362:	f8 01       	movw	r30, r16
    5364:	85 8d       	ldd	r24, Z+29	; 0x1d
    5366:	8f 3f       	cpi	r24, 0xFF	; 255
    5368:	09 f4       	brne	.+2      	; 0x536c <xQueueGenericReceive+0x10c>
    536a:	15 8e       	std	Z+29, r1	; 0x1d
    536c:	f8 01       	movw	r30, r16
    536e:	86 8d       	ldd	r24, Z+30	; 0x1e
    5370:	8f 3f       	cpi	r24, 0xFF	; 255
    5372:	09 f4       	brne	.+2      	; 0x5376 <xQueueGenericReceive+0x116>
    5374:	16 8e       	std	Z+30, r1	; 0x1e
    5376:	0f 90       	pop	r0
    5378:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    537a:	c7 01       	movw	r24, r14
    537c:	b6 01       	movw	r22, r12
    537e:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <xTaskCheckForTimeOut>
    5382:	88 23       	and	r24, r24
    5384:	f9 f4       	brne	.+62     	; 0x53c4 <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5386:	0f b6       	in	r0, 0x3f	; 63
    5388:	f8 94       	cli
    538a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    538c:	f8 01       	movw	r30, r16
    538e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5390:	0f 90       	pop	r0
    5392:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5394:	88 23       	and	r24, r24
    5396:	81 f4       	brne	.+32     	; 0x53b8 <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5398:	6c 81       	ldd	r22, Y+4	; 0x04
    539a:	7d 81       	ldd	r23, Y+5	; 0x05
    539c:	c5 01       	movw	r24, r10
    539e:	0e 94 cd 2d 	call	0x5b9a	; 0x5b9a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    53a2:	c8 01       	movw	r24, r16
    53a4:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    53a8:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
    53ac:	88 23       	and	r24, r24
    53ae:	09 f0       	breq	.+2      	; 0x53b2 <xQueueGenericReceive+0x152>
    53b0:	7f cf       	rjmp	.-258    	; 0x52b0 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    53b2:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
    53b6:	7c cf       	rjmp	.-264    	; 0x52b0 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    53b8:	c8 01       	movw	r24, r16
    53ba:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    53be:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
    53c2:	76 cf       	rjmp	.-276    	; 0x52b0 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    53c4:	c8 01       	movw	r24, r16
    53c6:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    53ca:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    53ce:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    53d0:	0f 90       	pop	r0
    53d2:	0f 90       	pop	r0
    53d4:	0f 90       	pop	r0
    53d6:	0f 90       	pop	r0
    53d8:	0f 90       	pop	r0
    53da:	cf 91       	pop	r28
    53dc:	df 91       	pop	r29
    53de:	1f 91       	pop	r17
    53e0:	0f 91       	pop	r16
    53e2:	ff 90       	pop	r15
    53e4:	ef 90       	pop	r14
    53e6:	df 90       	pop	r13
    53e8:	cf 90       	pop	r12
    53ea:	bf 90       	pop	r11
    53ec:	af 90       	pop	r10
    53ee:	9f 90       	pop	r9
    53f0:	8f 90       	pop	r8
    53f2:	7f 90       	pop	r7
    53f4:	08 95       	ret

000053f6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    53f6:	0f 93       	push	r16
    53f8:	1f 93       	push	r17
    53fa:	cf 93       	push	r28
    53fc:	df 93       	push	r29
    53fe:	ec 01       	movw	r28, r24
    5400:	cb 01       	movw	r24, r22
    5402:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5404:	2a 8d       	ldd	r18, Y+26	; 0x1a
    5406:	22 23       	and	r18, r18
    5408:	71 f1       	breq	.+92     	; 0x5466 <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    540a:	e8 81       	ld	r30, Y
    540c:	f9 81       	ldd	r31, Y+1	; 0x01
    540e:	30 97       	sbiw	r30, 0x00	; 0
    5410:	a1 f0       	breq	.+40     	; 0x543a <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    5412:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5414:	2e 81       	ldd	r18, Y+6	; 0x06
    5416:	3f 81       	ldd	r19, Y+7	; 0x07
    5418:	24 0f       	add	r18, r20
    541a:	31 1d       	adc	r19, r1
    541c:	3f 83       	std	Y+7, r19	; 0x07
    541e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    5420:	aa 81       	ldd	r26, Y+2	; 0x02
    5422:	bb 81       	ldd	r27, Y+3	; 0x03
    5424:	2a 17       	cp	r18, r26
    5426:	3b 07       	cpc	r19, r27
    5428:	10 f0       	brcs	.+4      	; 0x542e <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    542a:	ff 83       	std	Y+7, r31	; 0x07
    542c:	ee 83       	std	Y+6, r30	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    542e:	6e 81       	ldd	r22, Y+6	; 0x06
    5430:	2f 81       	ldd	r18, Y+7	; 0x07
    5432:	72 2f       	mov	r23, r18
    5434:	50 e0       	ldi	r21, 0x00	; 0
    5436:	0e 94 ef 32 	call	0x65de	; 0x65de <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    543a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    543c:	81 50       	subi	r24, 0x01	; 1
    543e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    5440:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5442:	8f 3f       	cpi	r24, 0xFF	; 255
    5444:	69 f4       	brne	.+26     	; 0x5460 <xQueueReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5446:	88 85       	ldd	r24, Y+8	; 0x08
    5448:	88 23       	and	r24, r24
    544a:	79 f0       	breq	.+30     	; 0x546a <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    544c:	ce 01       	movw	r24, r28
    544e:	08 96       	adiw	r24, 0x08	; 8
    5450:	0e 94 ea 2d 	call	0x5bd4	; 0x5bd4 <xTaskRemoveFromEventList>
    5454:	88 23       	and	r24, r24
    5456:	49 f0       	breq	.+18     	; 0x546a <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    5458:	81 e0       	ldi	r24, 0x01	; 1
    545a:	f8 01       	movw	r30, r16
    545c:	80 83       	st	Z, r24
    545e:	06 c0       	rjmp	.+12     	; 0x546c <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    5460:	8f 5f       	subi	r24, 0xFF	; 255
    5462:	8d 8f       	std	Y+29, r24	; 0x1d
    5464:	02 c0       	rjmp	.+4      	; 0x546a <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    5466:	80 e0       	ldi	r24, 0x00	; 0
    5468:	01 c0       	rjmp	.+2      	; 0x546c <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    546a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    546c:	df 91       	pop	r29
    546e:	cf 91       	pop	r28
    5470:	1f 91       	pop	r17
    5472:	0f 91       	pop	r16
    5474:	08 95       	ret

00005476 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5476:	0f b6       	in	r0, 0x3f	; 63
    5478:	f8 94       	cli
    547a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    547c:	fc 01       	movw	r30, r24
    547e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5480:	0f 90       	pop	r0
    5482:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    5484:	08 95       	ret

00005486 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    5486:	fc 01       	movw	r30, r24
    5488:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    548a:	08 95       	ret

0000548c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    548c:	cf 93       	push	r28
    548e:	df 93       	push	r29
    5490:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    5492:	88 81       	ld	r24, Y
    5494:	99 81       	ldd	r25, Y+1	; 0x01
    5496:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vPortFree>
	vPortFree( pxQueue );
    549a:	ce 01       	movw	r24, r28
    549c:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vPortFree>
}
    54a0:	df 91       	pop	r29
    54a2:	cf 91       	pop	r28
    54a4:	08 95       	ret

000054a6 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    54a6:	fc 01       	movw	r30, r24
    54a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    54aa:	81 e0       	ldi	r24, 0x01	; 1
    54ac:	91 11       	cpse	r25, r1
    54ae:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    54b0:	08 95       	ret

000054b2 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    54b2:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    54b4:	22 8d       	ldd	r18, Z+26	; 0x1a
    54b6:	81 e0       	ldi	r24, 0x01	; 1
    54b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    54ba:	29 13       	cpse	r18, r25
    54bc:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    54be:	08 95       	ret

000054c0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    54c0:	cf 93       	push	r28
    54c2:	df 93       	push	r29
    54c4:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    54c6:	e0 91 50 01 	lds	r30, 0x0150
    54ca:	f0 91 51 01 	lds	r31, 0x0151
    54ce:	93 83       	std	Z+3, r25	; 0x03
    54d0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    54d2:	80 91 54 01 	lds	r24, 0x0154
    54d6:	90 91 55 01 	lds	r25, 0x0155
    54da:	c8 17       	cp	r28, r24
    54dc:	d9 07       	cpc	r29, r25
    54de:	68 f4       	brcc	.+26     	; 0x54fa <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    54e0:	80 91 85 01 	lds	r24, 0x0185
    54e4:	90 91 86 01 	lds	r25, 0x0186
    54e8:	60 91 50 01 	lds	r22, 0x0150
    54ec:	70 91 51 01 	lds	r23, 0x0151
    54f0:	6e 5f       	subi	r22, 0xFE	; 254
    54f2:	7f 4f       	sbci	r23, 0xFF	; 255
    54f4:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <vListInsert>
    54f8:	17 c0       	rjmp	.+46     	; 0x5528 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    54fa:	80 91 87 01 	lds	r24, 0x0187
    54fe:	90 91 88 01 	lds	r25, 0x0188
    5502:	60 91 50 01 	lds	r22, 0x0150
    5506:	70 91 51 01 	lds	r23, 0x0151
    550a:	6e 5f       	subi	r22, 0xFE	; 254
    550c:	7f 4f       	sbci	r23, 0xFF	; 255
    550e:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    5512:	80 91 03 01 	lds	r24, 0x0103
    5516:	90 91 04 01 	lds	r25, 0x0104
    551a:	c8 17       	cp	r28, r24
    551c:	d9 07       	cpc	r29, r25
    551e:	20 f4       	brcc	.+8      	; 0x5528 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5520:	d0 93 04 01 	sts	0x0104, r29
    5524:	c0 93 03 01 	sts	0x0103, r28
		}
	}
}
    5528:	df 91       	pop	r29
    552a:	cf 91       	pop	r28
    552c:	08 95       	ret

0000552e <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    552e:	80 91 58 01 	lds	r24, 0x0158
    5532:	82 30       	cpi	r24, 0x02	; 2
    5534:	e0 f3       	brcs	.-8      	; 0x552e <prvIdleTask>
			{
				taskYIELD();
    5536:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
    553a:	f9 cf       	rjmp	.-14     	; 0x552e <prvIdleTask>

0000553c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    553c:	2f 92       	push	r2
    553e:	3f 92       	push	r3
    5540:	4f 92       	push	r4
    5542:	5f 92       	push	r5
    5544:	6f 92       	push	r6
    5546:	7f 92       	push	r7
    5548:	8f 92       	push	r8
    554a:	9f 92       	push	r9
    554c:	af 92       	push	r10
    554e:	bf 92       	push	r11
    5550:	cf 92       	push	r12
    5552:	df 92       	push	r13
    5554:	ef 92       	push	r14
    5556:	ff 92       	push	r15
    5558:	0f 93       	push	r16
    555a:	1f 93       	push	r17
    555c:	cf 93       	push	r28
    555e:	df 93       	push	r29
    5560:	1c 01       	movw	r2, r24
    5562:	3b 01       	movw	r6, r22
    5564:	5a 01       	movw	r10, r20
    5566:	29 01       	movw	r4, r18
    5568:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    556a:	81 e2       	ldi	r24, 0x21	; 33
    556c:	90 e0       	ldi	r25, 0x00	; 0
    556e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <pvPortMalloc>
    5572:	e8 2e       	mov	r14, r24
    5574:	e7 01       	movw	r28, r14
    5576:	7e 01       	movw	r14, r28
    5578:	f9 2e       	mov	r15, r25
    557a:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    557c:	20 97       	sbiw	r28, 0x00	; 0
    557e:	09 f4       	brne	.+2      	; 0x5582 <xTaskGenericCreate+0x46>
    5580:	d4 c0       	rjmp	.+424    	; 0x572a <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    5582:	c1 14       	cp	r12, r1
    5584:	d1 04       	cpc	r13, r1
    5586:	29 f4       	brne	.+10     	; 0x5592 <xTaskGenericCreate+0x56>
    5588:	c5 01       	movw	r24, r10
    558a:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <pvPortMalloc>
    558e:	c8 2e       	mov	r12, r24
    5590:	d9 2e       	mov	r13, r25
    5592:	d8 8e       	std	Y+24, r13	; 0x18
    5594:	cf 8a       	std	Y+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    5596:	c1 14       	cp	r12, r1
    5598:	d1 04       	cpc	r13, r1
    559a:	21 f4       	brne	.+8      	; 0x55a4 <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    559c:	ce 01       	movw	r24, r28
    559e:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vPortFree>
    55a2:	c3 c0       	rjmp	.+390    	; 0x572a <xTaskGenericCreate+0x1ee>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    55a4:	c6 01       	movw	r24, r12
    55a6:	65 ea       	ldi	r22, 0xA5	; 165
    55a8:	70 e0       	ldi	r23, 0x00	; 0
    55aa:	a5 01       	movw	r20, r10
    55ac:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    55b0:	08 94       	sec
    55b2:	a1 08       	sbc	r10, r1
    55b4:	b1 08       	sbc	r11, r1
    55b6:	ef 88       	ldd	r14, Y+23	; 0x17
    55b8:	f8 8c       	ldd	r15, Y+24	; 0x18
    55ba:	ea 0c       	add	r14, r10
    55bc:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    55be:	ce 01       	movw	r24, r28
    55c0:	49 96       	adiw	r24, 0x19	; 25
    55c2:	b3 01       	movw	r22, r6
    55c4:	48 e0       	ldi	r20, 0x08	; 8
    55c6:	50 e0       	ldi	r21, 0x00	; 0
    55c8:	0e 94 ff 32 	call	0x65fe	; 0x65fe <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    55cc:	18 a2       	std	Y+32, r1	; 0x20
    55ce:	10 2f       	mov	r17, r16
    55d0:	04 30       	cpi	r16, 0x04	; 4
    55d2:	08 f0       	brcs	.+2      	; 0x55d6 <xTaskGenericCreate+0x9a>
    55d4:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    55d6:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    55d8:	e2 e0       	ldi	r30, 0x02	; 2
    55da:	ae 2e       	mov	r10, r30
    55dc:	b1 2c       	mov	r11, r1
    55de:	ac 0e       	add	r10, r28
    55e0:	bd 1e       	adc	r11, r29
    55e2:	c5 01       	movw	r24, r10
    55e4:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    55e8:	ce 01       	movw	r24, r28
    55ea:	0c 96       	adiw	r24, 0x0c	; 12
    55ec:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    55f0:	d9 87       	std	Y+9, r29	; 0x09
    55f2:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    55f4:	84 e0       	ldi	r24, 0x04	; 4
    55f6:	90 e0       	ldi	r25, 0x00	; 0
    55f8:	81 1b       	sub	r24, r17
    55fa:	91 09       	sbc	r25, r1
    55fc:	9d 87       	std	Y+13, r25	; 0x0d
    55fe:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5600:	db 8b       	std	Y+19, r29	; 0x13
    5602:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5604:	c7 01       	movw	r24, r14
    5606:	b1 01       	movw	r22, r2
    5608:	a2 01       	movw	r20, r4
    560a:	0e 94 76 2e 	call	0x5cec	; 0x5cec <pxPortInitialiseStack>
    560e:	99 83       	std	Y+1, r25	; 0x01
    5610:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    5612:	81 14       	cp	r8, r1
    5614:	91 04       	cpc	r9, r1
    5616:	19 f0       	breq	.+6      	; 0x561e <xTaskGenericCreate+0xe2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5618:	f4 01       	movw	r30, r8
    561a:	d1 83       	std	Z+1, r29	; 0x01
    561c:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    561e:	0f b6       	in	r0, 0x3f	; 63
    5620:	f8 94       	cli
    5622:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    5624:	80 91 8a 01 	lds	r24, 0x018A
    5628:	8f 5f       	subi	r24, 0xFF	; 255
    562a:	80 93 8a 01 	sts	0x018A, r24
			if( pxCurrentTCB == NULL )
    562e:	80 91 50 01 	lds	r24, 0x0150
    5632:	90 91 51 01 	lds	r25, 0x0151
    5636:	00 97       	sbiw	r24, 0x00	; 0
    5638:	c9 f5       	brne	.+114    	; 0x56ac <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    563a:	d0 93 51 01 	sts	0x0151, r29
    563e:	c0 93 50 01 	sts	0x0150, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    5642:	80 91 8a 01 	lds	r24, 0x018A
    5646:	81 30       	cpi	r24, 0x01	; 1
    5648:	09 f0       	breq	.+2      	; 0x564c <xTaskGenericCreate+0x110>
    564a:	3f c0       	rjmp	.+126    	; 0x56ca <xTaskGenericCreate+0x18e>
    564c:	ee 24       	eor	r14, r14
    564e:	ff 24       	eor	r15, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5650:	c7 01       	movw	r24, r14
    5652:	73 e0       	ldi	r23, 0x03	; 3
    5654:	88 0f       	add	r24, r24
    5656:	99 1f       	adc	r25, r25
    5658:	7a 95       	dec	r23
    565a:	e1 f7       	brne	.-8      	; 0x5654 <xTaskGenericCreate+0x118>
    565c:	8e 0d       	add	r24, r14
    565e:	9f 1d       	adc	r25, r15
    5660:	88 5a       	subi	r24, 0xA8	; 168
    5662:	9e 4f       	sbci	r25, 0xFE	; 254
    5664:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
    5668:	08 94       	sec
    566a:	e1 1c       	adc	r14, r1
    566c:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    566e:	f4 e0       	ldi	r31, 0x04	; 4
    5670:	ef 16       	cp	r14, r31
    5672:	f1 04       	cpc	r15, r1
    5674:	69 f7       	brne	.-38     	; 0x5650 <xTaskGenericCreate+0x114>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5676:	6e e8       	ldi	r22, 0x8E	; 142
    5678:	e6 2e       	mov	r14, r22
    567a:	61 e0       	ldi	r22, 0x01	; 1
    567c:	f6 2e       	mov	r15, r22
    567e:	c7 01       	movw	r24, r14
    5680:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5684:	57 e9       	ldi	r21, 0x97	; 151
    5686:	c5 2e       	mov	r12, r21
    5688:	51 e0       	ldi	r21, 0x01	; 1
    568a:	d5 2e       	mov	r13, r21
    568c:	c6 01       	movw	r24, r12
    568e:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    5692:	8c e7       	ldi	r24, 0x7C	; 124
    5694:	91 e0       	ldi	r25, 0x01	; 1
    5696:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    569a:	f0 92 88 01 	sts	0x0188, r15
    569e:	e0 92 87 01 	sts	0x0187, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    56a2:	d0 92 86 01 	sts	0x0186, r13
    56a6:	c0 92 85 01 	sts	0x0185, r12
    56aa:	0f c0       	rjmp	.+30     	; 0x56ca <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    56ac:	80 91 8b 01 	lds	r24, 0x018B
    56b0:	88 23       	and	r24, r24
    56b2:	59 f4       	brne	.+22     	; 0x56ca <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    56b4:	e0 91 50 01 	lds	r30, 0x0150
    56b8:	f0 91 51 01 	lds	r31, 0x0151
    56bc:	86 89       	ldd	r24, Z+22	; 0x16
    56be:	08 17       	cp	r16, r24
    56c0:	20 f0       	brcs	.+8      	; 0x56ca <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    56c2:	d0 93 51 01 	sts	0x0151, r29
    56c6:	c0 93 50 01 	sts	0x0150, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    56ca:	2e 89       	ldd	r18, Y+22	; 0x16
    56cc:	80 91 8c 01 	lds	r24, 0x018C
    56d0:	82 17       	cp	r24, r18
    56d2:	10 f4       	brcc	.+4      	; 0x56d8 <xTaskGenericCreate+0x19c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    56d4:	20 93 8c 01 	sts	0x018C, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    56d8:	80 91 8d 01 	lds	r24, 0x018D
    56dc:	8f 5f       	subi	r24, 0xFF	; 255
    56de:	80 93 8d 01 	sts	0x018D, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    56e2:	80 91 57 01 	lds	r24, 0x0157
    56e6:	82 17       	cp	r24, r18
    56e8:	10 f4       	brcc	.+4      	; 0x56ee <xTaskGenericCreate+0x1b2>
    56ea:	20 93 57 01 	sts	0x0157, r18
    56ee:	30 e0       	ldi	r19, 0x00	; 0
    56f0:	c9 01       	movw	r24, r18
    56f2:	43 e0       	ldi	r20, 0x03	; 3
    56f4:	88 0f       	add	r24, r24
    56f6:	99 1f       	adc	r25, r25
    56f8:	4a 95       	dec	r20
    56fa:	e1 f7       	brne	.-8      	; 0x56f4 <xTaskGenericCreate+0x1b8>
    56fc:	82 0f       	add	r24, r18
    56fe:	93 1f       	adc	r25, r19
    5700:	88 5a       	subi	r24, 0xA8	; 168
    5702:	9e 4f       	sbci	r25, 0xFE	; 254
    5704:	b5 01       	movw	r22, r10
    5706:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    570a:	0f 90       	pop	r0
    570c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    570e:	80 91 8b 01 	lds	r24, 0x018B
    5712:	88 23       	and	r24, r24
    5714:	61 f0       	breq	.+24     	; 0x572e <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5716:	e0 91 50 01 	lds	r30, 0x0150
    571a:	f0 91 51 01 	lds	r31, 0x0151
    571e:	86 89       	ldd	r24, Z+22	; 0x16
    5720:	80 17       	cp	r24, r16
    5722:	28 f4       	brcc	.+10     	; 0x572e <xTaskGenericCreate+0x1f2>
			{
				portYIELD_WITHIN_API();
    5724:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
    5728:	02 c0       	rjmp	.+4      	; 0x572e <xTaskGenericCreate+0x1f2>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    572a:	8f ef       	ldi	r24, 0xFF	; 255
    572c:	01 c0       	rjmp	.+2      	; 0x5730 <xTaskGenericCreate+0x1f4>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    572e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    5730:	df 91       	pop	r29
    5732:	cf 91       	pop	r28
    5734:	1f 91       	pop	r17
    5736:	0f 91       	pop	r16
    5738:	ff 90       	pop	r15
    573a:	ef 90       	pop	r14
    573c:	df 90       	pop	r13
    573e:	cf 90       	pop	r12
    5740:	bf 90       	pop	r11
    5742:	af 90       	pop	r10
    5744:	9f 90       	pop	r9
    5746:	8f 90       	pop	r8
    5748:	7f 90       	pop	r7
    574a:	6f 90       	pop	r6
    574c:	5f 90       	pop	r5
    574e:	4f 90       	pop	r4
    5750:	3f 90       	pop	r3
    5752:	2f 90       	pop	r2
    5754:	08 95       	ret

00005756 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    5756:	af 92       	push	r10
    5758:	bf 92       	push	r11
    575a:	cf 92       	push	r12
    575c:	df 92       	push	r13
    575e:	ef 92       	push	r14
    5760:	ff 92       	push	r15
    5762:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    5764:	87 e9       	ldi	r24, 0x97	; 151
    5766:	9a e2       	ldi	r25, 0x2A	; 42
    5768:	6e ef       	ldi	r22, 0xFE	; 254
    576a:	70 e0       	ldi	r23, 0x00	; 0
    576c:	45 e5       	ldi	r20, 0x55	; 85
    576e:	50 e0       	ldi	r21, 0x00	; 0
    5770:	20 e0       	ldi	r18, 0x00	; 0
    5772:	30 e0       	ldi	r19, 0x00	; 0
    5774:	00 e0       	ldi	r16, 0x00	; 0
    5776:	ee 24       	eor	r14, r14
    5778:	ff 24       	eor	r15, r15
    577a:	cc 24       	eor	r12, r12
    577c:	dd 24       	eor	r13, r13
    577e:	aa 24       	eor	r10, r10
    5780:	bb 24       	eor	r11, r11
    5782:	0e 94 9e 2a 	call	0x553c	; 0x553c <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    5786:	81 30       	cpi	r24, 0x01	; 1
    5788:	49 f4       	brne	.+18     	; 0x579c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    578a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    578c:	80 93 8b 01 	sts	0x018B, r24
		xTickCount = ( portTickType ) 0U;
    5790:	10 92 55 01 	sts	0x0155, r1
    5794:	10 92 54 01 	sts	0x0154, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5798:	0e 94 c0 2e 	call	0x5d80	; 0x5d80 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    579c:	0f 91       	pop	r16
    579e:	ff 90       	pop	r15
    57a0:	ef 90       	pop	r14
    57a2:	df 90       	pop	r13
    57a4:	cf 90       	pop	r12
    57a6:	bf 90       	pop	r11
    57a8:	af 90       	pop	r10
    57aa:	08 95       	ret

000057ac <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    57ac:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    57ae:	10 92 8b 01 	sts	0x018B, r1
	vPortEndScheduler();
    57b2:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <vPortEndScheduler>
}
    57b6:	08 95       	ret

000057b8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    57b8:	80 91 56 01 	lds	r24, 0x0156
    57bc:	8f 5f       	subi	r24, 0xFF	; 255
    57be:	80 93 56 01 	sts	0x0156, r24
}
    57c2:	08 95       	ret

000057c4 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    57c4:	0f b6       	in	r0, 0x3f	; 63
    57c6:	f8 94       	cli
    57c8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    57ca:	20 91 54 01 	lds	r18, 0x0154
    57ce:	30 91 55 01 	lds	r19, 0x0155
	}
	taskEXIT_CRITICAL();
    57d2:	0f 90       	pop	r0
    57d4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    57d6:	c9 01       	movw	r24, r18
    57d8:	08 95       	ret

000057da <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    57da:	20 91 54 01 	lds	r18, 0x0154
    57de:	30 91 55 01 	lds	r19, 0x0155
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    57e2:	c9 01       	movw	r24, r18
    57e4:	08 95       	ret

000057e6 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    57e6:	80 91 8a 01 	lds	r24, 0x018A
}
    57ea:	08 95       	ret

000057ec <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    57ec:	0f 93       	push	r16
    57ee:	1f 93       	push	r17
    57f0:	cf 93       	push	r28
    57f2:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    57f4:	80 91 56 01 	lds	r24, 0x0156
    57f8:	88 23       	and	r24, r24
    57fa:	09 f0       	breq	.+2      	; 0x57fe <vTaskIncrementTick+0x12>
    57fc:	8f c0       	rjmp	.+286    	; 0x591c <vTaskIncrementTick+0x130>
	{
		++xTickCount;
    57fe:	80 91 54 01 	lds	r24, 0x0154
    5802:	90 91 55 01 	lds	r25, 0x0155
    5806:	01 96       	adiw	r24, 0x01	; 1
    5808:	90 93 55 01 	sts	0x0155, r25
    580c:	80 93 54 01 	sts	0x0154, r24
		if( xTickCount == ( portTickType ) 0U )
    5810:	80 91 54 01 	lds	r24, 0x0154
    5814:	90 91 55 01 	lds	r25, 0x0155
    5818:	00 97       	sbiw	r24, 0x00	; 0
    581a:	79 f5       	brne	.+94     	; 0x587a <vTaskIncrementTick+0x8e>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    581c:	80 91 87 01 	lds	r24, 0x0187
    5820:	90 91 88 01 	lds	r25, 0x0188
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    5824:	20 91 85 01 	lds	r18, 0x0185
    5828:	30 91 86 01 	lds	r19, 0x0186
    582c:	30 93 88 01 	sts	0x0188, r19
    5830:	20 93 87 01 	sts	0x0187, r18
			pxOverflowDelayedTaskList = pxTemp;
    5834:	90 93 86 01 	sts	0x0186, r25
    5838:	80 93 85 01 	sts	0x0185, r24
			xNumOfOverflows++;
    583c:	80 91 53 01 	lds	r24, 0x0153
    5840:	8f 5f       	subi	r24, 0xFF	; 255
    5842:	80 93 53 01 	sts	0x0153, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5846:	e0 91 87 01 	lds	r30, 0x0187
    584a:	f0 91 88 01 	lds	r31, 0x0188
    584e:	80 81       	ld	r24, Z
    5850:	88 23       	and	r24, r24
    5852:	19 f4       	brne	.+6      	; 0x585a <vTaskIncrementTick+0x6e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    5854:	8f ef       	ldi	r24, 0xFF	; 255
    5856:	9f ef       	ldi	r25, 0xFF	; 255
    5858:	0c c0       	rjmp	.+24     	; 0x5872 <vTaskIncrementTick+0x86>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    585a:	e0 91 87 01 	lds	r30, 0x0187
    585e:	f0 91 88 01 	lds	r31, 0x0188
    5862:	05 80       	ldd	r0, Z+5	; 0x05
    5864:	f6 81       	ldd	r31, Z+6	; 0x06
    5866:	e0 2d       	mov	r30, r0
    5868:	06 80       	ldd	r0, Z+6	; 0x06
    586a:	f7 81       	ldd	r31, Z+7	; 0x07
    586c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    586e:	82 81       	ldd	r24, Z+2	; 0x02
    5870:	93 81       	ldd	r25, Z+3	; 0x03
    5872:	90 93 04 01 	sts	0x0104, r25
    5876:	80 93 03 01 	sts	0x0103, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    587a:	20 91 54 01 	lds	r18, 0x0154
    587e:	30 91 55 01 	lds	r19, 0x0155
    5882:	80 91 03 01 	lds	r24, 0x0103
    5886:	90 91 04 01 	lds	r25, 0x0104
    588a:	28 17       	cp	r18, r24
    588c:	39 07       	cpc	r19, r25
    588e:	08 f4       	brcc	.+2      	; 0x5892 <vTaskIncrementTick+0xa6>
    5890:	4a c0       	rjmp	.+148    	; 0x5926 <vTaskIncrementTick+0x13a>
    5892:	e0 91 87 01 	lds	r30, 0x0187
    5896:	f0 91 88 01 	lds	r31, 0x0188
    589a:	80 81       	ld	r24, Z
    589c:	88 23       	and	r24, r24
    589e:	19 f4       	brne	.+6      	; 0x58a6 <vTaskIncrementTick+0xba>
    58a0:	8f ef       	ldi	r24, 0xFF	; 255
    58a2:	9f ef       	ldi	r25, 0xFF	; 255
    58a4:	12 c0       	rjmp	.+36     	; 0x58ca <vTaskIncrementTick+0xde>
    58a6:	e0 91 87 01 	lds	r30, 0x0187
    58aa:	f0 91 88 01 	lds	r31, 0x0188
    58ae:	05 80       	ldd	r0, Z+5	; 0x05
    58b0:	f6 81       	ldd	r31, Z+6	; 0x06
    58b2:	e0 2d       	mov	r30, r0
    58b4:	c6 81       	ldd	r28, Z+6	; 0x06
    58b6:	d7 81       	ldd	r29, Z+7	; 0x07
    58b8:	8a 81       	ldd	r24, Y+2	; 0x02
    58ba:	9b 81       	ldd	r25, Y+3	; 0x03
    58bc:	20 91 54 01 	lds	r18, 0x0154
    58c0:	30 91 55 01 	lds	r19, 0x0155
    58c4:	28 17       	cp	r18, r24
    58c6:	39 07       	cpc	r19, r25
    58c8:	28 f4       	brcc	.+10     	; 0x58d4 <vTaskIncrementTick+0xe8>
    58ca:	90 93 04 01 	sts	0x0104, r25
    58ce:	80 93 03 01 	sts	0x0103, r24
    58d2:	29 c0       	rjmp	.+82     	; 0x5926 <vTaskIncrementTick+0x13a>
    58d4:	8e 01       	movw	r16, r28
    58d6:	0e 5f       	subi	r16, 0xFE	; 254
    58d8:	1f 4f       	sbci	r17, 0xFF	; 255
    58da:	c8 01       	movw	r24, r16
    58dc:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
    58e0:	8c 89       	ldd	r24, Y+20	; 0x14
    58e2:	9d 89       	ldd	r25, Y+21	; 0x15
    58e4:	00 97       	sbiw	r24, 0x00	; 0
    58e6:	21 f0       	breq	.+8      	; 0x58f0 <vTaskIncrementTick+0x104>
    58e8:	ce 01       	movw	r24, r28
    58ea:	0c 96       	adiw	r24, 0x0c	; 12
    58ec:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
    58f0:	2e 89       	ldd	r18, Y+22	; 0x16
    58f2:	80 91 57 01 	lds	r24, 0x0157
    58f6:	82 17       	cp	r24, r18
    58f8:	10 f4       	brcc	.+4      	; 0x58fe <vTaskIncrementTick+0x112>
    58fa:	20 93 57 01 	sts	0x0157, r18
    58fe:	30 e0       	ldi	r19, 0x00	; 0
    5900:	c9 01       	movw	r24, r18
    5902:	f3 e0       	ldi	r31, 0x03	; 3
    5904:	88 0f       	add	r24, r24
    5906:	99 1f       	adc	r25, r25
    5908:	fa 95       	dec	r31
    590a:	e1 f7       	brne	.-8      	; 0x5904 <vTaskIncrementTick+0x118>
    590c:	82 0f       	add	r24, r18
    590e:	93 1f       	adc	r25, r19
    5910:	88 5a       	subi	r24, 0xA8	; 168
    5912:	9e 4f       	sbci	r25, 0xFE	; 254
    5914:	b8 01       	movw	r22, r16
    5916:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>
    591a:	bb cf       	rjmp	.-138    	; 0x5892 <vTaskIncrementTick+0xa6>
	}
	else
	{
		++uxMissedTicks;
    591c:	80 91 89 01 	lds	r24, 0x0189
    5920:	8f 5f       	subi	r24, 0xFF	; 255
    5922:	80 93 89 01 	sts	0x0189, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5926:	df 91       	pop	r29
    5928:	cf 91       	pop	r28
    592a:	1f 91       	pop	r17
    592c:	0f 91       	pop	r16
    592e:	08 95       	ret

00005930 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    5930:	ef 92       	push	r14
    5932:	ff 92       	push	r15
    5934:	0f 93       	push	r16
    5936:	1f 93       	push	r17
    5938:	df 93       	push	r29
    593a:	cf 93       	push	r28
    593c:	0f 92       	push	r0
    593e:	cd b7       	in	r28, 0x3d	; 61
    5940:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5942:	0f b6       	in	r0, 0x3f	; 63
    5944:	f8 94       	cli
    5946:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5948:	80 91 56 01 	lds	r24, 0x0156
    594c:	81 50       	subi	r24, 0x01	; 1
    594e:	80 93 56 01 	sts	0x0156, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5952:	80 91 56 01 	lds	r24, 0x0156
    5956:	88 23       	and	r24, r24
    5958:	09 f0       	breq	.+2      	; 0x595c <xTaskResumeAll+0x2c>
    595a:	5e c0       	rjmp	.+188    	; 0x5a18 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    595c:	80 91 8a 01 	lds	r24, 0x018A
    5960:	88 23       	and	r24, r24
    5962:	09 f4       	brne	.+2      	; 0x5966 <xTaskResumeAll+0x36>
    5964:	59 c0       	rjmp	.+178    	; 0x5a18 <xTaskResumeAll+0xe8>
    5966:	19 82       	std	Y+1, r1	; 0x01
    5968:	35 c0       	rjmp	.+106    	; 0x59d4 <xTaskResumeAll+0xa4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    596a:	e0 91 81 01 	lds	r30, 0x0181
    596e:	f0 91 82 01 	lds	r31, 0x0182
    5972:	e6 80       	ldd	r14, Z+6	; 0x06
    5974:	f7 80       	ldd	r15, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    5976:	c7 01       	movw	r24, r14
    5978:	0c 96       	adiw	r24, 0x0c	; 12
    597a:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    597e:	87 01       	movw	r16, r14
    5980:	0e 5f       	subi	r16, 0xFE	; 254
    5982:	1f 4f       	sbci	r17, 0xFF	; 255
    5984:	c8 01       	movw	r24, r16
    5986:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    598a:	d7 01       	movw	r26, r14
    598c:	56 96       	adiw	r26, 0x16	; 22
    598e:	2c 91       	ld	r18, X
    5990:	56 97       	sbiw	r26, 0x16	; 22
    5992:	80 91 57 01 	lds	r24, 0x0157
    5996:	82 17       	cp	r24, r18
    5998:	10 f4       	brcc	.+4      	; 0x599e <xTaskResumeAll+0x6e>
    599a:	20 93 57 01 	sts	0x0157, r18
    599e:	30 e0       	ldi	r19, 0x00	; 0
    59a0:	c9 01       	movw	r24, r18
    59a2:	a3 e0       	ldi	r26, 0x03	; 3
    59a4:	88 0f       	add	r24, r24
    59a6:	99 1f       	adc	r25, r25
    59a8:	aa 95       	dec	r26
    59aa:	e1 f7       	brne	.-8      	; 0x59a4 <xTaskResumeAll+0x74>
    59ac:	82 0f       	add	r24, r18
    59ae:	93 1f       	adc	r25, r19
    59b0:	88 5a       	subi	r24, 0xA8	; 168
    59b2:	9e 4f       	sbci	r25, 0xFE	; 254
    59b4:	b8 01       	movw	r22, r16
    59b6:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    59ba:	e0 91 50 01 	lds	r30, 0x0150
    59be:	f0 91 51 01 	lds	r31, 0x0151
    59c2:	d7 01       	movw	r26, r14
    59c4:	56 96       	adiw	r26, 0x16	; 22
    59c6:	9c 91       	ld	r25, X
    59c8:	56 97       	sbiw	r26, 0x16	; 22
    59ca:	86 89       	ldd	r24, Z+22	; 0x16
    59cc:	98 17       	cp	r25, r24
    59ce:	10 f0       	brcs	.+4      	; 0x59d4 <xTaskResumeAll+0xa4>
					{
						xYieldRequired = pdTRUE;
    59d0:	b1 e0       	ldi	r27, 0x01	; 1
    59d2:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    59d4:	80 91 7c 01 	lds	r24, 0x017C
    59d8:	88 23       	and	r24, r24
    59da:	39 f6       	brne	.-114    	; 0x596a <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    59dc:	80 91 89 01 	lds	r24, 0x0189
    59e0:	88 23       	and	r24, r24
    59e2:	41 f4       	brne	.+16     	; 0x59f4 <xTaskResumeAll+0xc4>
    59e4:	0c c0       	rjmp	.+24     	; 0x59fe <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    59e6:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <vTaskIncrementTick>
						--uxMissedTicks;
    59ea:	80 91 89 01 	lds	r24, 0x0189
    59ee:	81 50       	subi	r24, 0x01	; 1
    59f0:	80 93 89 01 	sts	0x0189, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    59f4:	80 91 89 01 	lds	r24, 0x0189
    59f8:	88 23       	and	r24, r24
    59fa:	a9 f7       	brne	.-22     	; 0x59e6 <xTaskResumeAll+0xb6>
    59fc:	07 c0       	rjmp	.+14     	; 0x5a0c <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    59fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5a00:	e1 30       	cpi	r30, 0x01	; 1
    5a02:	21 f0       	breq	.+8      	; 0x5a0c <xTaskResumeAll+0xdc>
    5a04:	80 91 52 01 	lds	r24, 0x0152
    5a08:	81 30       	cpi	r24, 0x01	; 1
    5a0a:	31 f4       	brne	.+12     	; 0x5a18 <xTaskResumeAll+0xe8>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    5a0c:	10 92 52 01 	sts	0x0152, r1
					portYIELD_WITHIN_API();
    5a10:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    5a14:	81 e0       	ldi	r24, 0x01	; 1
    5a16:	01 c0       	rjmp	.+2      	; 0x5a1a <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5a18:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5a1a:	0f 90       	pop	r0
    5a1c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    5a1e:	0f 90       	pop	r0
    5a20:	cf 91       	pop	r28
    5a22:	df 91       	pop	r29
    5a24:	1f 91       	pop	r17
    5a26:	0f 91       	pop	r16
    5a28:	ff 90       	pop	r15
    5a2a:	ef 90       	pop	r14
    5a2c:	08 95       	ret

00005a2e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    5a2e:	0f 93       	push	r16
    5a30:	1f 93       	push	r17
    5a32:	cf 93       	push	r28
    5a34:	df 93       	push	r29
    5a36:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    5a38:	00 97       	sbiw	r24, 0x00	; 0
    5a3a:	b1 f0       	breq	.+44     	; 0x5a68 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    5a3c:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5a40:	00 91 54 01 	lds	r16, 0x0154
    5a44:	10 91 55 01 	lds	r17, 0x0155

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5a48:	80 91 50 01 	lds	r24, 0x0150
    5a4c:	90 91 51 01 	lds	r25, 0x0151
    5a50:	02 96       	adiw	r24, 0x02	; 2
    5a52:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5a56:	ce 01       	movw	r24, r28
    5a58:	80 0f       	add	r24, r16
    5a5a:	91 1f       	adc	r25, r17
    5a5c:	0e 94 60 2a 	call	0x54c0	; 0x54c0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5a60:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5a64:	88 23       	and	r24, r24
    5a66:	11 f4       	brne	.+4      	; 0x5a6c <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    5a68:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
		}
	}
    5a6c:	df 91       	pop	r29
    5a6e:	cf 91       	pop	r28
    5a70:	1f 91       	pop	r17
    5a72:	0f 91       	pop	r16
    5a74:	08 95       	ret

00005a76 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    5a76:	0f 93       	push	r16
    5a78:	1f 93       	push	r17
    5a7a:	cf 93       	push	r28
    5a7c:	df 93       	push	r29
    5a7e:	8c 01       	movw	r16, r24
    5a80:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    5a82:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5a86:	f8 01       	movw	r30, r16
    5a88:	80 81       	ld	r24, Z
    5a8a:	91 81       	ldd	r25, Z+1	; 0x01
    5a8c:	c8 0f       	add	r28, r24
    5a8e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    5a90:	20 91 54 01 	lds	r18, 0x0154
    5a94:	30 91 55 01 	lds	r19, 0x0155
    5a98:	28 17       	cp	r18, r24
    5a9a:	39 07       	cpc	r19, r25
    5a9c:	20 f4       	brcc	.+8      	; 0x5aa6 <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    5a9e:	c8 17       	cp	r28, r24
    5aa0:	d9 07       	cpc	r29, r25
    5aa2:	60 f4       	brcc	.+24     	; 0x5abc <vTaskDelayUntil+0x46>
    5aa4:	03 c0       	rjmp	.+6      	; 0x5aac <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    5aa6:	c8 17       	cp	r28, r24
    5aa8:	d9 07       	cpc	r29, r25
    5aaa:	50 f0       	brcs	.+20     	; 0x5ac0 <vTaskDelayUntil+0x4a>
    5aac:	80 91 54 01 	lds	r24, 0x0154
    5ab0:	90 91 55 01 	lds	r25, 0x0155
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    5ab4:	21 e0       	ldi	r18, 0x01	; 1
    5ab6:	8c 17       	cp	r24, r28
    5ab8:	9d 07       	cpc	r25, r29
    5aba:	18 f0       	brcs	.+6      	; 0x5ac2 <vTaskDelayUntil+0x4c>
    5abc:	20 e0       	ldi	r18, 0x00	; 0
    5abe:	01 c0       	rjmp	.+2      	; 0x5ac2 <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    5ac0:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    5ac2:	f8 01       	movw	r30, r16
    5ac4:	d1 83       	std	Z+1, r29	; 0x01
    5ac6:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    5ac8:	22 23       	and	r18, r18
    5aca:	51 f0       	breq	.+20     	; 0x5ae0 <vTaskDelayUntil+0x6a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5acc:	80 91 50 01 	lds	r24, 0x0150
    5ad0:	90 91 51 01 	lds	r25, 0x0151
    5ad4:	02 96       	adiw	r24, 0x02	; 2
    5ad6:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5ada:	ce 01       	movw	r24, r28
    5adc:	0e 94 60 2a 	call	0x54c0	; 0x54c0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    5ae0:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5ae4:	88 23       	and	r24, r24
    5ae6:	11 f4       	brne	.+4      	; 0x5aec <vTaskDelayUntil+0x76>
		{
			portYIELD_WITHIN_API();
    5ae8:	0e 94 f6 2e 	call	0x5dec	; 0x5dec <vPortYield>
		}
	}
    5aec:	df 91       	pop	r29
    5aee:	cf 91       	pop	r28
    5af0:	1f 91       	pop	r17
    5af2:	0f 91       	pop	r16
    5af4:	08 95       	ret

00005af6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    5af6:	80 91 56 01 	lds	r24, 0x0156
    5afa:	88 23       	and	r24, r24
    5afc:	49 f0       	breq	.+18     	; 0x5b10 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5afe:	81 e0       	ldi	r24, 0x01	; 1
    5b00:	80 93 52 01 	sts	0x0152, r24
    5b04:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    5b06:	80 91 57 01 	lds	r24, 0x0157
    5b0a:	81 50       	subi	r24, 0x01	; 1
    5b0c:	80 93 57 01 	sts	0x0157, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    5b10:	80 91 57 01 	lds	r24, 0x0157
    5b14:	90 e0       	ldi	r25, 0x00	; 0
    5b16:	fc 01       	movw	r30, r24
    5b18:	53 e0       	ldi	r21, 0x03	; 3
    5b1a:	ee 0f       	add	r30, r30
    5b1c:	ff 1f       	adc	r31, r31
    5b1e:	5a 95       	dec	r21
    5b20:	e1 f7       	brne	.-8      	; 0x5b1a <vTaskSwitchContext+0x24>
    5b22:	e8 0f       	add	r30, r24
    5b24:	f9 1f       	adc	r31, r25
    5b26:	e8 5a       	subi	r30, 0xA8	; 168
    5b28:	fe 4f       	sbci	r31, 0xFE	; 254
    5b2a:	80 81       	ld	r24, Z
    5b2c:	88 23       	and	r24, r24
    5b2e:	59 f3       	breq	.-42     	; 0x5b06 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5b30:	80 91 57 01 	lds	r24, 0x0157
    5b34:	90 e0       	ldi	r25, 0x00	; 0
    5b36:	9c 01       	movw	r18, r24
    5b38:	43 e0       	ldi	r20, 0x03	; 3
    5b3a:	22 0f       	add	r18, r18
    5b3c:	33 1f       	adc	r19, r19
    5b3e:	4a 95       	dec	r20
    5b40:	e1 f7       	brne	.-8      	; 0x5b3a <vTaskSwitchContext+0x44>
    5b42:	28 0f       	add	r18, r24
    5b44:	39 1f       	adc	r19, r25
    5b46:	f9 01       	movw	r30, r18
    5b48:	e8 5a       	subi	r30, 0xA8	; 168
    5b4a:	fe 4f       	sbci	r31, 0xFE	; 254
    5b4c:	a1 81       	ldd	r26, Z+1	; 0x01
    5b4e:	b2 81       	ldd	r27, Z+2	; 0x02
    5b50:	12 96       	adiw	r26, 0x02	; 2
    5b52:	0d 90       	ld	r0, X+
    5b54:	bc 91       	ld	r27, X
    5b56:	a0 2d       	mov	r26, r0
    5b58:	b2 83       	std	Z+2, r27	; 0x02
    5b5a:	a1 83       	std	Z+1, r26	; 0x01
    5b5c:	25 5a       	subi	r18, 0xA5	; 165
    5b5e:	3e 4f       	sbci	r19, 0xFE	; 254
    5b60:	a2 17       	cp	r26, r18
    5b62:	b3 07       	cpc	r27, r19
    5b64:	31 f4       	brne	.+12     	; 0x5b72 <vTaskSwitchContext+0x7c>
    5b66:	12 96       	adiw	r26, 0x02	; 2
    5b68:	2d 91       	ld	r18, X+
    5b6a:	3c 91       	ld	r19, X
    5b6c:	13 97       	sbiw	r26, 0x03	; 3
    5b6e:	32 83       	std	Z+2, r19	; 0x02
    5b70:	21 83       	std	Z+1, r18	; 0x01
    5b72:	fc 01       	movw	r30, r24
    5b74:	b3 e0       	ldi	r27, 0x03	; 3
    5b76:	ee 0f       	add	r30, r30
    5b78:	ff 1f       	adc	r31, r31
    5b7a:	ba 95       	dec	r27
    5b7c:	e1 f7       	brne	.-8      	; 0x5b76 <vTaskSwitchContext+0x80>
    5b7e:	e8 0f       	add	r30, r24
    5b80:	f9 1f       	adc	r31, r25
    5b82:	e8 5a       	subi	r30, 0xA8	; 168
    5b84:	fe 4f       	sbci	r31, 0xFE	; 254
    5b86:	01 80       	ldd	r0, Z+1	; 0x01
    5b88:	f2 81       	ldd	r31, Z+2	; 0x02
    5b8a:	e0 2d       	mov	r30, r0
    5b8c:	86 81       	ldd	r24, Z+6	; 0x06
    5b8e:	97 81       	ldd	r25, Z+7	; 0x07
    5b90:	90 93 51 01 	sts	0x0151, r25
    5b94:	80 93 50 01 	sts	0x0150, r24
    5b98:	08 95       	ret

00005b9a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5b9a:	cf 93       	push	r28
    5b9c:	df 93       	push	r29
    5b9e:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5ba0:	60 91 50 01 	lds	r22, 0x0150
    5ba4:	70 91 51 01 	lds	r23, 0x0151
    5ba8:	64 5f       	subi	r22, 0xF4	; 244
    5baa:	7f 4f       	sbci	r23, 0xFF	; 255
    5bac:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5bb0:	80 91 50 01 	lds	r24, 0x0150
    5bb4:	90 91 51 01 	lds	r25, 0x0151
    5bb8:	02 96       	adiw	r24, 0x02	; 2
    5bba:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    5bbe:	80 91 54 01 	lds	r24, 0x0154
    5bc2:	90 91 55 01 	lds	r25, 0x0155
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5bc6:	8c 0f       	add	r24, r28
    5bc8:	9d 1f       	adc	r25, r29
    5bca:	0e 94 60 2a 	call	0x54c0	; 0x54c0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    5bce:	df 91       	pop	r29
    5bd0:	cf 91       	pop	r28
    5bd2:	08 95       	ret

00005bd4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    5bd4:	0f 93       	push	r16
    5bd6:	1f 93       	push	r17
    5bd8:	cf 93       	push	r28
    5bda:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5bdc:	dc 01       	movw	r26, r24
    5bde:	15 96       	adiw	r26, 0x05	; 5
    5be0:	ed 91       	ld	r30, X+
    5be2:	fc 91       	ld	r31, X
    5be4:	16 97       	sbiw	r26, 0x06	; 6
    5be6:	c6 81       	ldd	r28, Z+6	; 0x06
    5be8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5bea:	8e 01       	movw	r16, r28
    5bec:	04 5f       	subi	r16, 0xF4	; 244
    5bee:	1f 4f       	sbci	r17, 0xFF	; 255
    5bf0:	c8 01       	movw	r24, r16
    5bf2:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5bf6:	80 91 56 01 	lds	r24, 0x0156
    5bfa:	88 23       	and	r24, r24
    5bfc:	c9 f4       	brne	.+50     	; 0x5c30 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5bfe:	8e 01       	movw	r16, r28
    5c00:	0e 5f       	subi	r16, 0xFE	; 254
    5c02:	1f 4f       	sbci	r17, 0xFF	; 255
    5c04:	c8 01       	movw	r24, r16
    5c06:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    5c0a:	2e 89       	ldd	r18, Y+22	; 0x16
    5c0c:	80 91 57 01 	lds	r24, 0x0157
    5c10:	82 17       	cp	r24, r18
    5c12:	10 f4       	brcc	.+4      	; 0x5c18 <xTaskRemoveFromEventList+0x44>
    5c14:	20 93 57 01 	sts	0x0157, r18
    5c18:	30 e0       	ldi	r19, 0x00	; 0
    5c1a:	c9 01       	movw	r24, r18
    5c1c:	63 e0       	ldi	r22, 0x03	; 3
    5c1e:	88 0f       	add	r24, r24
    5c20:	99 1f       	adc	r25, r25
    5c22:	6a 95       	dec	r22
    5c24:	e1 f7       	brne	.-8      	; 0x5c1e <xTaskRemoveFromEventList+0x4a>
    5c26:	82 0f       	add	r24, r18
    5c28:	93 1f       	adc	r25, r19
    5c2a:	88 5a       	subi	r24, 0xA8	; 168
    5c2c:	9e 4f       	sbci	r25, 0xFE	; 254
    5c2e:	02 c0       	rjmp	.+4      	; 0x5c34 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5c30:	8c e7       	ldi	r24, 0x7C	; 124
    5c32:	91 e0       	ldi	r25, 0x01	; 1
    5c34:	b8 01       	movw	r22, r16
    5c36:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5c3a:	e0 91 50 01 	lds	r30, 0x0150
    5c3e:	f0 91 51 01 	lds	r31, 0x0151
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    5c42:	81 e0       	ldi	r24, 0x01	; 1
    5c44:	2e 89       	ldd	r18, Y+22	; 0x16
    5c46:	96 89       	ldd	r25, Z+22	; 0x16
    5c48:	29 17       	cp	r18, r25
    5c4a:	08 f4       	brcc	.+2      	; 0x5c4e <xTaskRemoveFromEventList+0x7a>
    5c4c:	80 e0       	ldi	r24, 0x00	; 0
}
    5c4e:	df 91       	pop	r29
    5c50:	cf 91       	pop	r28
    5c52:	1f 91       	pop	r17
    5c54:	0f 91       	pop	r16
    5c56:	08 95       	ret

00005c58 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5c58:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5c5a:	80 91 53 01 	lds	r24, 0x0153
    5c5e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5c60:	80 91 54 01 	lds	r24, 0x0154
    5c64:	90 91 55 01 	lds	r25, 0x0155
    5c68:	92 83       	std	Z+2, r25	; 0x02
    5c6a:	81 83       	std	Z+1, r24	; 0x01
}
    5c6c:	08 95       	ret

00005c6e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5c6e:	fc 01       	movw	r30, r24
    5c70:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5c72:	0f b6       	in	r0, 0x3f	; 63
    5c74:	f8 94       	cli
    5c76:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    5c78:	90 91 53 01 	lds	r25, 0x0153
    5c7c:	80 81       	ld	r24, Z
    5c7e:	98 17       	cp	r25, r24
    5c80:	49 f0       	breq	.+18     	; 0x5c94 <xTaskCheckForTimeOut+0x26>
    5c82:	20 91 54 01 	lds	r18, 0x0154
    5c86:	30 91 55 01 	lds	r19, 0x0155
    5c8a:	81 81       	ldd	r24, Z+1	; 0x01
    5c8c:	92 81       	ldd	r25, Z+2	; 0x02
    5c8e:	28 17       	cp	r18, r24
    5c90:	39 07       	cpc	r19, r25
    5c92:	20 f5       	brcc	.+72     	; 0x5cdc <xTaskCheckForTimeOut+0x6e>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5c94:	20 91 54 01 	lds	r18, 0x0154
    5c98:	30 91 55 01 	lds	r19, 0x0155
    5c9c:	81 81       	ldd	r24, Z+1	; 0x01
    5c9e:	92 81       	ldd	r25, Z+2	; 0x02
    5ca0:	4d 91       	ld	r20, X+
    5ca2:	5c 91       	ld	r21, X
    5ca4:	11 97       	sbiw	r26, 0x01	; 1
    5ca6:	28 1b       	sub	r18, r24
    5ca8:	39 0b       	sbc	r19, r25
    5caa:	24 17       	cp	r18, r20
    5cac:	35 07       	cpc	r19, r21
    5cae:	b0 f4       	brcc	.+44     	; 0x5cdc <xTaskCheckForTimeOut+0x6e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5cb0:	20 91 54 01 	lds	r18, 0x0154
    5cb4:	30 91 55 01 	lds	r19, 0x0155
    5cb8:	82 1b       	sub	r24, r18
    5cba:	93 0b       	sbc	r25, r19
    5cbc:	84 0f       	add	r24, r20
    5cbe:	95 1f       	adc	r25, r21
    5cc0:	11 96       	adiw	r26, 0x01	; 1
    5cc2:	9c 93       	st	X, r25
    5cc4:	8e 93       	st	-X, r24
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5cc6:	80 91 53 01 	lds	r24, 0x0153
    5cca:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5ccc:	80 91 54 01 	lds	r24, 0x0154
    5cd0:	90 91 55 01 	lds	r25, 0x0155
    5cd4:	92 83       	std	Z+2, r25	; 0x02
    5cd6:	81 83       	std	Z+1, r24	; 0x01
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    5cd8:	80 e0       	ldi	r24, 0x00	; 0
    5cda:	01 c0       	rjmp	.+2      	; 0x5cde <xTaskCheckForTimeOut+0x70>
		}
		else
		{
			xReturn = pdTRUE;
    5cdc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    5cde:	0f 90       	pop	r0
    5ce0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    5ce2:	08 95       	ret

00005ce4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    5ce4:	81 e0       	ldi	r24, 0x01	; 1
    5ce6:	80 93 52 01 	sts	0x0152, r24
}
    5cea:	08 95       	ret

00005cec <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    5cec:	21 e1       	ldi	r18, 0x11	; 17
    5cee:	fc 01       	movw	r30, r24
    5cf0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    5cf2:	92 e2       	ldi	r25, 0x22	; 34
    5cf4:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    5cf6:	83 e3       	ldi	r24, 0x33	; 51
    5cf8:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5cfa:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5cfc:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    5cfe:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    5d00:	80 e8       	ldi	r24, 0x80	; 128
    5d02:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    5d04:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    5d06:	82 e0       	ldi	r24, 0x02	; 2
    5d08:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    5d0a:	83 e0       	ldi	r24, 0x03	; 3
    5d0c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    5d0e:	84 e0       	ldi	r24, 0x04	; 4
    5d10:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    5d12:	85 e0       	ldi	r24, 0x05	; 5
    5d14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    5d16:	86 e0       	ldi	r24, 0x06	; 6
    5d18:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    5d1a:	87 e0       	ldi	r24, 0x07	; 7
    5d1c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    5d1e:	88 e0       	ldi	r24, 0x08	; 8
    5d20:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    5d22:	89 e0       	ldi	r24, 0x09	; 9
    5d24:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    5d26:	80 e1       	ldi	r24, 0x10	; 16
    5d28:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    5d2a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    5d2c:	82 e1       	ldi	r24, 0x12	; 18
    5d2e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    5d30:	83 e1       	ldi	r24, 0x13	; 19
    5d32:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    5d34:	84 e1       	ldi	r24, 0x14	; 20
    5d36:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    5d38:	85 e1       	ldi	r24, 0x15	; 21
    5d3a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5d3c:	86 e1       	ldi	r24, 0x16	; 22
    5d3e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    5d40:	87 e1       	ldi	r24, 0x17	; 23
    5d42:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5d44:	88 e1       	ldi	r24, 0x18	; 24
    5d46:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    5d48:	89 e1       	ldi	r24, 0x19	; 25
    5d4a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    5d4c:	80 e2       	ldi	r24, 0x20	; 32
    5d4e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    5d50:	81 e2       	ldi	r24, 0x21	; 33
    5d52:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    5d54:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    5d56:	83 e2       	ldi	r24, 0x23	; 35
    5d58:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5d5a:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5d5c:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    5d5e:	86 e2       	ldi	r24, 0x26	; 38
    5d60:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    5d62:	87 e2       	ldi	r24, 0x27	; 39
    5d64:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    5d66:	88 e2       	ldi	r24, 0x28	; 40
    5d68:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5d6a:	89 e2       	ldi	r24, 0x29	; 41
    5d6c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5d6e:	80 e3       	ldi	r24, 0x30	; 48
    5d70:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5d72:	81 e3       	ldi	r24, 0x31	; 49
    5d74:	82 93       	st	-Z, r24
	pxTopOfStack--;
    5d76:	9f 01       	movw	r18, r30
    5d78:	21 50       	subi	r18, 0x01	; 1
    5d7a:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    5d7c:	c9 01       	movw	r24, r18
    5d7e:	08 95       	ret

00005d80 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    5d80:	89 e0       	ldi	r24, 0x09	; 9
    5d82:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    5d84:	9f e5       	ldi	r25, 0x5F	; 95
    5d86:	9a bd       	out	0x2a, r25	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    5d88:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5d8a:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5d8c:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    5d8e:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5d90:	a0 91 50 01 	lds	r26, 0x0150
    5d94:	b0 91 51 01 	lds	r27, 0x0151
    5d98:	cd 91       	ld	r28, X+
    5d9a:	cd bf       	out	0x3d, r28	; 61
    5d9c:	dd 91       	ld	r29, X+
    5d9e:	de bf       	out	0x3e, r29	; 62
    5da0:	ff 91       	pop	r31
    5da2:	ef 91       	pop	r30
    5da4:	df 91       	pop	r29
    5da6:	cf 91       	pop	r28
    5da8:	bf 91       	pop	r27
    5daa:	af 91       	pop	r26
    5dac:	9f 91       	pop	r25
    5dae:	8f 91       	pop	r24
    5db0:	7f 91       	pop	r23
    5db2:	6f 91       	pop	r22
    5db4:	5f 91       	pop	r21
    5db6:	4f 91       	pop	r20
    5db8:	3f 91       	pop	r19
    5dba:	2f 91       	pop	r18
    5dbc:	1f 91       	pop	r17
    5dbe:	0f 91       	pop	r16
    5dc0:	ff 90       	pop	r15
    5dc2:	ef 90       	pop	r14
    5dc4:	df 90       	pop	r13
    5dc6:	cf 90       	pop	r12
    5dc8:	bf 90       	pop	r11
    5dca:	af 90       	pop	r10
    5dcc:	9f 90       	pop	r9
    5dce:	8f 90       	pop	r8
    5dd0:	7f 90       	pop	r7
    5dd2:	6f 90       	pop	r6
    5dd4:	5f 90       	pop	r5
    5dd6:	4f 90       	pop	r4
    5dd8:	3f 90       	pop	r3
    5dda:	2f 90       	pop	r2
    5ddc:	1f 90       	pop	r1
    5dde:	0f 90       	pop	r0
    5de0:	0f be       	out	0x3f, r0	; 63
    5de2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5de4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    5de6:	81 e0       	ldi	r24, 0x01	; 1
    5de8:	08 95       	ret

00005dea <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5dea:	08 95       	ret

00005dec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5dec:	0f 92       	push	r0
    5dee:	0f b6       	in	r0, 0x3f	; 63
    5df0:	f8 94       	cli
    5df2:	0f 92       	push	r0
    5df4:	1f 92       	push	r1
    5df6:	11 24       	eor	r1, r1
    5df8:	2f 92       	push	r2
    5dfa:	3f 92       	push	r3
    5dfc:	4f 92       	push	r4
    5dfe:	5f 92       	push	r5
    5e00:	6f 92       	push	r6
    5e02:	7f 92       	push	r7
    5e04:	8f 92       	push	r8
    5e06:	9f 92       	push	r9
    5e08:	af 92       	push	r10
    5e0a:	bf 92       	push	r11
    5e0c:	cf 92       	push	r12
    5e0e:	df 92       	push	r13
    5e10:	ef 92       	push	r14
    5e12:	ff 92       	push	r15
    5e14:	0f 93       	push	r16
    5e16:	1f 93       	push	r17
    5e18:	2f 93       	push	r18
    5e1a:	3f 93       	push	r19
    5e1c:	4f 93       	push	r20
    5e1e:	5f 93       	push	r21
    5e20:	6f 93       	push	r22
    5e22:	7f 93       	push	r23
    5e24:	8f 93       	push	r24
    5e26:	9f 93       	push	r25
    5e28:	af 93       	push	r26
    5e2a:	bf 93       	push	r27
    5e2c:	cf 93       	push	r28
    5e2e:	df 93       	push	r29
    5e30:	ef 93       	push	r30
    5e32:	ff 93       	push	r31
    5e34:	a0 91 50 01 	lds	r26, 0x0150
    5e38:	b0 91 51 01 	lds	r27, 0x0151
    5e3c:	0d b6       	in	r0, 0x3d	; 61
    5e3e:	0d 92       	st	X+, r0
    5e40:	0e b6       	in	r0, 0x3e	; 62
    5e42:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5e44:	0e 94 7b 2d 	call	0x5af6	; 0x5af6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5e48:	a0 91 50 01 	lds	r26, 0x0150
    5e4c:	b0 91 51 01 	lds	r27, 0x0151
    5e50:	cd 91       	ld	r28, X+
    5e52:	cd bf       	out	0x3d, r28	; 61
    5e54:	dd 91       	ld	r29, X+
    5e56:	de bf       	out	0x3e, r29	; 62
    5e58:	ff 91       	pop	r31
    5e5a:	ef 91       	pop	r30
    5e5c:	df 91       	pop	r29
    5e5e:	cf 91       	pop	r28
    5e60:	bf 91       	pop	r27
    5e62:	af 91       	pop	r26
    5e64:	9f 91       	pop	r25
    5e66:	8f 91       	pop	r24
    5e68:	7f 91       	pop	r23
    5e6a:	6f 91       	pop	r22
    5e6c:	5f 91       	pop	r21
    5e6e:	4f 91       	pop	r20
    5e70:	3f 91       	pop	r19
    5e72:	2f 91       	pop	r18
    5e74:	1f 91       	pop	r17
    5e76:	0f 91       	pop	r16
    5e78:	ff 90       	pop	r15
    5e7a:	ef 90       	pop	r14
    5e7c:	df 90       	pop	r13
    5e7e:	cf 90       	pop	r12
    5e80:	bf 90       	pop	r11
    5e82:	af 90       	pop	r10
    5e84:	9f 90       	pop	r9
    5e86:	8f 90       	pop	r8
    5e88:	7f 90       	pop	r7
    5e8a:	6f 90       	pop	r6
    5e8c:	5f 90       	pop	r5
    5e8e:	4f 90       	pop	r4
    5e90:	3f 90       	pop	r3
    5e92:	2f 90       	pop	r2
    5e94:	1f 90       	pop	r1
    5e96:	0f 90       	pop	r0
    5e98:	0f be       	out	0x3f, r0	; 63
    5e9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5e9c:	08 95       	ret

00005e9e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    5e9e:	0f 92       	push	r0
    5ea0:	0f b6       	in	r0, 0x3f	; 63
    5ea2:	f8 94       	cli
    5ea4:	0f 92       	push	r0
    5ea6:	1f 92       	push	r1
    5ea8:	11 24       	eor	r1, r1
    5eaa:	2f 92       	push	r2
    5eac:	3f 92       	push	r3
    5eae:	4f 92       	push	r4
    5eb0:	5f 92       	push	r5
    5eb2:	6f 92       	push	r6
    5eb4:	7f 92       	push	r7
    5eb6:	8f 92       	push	r8
    5eb8:	9f 92       	push	r9
    5eba:	af 92       	push	r10
    5ebc:	bf 92       	push	r11
    5ebe:	cf 92       	push	r12
    5ec0:	df 92       	push	r13
    5ec2:	ef 92       	push	r14
    5ec4:	ff 92       	push	r15
    5ec6:	0f 93       	push	r16
    5ec8:	1f 93       	push	r17
    5eca:	2f 93       	push	r18
    5ecc:	3f 93       	push	r19
    5ece:	4f 93       	push	r20
    5ed0:	5f 93       	push	r21
    5ed2:	6f 93       	push	r22
    5ed4:	7f 93       	push	r23
    5ed6:	8f 93       	push	r24
    5ed8:	9f 93       	push	r25
    5eda:	af 93       	push	r26
    5edc:	bf 93       	push	r27
    5ede:	cf 93       	push	r28
    5ee0:	df 93       	push	r29
    5ee2:	ef 93       	push	r30
    5ee4:	ff 93       	push	r31
    5ee6:	a0 91 50 01 	lds	r26, 0x0150
    5eea:	b0 91 51 01 	lds	r27, 0x0151
    5eee:	0d b6       	in	r0, 0x3d	; 61
    5ef0:	0d 92       	st	X+, r0
    5ef2:	0e b6       	in	r0, 0x3e	; 62
    5ef4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    5ef6:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <vTaskIncrementTick>
	vTaskSwitchContext();
    5efa:	0e 94 7b 2d 	call	0x5af6	; 0x5af6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5efe:	a0 91 50 01 	lds	r26, 0x0150
    5f02:	b0 91 51 01 	lds	r27, 0x0151
    5f06:	cd 91       	ld	r28, X+
    5f08:	cd bf       	out	0x3d, r28	; 61
    5f0a:	dd 91       	ld	r29, X+
    5f0c:	de bf       	out	0x3e, r29	; 62
    5f0e:	ff 91       	pop	r31
    5f10:	ef 91       	pop	r30
    5f12:	df 91       	pop	r29
    5f14:	cf 91       	pop	r28
    5f16:	bf 91       	pop	r27
    5f18:	af 91       	pop	r26
    5f1a:	9f 91       	pop	r25
    5f1c:	8f 91       	pop	r24
    5f1e:	7f 91       	pop	r23
    5f20:	6f 91       	pop	r22
    5f22:	5f 91       	pop	r21
    5f24:	4f 91       	pop	r20
    5f26:	3f 91       	pop	r19
    5f28:	2f 91       	pop	r18
    5f2a:	1f 91       	pop	r17
    5f2c:	0f 91       	pop	r16
    5f2e:	ff 90       	pop	r15
    5f30:	ef 90       	pop	r14
    5f32:	df 90       	pop	r13
    5f34:	cf 90       	pop	r12
    5f36:	bf 90       	pop	r11
    5f38:	af 90       	pop	r10
    5f3a:	9f 90       	pop	r9
    5f3c:	8f 90       	pop	r8
    5f3e:	7f 90       	pop	r7
    5f40:	6f 90       	pop	r6
    5f42:	5f 90       	pop	r5
    5f44:	4f 90       	pop	r4
    5f46:	3f 90       	pop	r3
    5f48:	2f 90       	pop	r2
    5f4a:	1f 90       	pop	r1
    5f4c:	0f 90       	pop	r0
    5f4e:	0f be       	out	0x3f, r0	; 63
    5f50:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5f52:	08 95       	ret

00005f54 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5f54:	0e 94 4f 2f 	call	0x5e9e	; 0x5e9e <vPortYieldFromTick>
		asm volatile ( "reti" );
    5f58:	18 95       	reti

00005f5a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5f5a:	ef 92       	push	r14
    5f5c:	ff 92       	push	r15
    5f5e:	0f 93       	push	r16
    5f60:	1f 93       	push	r17
    5f62:	cf 93       	push	r28
    5f64:	df 93       	push	r29
    5f66:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    5f68:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    5f6c:	c0 91 a0 01 	lds	r28, 0x01A0
    5f70:	d0 91 a1 01 	lds	r29, 0x01A1
    5f74:	0c 0f       	add	r16, r28
    5f76:	1d 1f       	adc	r17, r29
    5f78:	25 e0       	ldi	r18, 0x05	; 5
    5f7a:	0c 3d       	cpi	r16, 0xDC	; 220
    5f7c:	12 07       	cpc	r17, r18
    5f7e:	50 f4       	brcc	.+20     	; 0x5f94 <pvPortMalloc+0x3a>
    5f80:	c0 17       	cp	r28, r16
    5f82:	d1 07       	cpc	r29, r17
    5f84:	38 f4       	brcc	.+14     	; 0x5f94 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    5f86:	ce 55       	subi	r28, 0x5E	; 94
    5f88:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
    5f8a:	10 93 a1 01 	sts	0x01A1, r17
    5f8e:	00 93 a0 01 	sts	0x01A0, r16
    5f92:	02 c0       	rjmp	.+4      	; 0x5f98 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    5f94:	c0 e0       	ldi	r28, 0x00	; 0
    5f96:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    5f98:	0e 94 98 2c 	call	0x5930	; 0x5930 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    5f9c:	ce 01       	movw	r24, r28
    5f9e:	df 91       	pop	r29
    5fa0:	cf 91       	pop	r28
    5fa2:	1f 91       	pop	r17
    5fa4:	0f 91       	pop	r16
    5fa6:	ff 90       	pop	r15
    5fa8:	ef 90       	pop	r14
    5faa:	08 95       	ret

00005fac <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    5fac:	08 95       	ret

00005fae <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    5fae:	10 92 a1 01 	sts	0x01A1, r1
    5fb2:	10 92 a0 01 	sts	0x01A0, r1
}
    5fb6:	08 95       	ret

00005fb8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    5fb8:	2c ed       	ldi	r18, 0xDC	; 220
    5fba:	35 e0       	ldi	r19, 0x05	; 5
    5fbc:	80 91 a0 01 	lds	r24, 0x01A0
    5fc0:	90 91 a1 01 	lds	r25, 0x01A1
    5fc4:	28 1b       	sub	r18, r24
    5fc6:	39 0b       	sbc	r19, r25
}
    5fc8:	c9 01       	movw	r24, r18
    5fca:	08 95       	ret

00005fcc <i2c_transmit>:
#include <util/twi.h>

void i2c_transmit(char address, char reg, char data)
{
	TWCR = 0xA4;                                                  // send a start bit on i2c bus
    5fcc:	94 ea       	ldi	r25, 0xA4	; 164
    5fce:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5fd0:	06 b6       	in	r0, 0x36	; 54
    5fd2:	07 fe       	sbrs	r0, 7
    5fd4:	fd cf       	rjmp	.-6      	; 0x5fd0 <i2c_transmit+0x4>
	TWDR = address;                                               // load address of i2c device
    5fd6:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                  // transmit
    5fd8:	84 e8       	ldi	r24, 0x84	; 132
    5fda:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5fdc:	06 b6       	in	r0, 0x36	; 54
    5fde:	07 fe       	sbrs	r0, 7
    5fe0:	fd cf       	rjmp	.-6      	; 0x5fdc <i2c_transmit+0x10>
	TWDR = reg;
    5fe2:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                                                  // transmit
    5fe4:	84 e8       	ldi	r24, 0x84	; 132
    5fe6:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5fe8:	06 b6       	in	r0, 0x36	; 54
    5fea:	07 fe       	sbrs	r0, 7
    5fec:	fd cf       	rjmp	.-6      	; 0x5fe8 <i2c_transmit+0x1c>
	TWDR = data;
    5fee:	43 b9       	out	0x03, r20	; 3
	TWCR = 0x84;                                                  // transmit
    5ff0:	84 e8       	ldi	r24, 0x84	; 132
    5ff2:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5ff4:	06 b6       	in	r0, 0x36	; 54
    5ff6:	07 fe       	sbrs	r0, 7
    5ff8:	fd cf       	rjmp	.-6      	; 0x5ff4 <i2c_transmit+0x28>
	TWCR = 0x94;                                                  // stop bit
    5ffa:	84 e9       	ldi	r24, 0x94	; 148
    5ffc:	86 bf       	out	0x36, r24	; 54
}
    5ffe:	08 95       	ret

00006000 <i2cRead>:

unsigned char i2cRead(char address, char reg)
{
   char read_data = 0;

   TWCR = 0xA4;                                                  // send a start bit on i2c bus
    6000:	94 ea       	ldi	r25, 0xA4	; 164
    6002:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit  
    6004:	06 b6       	in	r0, 0x36	; 54
    6006:	07 fe       	sbrs	r0, 7
    6008:	fd cf       	rjmp	.-6      	; 0x6004 <i2cRead+0x4>
   TWDR = address;                                               // load address of i2c device
    600a:	83 b9       	out	0x03, r24	; 3
   TWCR = 0x84;                                                  // transmit 
    600c:	94 e8       	ldi	r25, 0x84	; 132
    600e:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    6010:	06 b6       	in	r0, 0x36	; 54
    6012:	07 fe       	sbrs	r0, 7
    6014:	fd cf       	rjmp	.-6      	; 0x6010 <i2cRead+0x10>
   TWDR = reg;                                                   // send register number to read from
    6016:	63 b9       	out	0x03, r22	; 3
   TWCR = 0x84;                                                  // transmit
    6018:	94 e8       	ldi	r25, 0x84	; 132
    601a:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    601c:	06 b6       	in	r0, 0x36	; 54
    601e:	07 fe       	sbrs	r0, 7
    6020:	fd cf       	rjmp	.-6      	; 0x601c <i2cRead+0x1c>

   TWCR = 0xA4;                                                  // send repeated start bit
    6022:	94 ea       	ldi	r25, 0xA4	; 164
    6024:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    6026:	06 b6       	in	r0, 0x36	; 54
    6028:	07 fe       	sbrs	r0, 7
    602a:	fd cf       	rjmp	.-6      	; 0x6026 <i2cRead+0x26>
   TWDR = address+1;                                             // transmit address of i2c device with readbit set
    602c:	8f 5f       	subi	r24, 0xFF	; 255
    602e:	83 b9       	out	0x03, r24	; 3
   TWCR = 0xC4;                                                  // clear transmit interupt flag
    6030:	84 ec       	ldi	r24, 0xC4	; 196
    6032:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    6034:	06 b6       	in	r0, 0x36	; 54
    6036:	07 fe       	sbrs	r0, 7
    6038:	fd cf       	rjmp	.-6      	; 0x6034 <i2cRead+0x34>
   TWCR = 0x84;                                                  // transmit, nack (last byte request)
    603a:	84 e8       	ldi	r24, 0x84	; 132
    603c:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    603e:	06 b6       	in	r0, 0x36	; 54
    6040:	07 fe       	sbrs	r0, 7
    6042:	fd cf       	rjmp	.-6      	; 0x603e <i2cRead+0x3e>
   read_data = TWDR;                                             // and grab the target data
    6044:	83 b1       	in	r24, 0x03	; 3
   TWCR = 0x94;                                                  // send a stop bit on i2c bus
    6046:	94 e9       	ldi	r25, 0x94	; 148
    6048:	96 bf       	out	0x36, r25	; 54
   return read_data;
}
    604a:	08 95       	ret

0000604c <lcdSiap>:


unsigned char lcdSiap(){
	unsigned char busyFlag;

	LCD_DATA_DDR = 0x00;					// Set PORT DATA sebagai input
    604c:	1a ba       	out	0x1a, r1	; 26
	LCD_DATA_PORT = 0x00;					// Matikan pull-up
    604e:	1b ba       	out	0x1b, r1	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    6050:	c5 98       	cbi	0x18, 5	; 24
	LCD_CONTROL_PORT |= _BV(LCD_RW_BIT);	// RW = 1
    6052:	c6 9a       	sbi	0x18, 6	; 24
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    6054:	c7 9a       	sbi	0x18, 7	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    6056:	84 e0       	ldi	r24, 0x04	; 4
    6058:	8a 95       	dec	r24
    605a:	f1 f7       	brne	.-4      	; 0x6058 <lcdSiap+0xc>

	_delay_us(1);							// Beri jeda untuk menunggu input stabil

	busyFlag = (LCD_DATA_PIN & _BV(7));		// Check busy flag bit
    605c:	89 b3       	in	r24, 0x19	; 25
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0
    605e:	c7 98       	cbi	0x18, 7	; 24

	return busyFlag;
}
    6060:	80 78       	andi	r24, 0x80	; 128
    6062:	08 95       	ret

00006064 <lcdWait>:

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
		busyFlag = lcdSiap();
    6064:	0e 94 26 30 	call	0x604c	; 0x604c <lcdSiap>
}

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
    6068:	88 23       	and	r24, r24
    606a:	e1 f7       	brne	.-8      	; 0x6064 <lcdWait>
		busyFlag = lcdSiap();
	}
}
    606c:	08 95       	ret

0000606e <kirim_perintah_lcd>:

void kirim_perintah_lcd(unsigned char perintah){
    606e:	df 93       	push	r29
    6070:	cf 93       	push	r28
    6072:	0f 92       	push	r0
    6074:	cd b7       	in	r28, 0x3d	; 61
    6076:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    6078:	89 83       	std	Y+1, r24	; 0x01
    607a:	0e 94 32 30 	call	0x6064	; 0x6064 <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    607e:	9f ef       	ldi	r25, 0xFF	; 255
    6080:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    6082:	c5 98       	cbi	0x18, 5	; 24
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    6084:	c6 98       	cbi	0x18, 6	; 24
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    6086:	c7 9a       	sbi	0x18, 7	; 24
	LCD_DATA_PORT = perintah;				// Set perintah yang ingin dikirim	
    6088:	89 81       	ldd	r24, Y+1	; 0x01
    608a:	8b bb       	out	0x1b, r24	; 27
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    608c:	c7 98       	cbi	0x18, 7	; 24
}
    608e:	0f 90       	pop	r0
    6090:	cf 91       	pop	r28
    6092:	df 91       	pop	r29
    6094:	08 95       	ret

00006096 <init_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    6096:	8f e5       	ldi	r24, 0x5F	; 95
    6098:	9a ee       	ldi	r25, 0xEA	; 234
    609a:	01 97       	sbiw	r24, 0x01	; 1
    609c:	f1 f7       	brne	.-4      	; 0x609a <init_lcd+0x4>
    609e:	00 c0       	rjmp	.+0      	; 0x60a0 <init_lcd+0xa>
    60a0:	00 00       	nop
//Inisialisasi LCD
void init_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							
    kirim_perintah_lcd(0x38);  				//Function set: Interface is 8 bit long,
    60a2:	88 e3       	ldi	r24, 0x38	; 56
    60a4:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    60a8:	98 ec       	ldi	r25, 0xC8	; 200
    60aa:	9a 95       	dec	r25
    60ac:	f1 f7       	brne	.-4      	; 0x60aa <init_lcd+0x14>
    _delay_us(50);  						// 2lines, 5x7 dots (N=1, F=0)
											//Execution time 39 us
    
    kirim_perintah_lcd(0x04);				//Display Off
    60ae:	84 e0       	ldi	r24, 0x04	; 4
    60b0:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x01);				//Display Clear
    60b4:	81 e0       	ldi	r24, 0x01	; 1
    60b6:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x06);				//Entry mode set: increment & no display shift
    60ba:	86 e0       	ldi	r24, 0x06	; 6
    60bc:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x0C);				//Display ON,Cursor OFF & Blink OFF
    60c0:	8c e0       	ldi	r24, 0x0C	; 12
    60c2:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
}
    60c6:	08 95       	ret

000060c8 <clear_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    60c8:	8f e5       	ldi	r24, 0x5F	; 95
    60ca:	9a ee       	ldi	r25, 0xEA	; 234
    60cc:	01 97       	sbiw	r24, 0x01	; 1
    60ce:	f1 f7       	brne	.-4      	; 0x60cc <clear_lcd+0x4>
    60d0:	00 c0       	rjmp	.+0      	; 0x60d2 <clear_lcd+0xa>
    60d2:	00 00       	nop
//Clear LCD
void clear_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							  
    kirim_perintah_lcd(0x01);				//Display Clear
    60d4:	81 e0       	ldi	r24, 0x01	; 1
    60d6:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
    
}
    60da:	08 95       	ret

000060dc <set_cursor>:

void set_cursor(int x,int y){
	int address = 0b10000000;
	char ddram = address ^ x;
    60dc:	80 58       	subi	r24, 0x80	; 128
	if (y==1){
    60de:	61 30       	cpi	r22, 0x01	; 1
    60e0:	71 05       	cpc	r23, r1
    60e2:	11 f4       	brne	.+4      	; 0x60e8 <set_cursor+0xc>
		ddram = ddram ^ 0b01000000;
    60e4:	90 e4       	ldi	r25, 0x40	; 64
    60e6:	89 27       	eor	r24, r25
	}
	kirim_perintah_lcd(ddram);
    60e8:	0e 94 37 30 	call	0x606e	; 0x606e <kirim_perintah_lcd>
}
    60ec:	08 95       	ret

000060ee <tulis_data_ram_lcd>:
		tulis_data_ram_lcd(data[ii]);
	}

}

void tulis_data_ram_lcd(unsigned char data){
    60ee:	df 93       	push	r29
    60f0:	cf 93       	push	r28
    60f2:	0f 92       	push	r0
    60f4:	cd b7       	in	r28, 0x3d	; 61
    60f6:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    60f8:	89 83       	std	Y+1, r24	; 0x01
    60fa:	0e 94 32 30 	call	0x6064	; 0x6064 <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    60fe:	9f ef       	ldi	r25, 0xFF	; 255
    6100:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT |= _BV(LCD_RS_BIT);	// RS = 1
    6102:	c5 9a       	sbi	0x18, 5	; 24
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    6104:	c6 98       	cbi	0x18, 6	; 24
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    6106:	c7 9a       	sbi	0x18, 7	; 24
	
	LCD_DATA_PORT = data;					// Set data yang ingin dikirim
    6108:	89 81       	ldd	r24, Y+1	; 0x01
    610a:	8b bb       	out	0x1b, r24	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    610c:	c7 98       	cbi	0x18, 7	; 24
}
    610e:	0f 90       	pop	r0
    6110:	cf 91       	pop	r28
    6112:	df 91       	pop	r29
    6114:	08 95       	ret

00006116 <tulis_string2>:
		tulis_data_ram_lcd(data[ii]);
	}

}

void tulis_string2(unsigned char* data, int x, int y,int datalen){
    6116:	ef 92       	push	r14
    6118:	ff 92       	push	r15
    611a:	0f 93       	push	r16
    611c:	1f 93       	push	r17
    611e:	cf 93       	push	r28
    6120:	df 93       	push	r29
    6122:	e8 2e       	mov	r14, r24
    6124:	09 2f       	mov	r16, r25
    6126:	cb 01       	movw	r24, r22
    6128:	e9 01       	movw	r28, r18
	set_cursor(x,y);
    612a:	ba 01       	movw	r22, r20
    612c:	0e 94 6e 30 	call	0x60dc	; 0x60dc <set_cursor>
    6130:	f0 2e       	mov	r15, r16
	for(int ii=0; ii<datalen; ii++){
    6132:	00 e0       	ldi	r16, 0x00	; 0
    6134:	10 e0       	ldi	r17, 0x00	; 0
    6136:	07 c0       	rjmp	.+14     	; 0x6146 <tulis_string2+0x30>
		tulis_data_ram_lcd(data[ii]);
    6138:	f7 01       	movw	r30, r14
    613a:	81 91       	ld	r24, Z+
    613c:	7f 01       	movw	r14, r30
    613e:	0e 94 77 30 	call	0x60ee	; 0x60ee <tulis_data_ram_lcd>

}

void tulis_string2(unsigned char* data, int x, int y,int datalen){
	set_cursor(x,y);
	for(int ii=0; ii<datalen; ii++){
    6142:	0f 5f       	subi	r16, 0xFF	; 255
    6144:	1f 4f       	sbci	r17, 0xFF	; 255
    6146:	0c 17       	cp	r16, r28
    6148:	1d 07       	cpc	r17, r29
    614a:	b4 f3       	brlt	.-20     	; 0x6138 <tulis_string2+0x22>
		tulis_data_ram_lcd(data[ii]);
	}

}
    614c:	df 91       	pop	r29
    614e:	cf 91       	pop	r28
    6150:	1f 91       	pop	r17
    6152:	0f 91       	pop	r16
    6154:	ff 90       	pop	r15
    6156:	ef 90       	pop	r14
    6158:	08 95       	ret

0000615a <tulis_string>:
void tulis_data_at(unsigned char data, int x, int y){
	set_cursor(x,y);
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
    615a:	ef 92       	push	r14
    615c:	ff 92       	push	r15
    615e:	0f 93       	push	r16
    6160:	1f 93       	push	r17
    6162:	cf 93       	push	r28
    6164:	df 93       	push	r29
    6166:	7c 01       	movw	r14, r24
    6168:	cb 01       	movw	r24, r22
	set_cursor(x,y);
    616a:	ba 01       	movw	r22, r20
    616c:	0e 94 6e 30 	call	0x60dc	; 0x60dc <set_cursor>
    6170:	0e 2d       	mov	r16, r14
    6172:	1f 2d       	mov	r17, r15
	for(int ii=0; ii<strlen(data); ii++){
    6174:	c0 e0       	ldi	r28, 0x00	; 0
    6176:	d0 e0       	ldi	r29, 0x00	; 0
    6178:	06 c0       	rjmp	.+12     	; 0x6186 <tulis_string+0x2c>
		tulis_data_ram_lcd(data[ii]);
    617a:	f8 01       	movw	r30, r16
    617c:	81 91       	ld	r24, Z+
    617e:	8f 01       	movw	r16, r30
    6180:	0e 94 77 30 	call	0x60ee	; 0x60ee <tulis_data_ram_lcd>
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
	set_cursor(x,y);
	for(int ii=0; ii<strlen(data); ii++){
    6184:	21 96       	adiw	r28, 0x01	; 1
    6186:	f7 01       	movw	r30, r14
    6188:	01 90       	ld	r0, Z+
    618a:	00 20       	and	r0, r0
    618c:	e9 f7       	brne	.-6      	; 0x6188 <tulis_string+0x2e>
    618e:	31 97       	sbiw	r30, 0x01	; 1
    6190:	ee 19       	sub	r30, r14
    6192:	ff 09       	sbc	r31, r15
    6194:	ce 17       	cp	r28, r30
    6196:	df 07       	cpc	r29, r31
    6198:	80 f3       	brcs	.-32     	; 0x617a <tulis_string+0x20>
		tulis_data_ram_lcd(data[ii]);
	}

}
    619a:	df 91       	pop	r29
    619c:	cf 91       	pop	r28
    619e:	1f 91       	pop	r17
    61a0:	0f 91       	pop	r16
    61a2:	ff 90       	pop	r15
    61a4:	ef 90       	pop	r14
    61a6:	08 95       	ret

000061a8 <tulis_data_at>:
		ddram = ddram ^ 0b01000000;
	}
	kirim_perintah_lcd(ddram);
}

void tulis_data_at(unsigned char data, int x, int y){
    61a8:	1f 93       	push	r17
    61aa:	18 2f       	mov	r17, r24
	set_cursor(x,y);
    61ac:	cb 01       	movw	r24, r22
    61ae:	ba 01       	movw	r22, r20
    61b0:	0e 94 6e 30 	call	0x60dc	; 0x60dc <set_cursor>
	tulis_data_ram_lcd(data);
    61b4:	81 2f       	mov	r24, r17
    61b6:	0e 94 77 30 	call	0x60ee	; 0x60ee <tulis_data_ram_lcd>
}
    61ba:	1f 91       	pop	r17
    61bc:	08 95       	ret

000061be <setup_seed>:
static int play_state=0;
//state mode
static int mode = SLOW_MODE;


void setup_seed(){
    61be:	1f 93       	push	r17
	 unsigned char oldADMUX = ADMUX;
    61c0:	17 b1       	in	r17, 0x07	; 7
	 ADMUX |=  _BV(MUX0); //choose ADC1 on PB2
    61c2:	38 9a       	sbi	0x07, 0	; 7
	 ADCSRA |= _BV(ADPS2) |_BV(ADPS1) |_BV(ADPS0); //set prescaler to max value, 128
    61c4:	86 b1       	in	r24, 0x06	; 6
    61c6:	87 60       	ori	r24, 0x07	; 7
    61c8:	86 b9       	out	0x06, r24	; 6
	 ADCSRA |= _BV(ADEN); //enable the ADC
    61ca:	37 9a       	sbi	0x06, 7	; 6
	 ADCSRA |= _BV(ADSC);//start conversion
    61cc:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait until the hardware clears the flag. Note semicolon!
    61ce:	36 99       	sbic	0x06, 6	; 6
    61d0:	fe cf       	rjmp	.-4      	; 0x61ce <setup_seed+0x10>
	 unsigned char byte1 = ADCL;
    61d2:	94 b1       	in	r25, 0x04	; 4
	 ADCSRA |= _BV(ADSC);//start conversion
    61d4:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait again note semicolon!
    61d6:	36 99       	sbic	0x06, 6	; 6
    61d8:	fe cf       	rjmp	.-4      	; 0x61d6 <setup_seed+0x18>
	 unsigned char byte2 = ADCL;
    61da:	84 b1       	in	r24, 0x04	; 4
	 unsigned int seed = byte1 << 8 | byte2;
    61dc:	39 2f       	mov	r19, r25
    61de:	20 e0       	ldi	r18, 0x00	; 0
    61e0:	90 e0       	ldi	r25, 0x00	; 0
	 srand(seed);
    61e2:	82 2b       	or	r24, r18
    61e4:	93 2b       	or	r25, r19
    61e6:	0e 94 e4 32 	call	0x65c8	; 0x65c8 <srand>
	 ADCSRA &= ~_BV(ADEN); //disable ADC
    61ea:	37 98       	cbi	0x06, 7	; 6
	 ADMUX = oldADMUX;
    61ec:	17 b9       	out	0x07, r17	; 7
}
    61ee:	1f 91       	pop	r17
    61f0:	08 95       	ret

000061f2 <init_game>:



void init_game(){
	setup_seed();
    61f2:	0e 94 df 30 	call	0x61be	; 0x61be <setup_seed>
	mario = 0;
    61f6:	10 92 83 07 	sts	0x0783, r1
    61fa:	10 92 82 07 	sts	0x0782, r1
	pass = 0;
    61fe:	10 92 7f 07 	sts	0x077F, r1
    6202:	10 92 7e 07 	sts	0x077E, r1
	speed = 0;
    6206:	10 92 a5 07 	sts	0x07A5, r1
    620a:	10 92 a4 07 	sts	0x07A4, r1
	summon_time = 2*TIME_INTERVAL;
    620e:	84 e0       	ldi	r24, 0x04	; 4
    6210:	90 e0       	ldi	r25, 0x00	; 0
    6212:	90 93 08 01 	sts	0x0108, r25
    6216:	80 93 07 01 	sts	0x0107, r24
	play_state = GAME_PLAY;
    621a:	10 92 81 07 	sts	0x0781, r1
    621e:	10 92 80 07 	sts	0x0780, r1
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			obstacle[ii][jj] = 0;
    6222:	10 92 85 07 	sts	0x0785, r1
    6226:	10 92 84 07 	sts	0x0784, r1
    622a:	10 92 87 07 	sts	0x0787, r1
    622e:	10 92 86 07 	sts	0x0786, r1
    6232:	10 92 89 07 	sts	0x0789, r1
    6236:	10 92 88 07 	sts	0x0788, r1
    623a:	10 92 8b 07 	sts	0x078B, r1
    623e:	10 92 8a 07 	sts	0x078A, r1
    6242:	10 92 8d 07 	sts	0x078D, r1
    6246:	10 92 8c 07 	sts	0x078C, r1
    624a:	10 92 8f 07 	sts	0x078F, r1
    624e:	10 92 8e 07 	sts	0x078E, r1
    6252:	10 92 91 07 	sts	0x0791, r1
    6256:	10 92 90 07 	sts	0x0790, r1
    625a:	10 92 93 07 	sts	0x0793, r1
    625e:	10 92 92 07 	sts	0x0792, r1
    6262:	10 92 95 07 	sts	0x0795, r1
    6266:	10 92 94 07 	sts	0x0794, r1
    626a:	10 92 97 07 	sts	0x0797, r1
    626e:	10 92 96 07 	sts	0x0796, r1
    6272:	10 92 99 07 	sts	0x0799, r1
    6276:	10 92 98 07 	sts	0x0798, r1
    627a:	10 92 9b 07 	sts	0x079B, r1
    627e:	10 92 9a 07 	sts	0x079A, r1
    6282:	10 92 9d 07 	sts	0x079D, r1
    6286:	10 92 9c 07 	sts	0x079C, r1
    628a:	10 92 9f 07 	sts	0x079F, r1
    628e:	10 92 9e 07 	sts	0x079E, r1
    6292:	10 92 a1 07 	sts	0x07A1, r1
    6296:	10 92 a0 07 	sts	0x07A0, r1
    629a:	10 92 a3 07 	sts	0x07A3, r1
    629e:	10 92 a2 07 	sts	0x07A2, r1
		}
	}
	obstacle[rand()%2][7] = 1;
    62a2:	0e 94 df 32 	call	0x65be	; 0x65be <rand>
    62a6:	62 e0       	ldi	r22, 0x02	; 2
    62a8:	70 e0       	ldi	r23, 0x00	; 0
    62aa:	0e 94 74 32 	call	0x64e8	; 0x64e8 <__divmodhi4>
    62ae:	24 e0       	ldi	r18, 0x04	; 4
    62b0:	88 0f       	add	r24, r24
    62b2:	99 1f       	adc	r25, r25
    62b4:	2a 95       	dec	r18
    62b6:	e1 f7       	brne	.-8      	; 0x62b0 <init_game+0xbe>
    62b8:	8c 57       	subi	r24, 0x7C	; 124
    62ba:	98 4f       	sbci	r25, 0xF8	; 248
    62bc:	21 e0       	ldi	r18, 0x01	; 1
    62be:	30 e0       	ldi	r19, 0x00	; 0
    62c0:	fc 01       	movw	r30, r24
    62c2:	37 87       	std	Z+15, r19	; 0x0f
    62c4:	26 87       	std	Z+14, r18	; 0x0e
}
    62c6:	08 95       	ret

000062c8 <update_game>:


void update_game(){
    62c8:	cf 93       	push	r28
    62ca:	df 93       	push	r29
	if(play_state==GAME_PLAY){
    62cc:	80 91 80 07 	lds	r24, 0x0780
    62d0:	90 91 81 07 	lds	r25, 0x0781
    62d4:	00 97       	sbiw	r24, 0x00	; 0
    62d6:	09 f0       	breq	.+2      	; 0x62da <update_game+0x12>
    62d8:	94 c0       	rjmp	.+296    	; 0x6402 <update_game+0x13a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
    62da:	83 e0       	ldi	r24, 0x03	; 3
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	60 91 05 01 	lds	r22, 0x0105
    62e2:	70 91 06 01 	lds	r23, 0x0106
    62e6:	86 1b       	sub	r24, r22
    62e8:	97 0b       	sbc	r25, r23
    62ea:	20 91 a4 07 	lds	r18, 0x07A4
    62ee:	30 91 a5 07 	lds	r19, 0x07A5
    62f2:	82 17       	cp	r24, r18
    62f4:	93 07       	cpc	r25, r19
    62f6:	ec f5       	brge	.+122    	; 0x6372 <update_game+0xaa>
			speed = 0;
    62f8:	10 92 a5 07 	sts	0x07A5, r1
    62fc:	10 92 a4 07 	sts	0x07A4, r1
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
						}else{
							pass+=mode;
    6300:	40 91 7e 07 	lds	r20, 0x077E
    6304:	50 91 7f 07 	lds	r21, 0x077F
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    6308:	80 e0       	ldi	r24, 0x00	; 0
    630a:	90 e0       	ldi	r25, 0x00	; 0
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
    630c:	a1 e0       	ldi	r26, 0x01	; 1
    630e:	b0 e0       	ldi	r27, 0x00	; 0
    6310:	18 c0       	rjmp	.+48     	; 0x6342 <update_game+0x7a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
    6312:	c2 81       	ldd	r28, Z+2	; 0x02
    6314:	d3 81       	ldd	r29, Z+3	; 0x03
    6316:	20 97       	sbiw	r28, 0x00	; 0
    6318:	51 f0       	breq	.+20     	; 0x632e <update_game+0x66>
						obstacle[ii][jj] = 0;
    631a:	13 82       	std	Z+3, r1	; 0x03
    631c:	12 82       	std	Z+2, r1	; 0x02
						if(jj>=1) {
    631e:	21 15       	cp	r18, r1
    6320:	31 05       	cpc	r19, r1
    6322:	19 f0       	breq	.+6      	; 0x632a <update_game+0x62>
							obstacle[ii][jj-1] = 1;
    6324:	b1 83       	std	Z+1, r27	; 0x01
    6326:	a0 83       	st	Z, r26
    6328:	02 c0       	rjmp	.+4      	; 0x632e <update_game+0x66>
						}else{
							pass+=mode;
    632a:	46 0f       	add	r20, r22
    632c:	57 1f       	adc	r21, r23
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
    632e:	2f 5f       	subi	r18, 0xFF	; 255
    6330:	3f 4f       	sbci	r19, 0xFF	; 255
    6332:	32 96       	adiw	r30, 0x02	; 2
    6334:	28 30       	cpi	r18, 0x08	; 8
    6336:	31 05       	cpc	r19, r1
    6338:	61 f7       	brne	.-40     	; 0x6312 <update_game+0x4a>
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    633a:	01 96       	adiw	r24, 0x01	; 1
    633c:	82 30       	cpi	r24, 0x02	; 2
    633e:	91 05       	cpc	r25, r1
    6340:	59 f0       	breq	.+22     	; 0x6358 <update_game+0x90>
	}
	obstacle[rand()%2][7] = 1;
}


void update_game(){
    6342:	fc 01       	movw	r30, r24
    6344:	24 e0       	ldi	r18, 0x04	; 4
    6346:	ee 0f       	add	r30, r30
    6348:	ff 1f       	adc	r31, r31
    634a:	2a 95       	dec	r18
    634c:	e1 f7       	brne	.-8      	; 0x6346 <update_game+0x7e>
    634e:	ee 57       	subi	r30, 0x7E	; 126
    6350:	f8 4f       	sbci	r31, 0xF8	; 248
    6352:	20 e0       	ldi	r18, 0x00	; 0
    6354:	30 e0       	ldi	r19, 0x00	; 0
    6356:	dd cf       	rjmp	.-70     	; 0x6312 <update_game+0x4a>
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    6358:	50 93 7f 07 	sts	0x077F, r21
    635c:	40 93 7e 07 	sts	0x077E, r20
						}				
					}

				}
			}
			summon_time--;	
    6360:	80 91 07 01 	lds	r24, 0x0107
    6364:	90 91 08 01 	lds	r25, 0x0108
    6368:	01 97       	sbiw	r24, 0x01	; 1
    636a:	90 93 08 01 	sts	0x0108, r25
    636e:	80 93 07 01 	sts	0x0107, r24
		}	

		

		if(obstacle[mario][0]){
    6372:	e0 91 82 07 	lds	r30, 0x0782
    6376:	f0 91 83 07 	lds	r31, 0x0783
    637a:	44 e0       	ldi	r20, 0x04	; 4
    637c:	ee 0f       	add	r30, r30
    637e:	ff 1f       	adc	r31, r31
    6380:	4a 95       	dec	r20
    6382:	e1 f7       	brne	.-8      	; 0x637c <update_game+0xb4>
    6384:	ec 57       	subi	r30, 0x7C	; 124
    6386:	f8 4f       	sbci	r31, 0xF8	; 248
    6388:	80 81       	ld	r24, Z
    638a:	91 81       	ldd	r25, Z+1	; 0x01
    638c:	00 97       	sbiw	r24, 0x00	; 0
    638e:	31 f0       	breq	.+12     	; 0x639c <update_game+0xd4>
			play_state = GAME_FINAL;
    6390:	81 e0       	ldi	r24, 0x01	; 1
    6392:	90 e0       	ldi	r25, 0x00	; 0
    6394:	90 93 81 07 	sts	0x0781, r25
    6398:	80 93 80 07 	sts	0x0780, r24
		}


		if(summon_time<=0){
    639c:	80 91 07 01 	lds	r24, 0x0107
    63a0:	90 91 08 01 	lds	r25, 0x0108
    63a4:	18 16       	cp	r1, r24
    63a6:	19 06       	cpc	r1, r25
    63a8:	1c f1       	brlt	.+70     	; 0x63f0 <update_game+0x128>
			int yy =  rand()%2;
    63aa:	0e 94 df 32 	call	0x65be	; 0x65be <rand>
    63ae:	62 e0       	ldi	r22, 0x02	; 2
    63b0:	70 e0       	ldi	r23, 0x00	; 0
    63b2:	0e 94 74 32 	call	0x64e8	; 0x64e8 <__divmodhi4>
			obstacle[yy][7] = 1;
    63b6:	34 e0       	ldi	r19, 0x04	; 4
    63b8:	88 0f       	add	r24, r24
    63ba:	99 1f       	adc	r25, r25
    63bc:	3a 95       	dec	r19
    63be:	e1 f7       	brne	.-8      	; 0x63b8 <update_game+0xf0>
    63c0:	8c 57       	subi	r24, 0x7C	; 124
    63c2:	98 4f       	sbci	r25, 0xF8	; 248
    63c4:	21 e0       	ldi	r18, 0x01	; 1
    63c6:	30 e0       	ldi	r19, 0x00	; 0
    63c8:	fc 01       	movw	r30, r24
    63ca:	37 87       	std	Z+15, r19	; 0x0f
    63cc:	26 87       	std	Z+14, r18	; 0x0e
			summon_time = rand()%(3-(mode-1))+2;	
    63ce:	0e 94 df 32 	call	0x65be	; 0x65be <rand>
    63d2:	64 e0       	ldi	r22, 0x04	; 4
    63d4:	70 e0       	ldi	r23, 0x00	; 0
    63d6:	20 91 05 01 	lds	r18, 0x0105
    63da:	30 91 06 01 	lds	r19, 0x0106
    63de:	62 1b       	sub	r22, r18
    63e0:	73 0b       	sbc	r23, r19
    63e2:	0e 94 74 32 	call	0x64e8	; 0x64e8 <__divmodhi4>
    63e6:	02 96       	adiw	r24, 0x02	; 2
    63e8:	90 93 08 01 	sts	0x0108, r25
    63ec:	80 93 07 01 	sts	0x0107, r24
		}

		speed++;
    63f0:	80 91 a4 07 	lds	r24, 0x07A4
    63f4:	90 91 a5 07 	lds	r25, 0x07A5
    63f8:	01 96       	adiw	r24, 0x01	; 1
    63fa:	90 93 a5 07 	sts	0x07A5, r25
    63fe:	80 93 a4 07 	sts	0x07A4, r24
	}
}
    6402:	df 91       	pop	r29
    6404:	cf 91       	pop	r28
    6406:	08 95       	ret

00006408 <draw_game>:



void draw_game(){
    6408:	ef 92       	push	r14
    640a:	ff 92       	push	r15
    640c:	0f 93       	push	r16
    640e:	1f 93       	push	r17
    6410:	cf 93       	push	r28
    6412:	df 93       	push	r29
	tulis_data_at('M',0,mario);
    6414:	40 91 82 07 	lds	r20, 0x0782
    6418:	50 91 83 07 	lds	r21, 0x0783
    641c:	8d e4       	ldi	r24, 0x4D	; 77
    641e:	60 e0       	ldi	r22, 0x00	; 0
    6420:	70 e0       	ldi	r23, 0x00	; 0
    6422:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <tulis_data_at>
	if(mario==1){
    6426:	80 91 82 07 	lds	r24, 0x0782
    642a:	90 91 83 07 	lds	r25, 0x0783
    642e:	81 30       	cpi	r24, 0x01	; 1
    6430:	91 05       	cpc	r25, r1
    6432:	31 f4       	brne	.+12     	; 0x6440 <draw_game+0x38>
		tulis_data_at(' ',0,0);
    6434:	80 e2       	ldi	r24, 0x20	; 32
    6436:	60 e0       	ldi	r22, 0x00	; 0
    6438:	70 e0       	ldi	r23, 0x00	; 0
    643a:	40 e0       	ldi	r20, 0x00	; 0
    643c:	50 e0       	ldi	r21, 0x00	; 0
    643e:	05 c0       	rjmp	.+10     	; 0x644a <draw_game+0x42>
	}else{
		tulis_data_at(' ',0,1);
    6440:	80 e2       	ldi	r24, 0x20	; 32
    6442:	60 e0       	ldi	r22, 0x00	; 0
    6444:	70 e0       	ldi	r23, 0x00	; 0
    6446:	41 e0       	ldi	r20, 0x01	; 1
    6448:	50 e0       	ldi	r21, 0x00	; 0
    644a:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <tulis_data_at>
	}
}



void draw_game(){
    644e:	c0 e0       	ldi	r28, 0x00	; 0
    6450:	d0 e0       	ldi	r29, 0x00	; 0
    6452:	16 c0       	rjmp	.+44     	; 0x6480 <draw_game+0x78>
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			if(obstacle[ii][jj]){
    6454:	f8 01       	movw	r30, r16
    6456:	81 91       	ld	r24, Z+
    6458:	91 91       	ld	r25, Z+
    645a:	8f 01       	movw	r16, r30
    645c:	00 97       	sbiw	r24, 0x00	; 0
    645e:	29 f0       	breq	.+10     	; 0x646a <draw_game+0x62>
				tulis_data_at('#',jj,ii);			
    6460:	83 e2       	ldi	r24, 0x23	; 35
    6462:	b7 01       	movw	r22, r14
    6464:	ae 01       	movw	r20, r28
    6466:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <tulis_data_at>
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
    646a:	08 94       	sec
    646c:	e1 1c       	adc	r14, r1
    646e:	f1 1c       	adc	r15, r1
    6470:	f8 e0       	ldi	r31, 0x08	; 8
    6472:	ef 16       	cp	r14, r31
    6474:	f1 04       	cpc	r15, r1
    6476:	71 f7       	brne	.-36     	; 0x6454 <draw_game+0x4c>
	if(mario==1){
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
    6478:	21 96       	adiw	r28, 0x01	; 1
    647a:	c2 30       	cpi	r28, 0x02	; 2
    647c:	d1 05       	cpc	r29, r1
    647e:	59 f0       	breq	.+22     	; 0x6496 <draw_game+0x8e>
	}
}



void draw_game(){
    6480:	8e 01       	movw	r16, r28
    6482:	34 e0       	ldi	r19, 0x04	; 4
    6484:	00 0f       	add	r16, r16
    6486:	11 1f       	adc	r17, r17
    6488:	3a 95       	dec	r19
    648a:	e1 f7       	brne	.-8      	; 0x6484 <draw_game+0x7c>
    648c:	0c 57       	subi	r16, 0x7C	; 124
    648e:	18 4f       	sbci	r17, 0xF8	; 248
    6490:	ee 24       	eor	r14, r14
    6492:	ff 24       	eor	r15, r15
    6494:	df cf       	rjmp	.-66     	; 0x6454 <draw_game+0x4c>
				tulis_data_at('#',jj,ii);			
			}
		}
	}
	
}
    6496:	df 91       	pop	r29
    6498:	cf 91       	pop	r28
    649a:	1f 91       	pop	r17
    649c:	0f 91       	pop	r16
    649e:	ff 90       	pop	r15
    64a0:	ef 90       	pop	r14
    64a2:	08 95       	ret

000064a4 <set_mario>:

void set_mario(int loc){
	if(loc==0){
    64a4:	00 97       	sbiw	r24, 0x00	; 0
    64a6:	29 f4       	brne	.+10     	; 0x64b2 <set_mario+0xe>
		mario = 0;
    64a8:	10 92 83 07 	sts	0x0783, r1
    64ac:	10 92 82 07 	sts	0x0782, r1
    64b0:	08 95       	ret
	}else{
		mario = 1;
    64b2:	81 e0       	ldi	r24, 0x01	; 1
    64b4:	90 e0       	ldi	r25, 0x00	; 0
    64b6:	90 93 83 07 	sts	0x0783, r25
    64ba:	80 93 82 07 	sts	0x0782, r24
    64be:	08 95       	ret

000064c0 <get_mario>:
	}
}

int get_mario(){
	return mario;
}
    64c0:	80 91 82 07 	lds	r24, 0x0782
    64c4:	90 91 83 07 	lds	r25, 0x0783
    64c8:	08 95       	ret

000064ca <get_state>:


int get_state(){
	return play_state;
}
    64ca:	80 91 80 07 	lds	r24, 0x0780
    64ce:	90 91 81 07 	lds	r25, 0x0781
    64d2:	08 95       	ret

000064d4 <getpass>:

int getpass(){
	return pass;
}
    64d4:	80 91 7e 07 	lds	r24, 0x077E
    64d8:	90 91 7f 07 	lds	r25, 0x077F
    64dc:	08 95       	ret

000064de <set_mode>:

void set_mode(int mod){
	mode = mod;
    64de:	90 93 06 01 	sts	0x0106, r25
    64e2:	80 93 05 01 	sts	0x0105, r24
}
    64e6:	08 95       	ret

000064e8 <__divmodhi4>:
    64e8:	97 fb       	bst	r25, 7
    64ea:	09 2e       	mov	r0, r25
    64ec:	07 26       	eor	r0, r23
    64ee:	0a d0       	rcall	.+20     	; 0x6504 <__divmodhi4_neg1>
    64f0:	77 fd       	sbrc	r23, 7
    64f2:	04 d0       	rcall	.+8      	; 0x64fc <__divmodhi4_neg2>
    64f4:	0c d0       	rcall	.+24     	; 0x650e <__udivmodhi4>
    64f6:	06 d0       	rcall	.+12     	; 0x6504 <__divmodhi4_neg1>
    64f8:	00 20       	and	r0, r0
    64fa:	1a f4       	brpl	.+6      	; 0x6502 <__divmodhi4_exit>

000064fc <__divmodhi4_neg2>:
    64fc:	70 95       	com	r23
    64fe:	61 95       	neg	r22
    6500:	7f 4f       	sbci	r23, 0xFF	; 255

00006502 <__divmodhi4_exit>:
    6502:	08 95       	ret

00006504 <__divmodhi4_neg1>:
    6504:	f6 f7       	brtc	.-4      	; 0x6502 <__divmodhi4_exit>
    6506:	90 95       	com	r25
    6508:	81 95       	neg	r24
    650a:	9f 4f       	sbci	r25, 0xFF	; 255
    650c:	08 95       	ret

0000650e <__udivmodhi4>:
    650e:	aa 1b       	sub	r26, r26
    6510:	bb 1b       	sub	r27, r27
    6512:	51 e1       	ldi	r21, 0x11	; 17
    6514:	07 c0       	rjmp	.+14     	; 0x6524 <__udivmodhi4_ep>

00006516 <__udivmodhi4_loop>:
    6516:	aa 1f       	adc	r26, r26
    6518:	bb 1f       	adc	r27, r27
    651a:	a6 17       	cp	r26, r22
    651c:	b7 07       	cpc	r27, r23
    651e:	10 f0       	brcs	.+4      	; 0x6524 <__udivmodhi4_ep>
    6520:	a6 1b       	sub	r26, r22
    6522:	b7 0b       	sbc	r27, r23

00006524 <__udivmodhi4_ep>:
    6524:	88 1f       	adc	r24, r24
    6526:	99 1f       	adc	r25, r25
    6528:	5a 95       	dec	r21
    652a:	a9 f7       	brne	.-22     	; 0x6516 <__udivmodhi4_loop>
    652c:	80 95       	com	r24
    652e:	90 95       	com	r25
    6530:	bc 01       	movw	r22, r24
    6532:	cd 01       	movw	r24, r26
    6534:	08 95       	ret

00006536 <do_rand>:
    6536:	a0 e0       	ldi	r26, 0x00	; 0
    6538:	b0 e0       	ldi	r27, 0x00	; 0
    653a:	e1 ea       	ldi	r30, 0xA1	; 161
    653c:	f2 e3       	ldi	r31, 0x32	; 50
    653e:	0c 94 e3 33 	jmp	0x67c6	; 0x67c6 <__prologue_saves__+0x10>
    6542:	ec 01       	movw	r28, r24
    6544:	68 81       	ld	r22, Y
    6546:	79 81       	ldd	r23, Y+1	; 0x01
    6548:	8a 81       	ldd	r24, Y+2	; 0x02
    654a:	9b 81       	ldd	r25, Y+3	; 0x03
    654c:	61 15       	cp	r22, r1
    654e:	71 05       	cpc	r23, r1
    6550:	81 05       	cpc	r24, r1
    6552:	91 05       	cpc	r25, r1
    6554:	21 f4       	brne	.+8      	; 0x655e <do_rand+0x28>
    6556:	64 e2       	ldi	r22, 0x24	; 36
    6558:	79 ed       	ldi	r23, 0xD9	; 217
    655a:	8b e5       	ldi	r24, 0x5B	; 91
    655c:	97 e0       	ldi	r25, 0x07	; 7
    655e:	2d e1       	ldi	r18, 0x1D	; 29
    6560:	33 ef       	ldi	r19, 0xF3	; 243
    6562:	41 e0       	ldi	r20, 0x01	; 1
    6564:	50 e0       	ldi	r21, 0x00	; 0
    6566:	0e 94 c0 33 	call	0x6780	; 0x6780 <__divmodsi4>
    656a:	79 01       	movw	r14, r18
    656c:	8a 01       	movw	r16, r20
    656e:	27 ea       	ldi	r18, 0xA7	; 167
    6570:	31 e4       	ldi	r19, 0x41	; 65
    6572:	40 e0       	ldi	r20, 0x00	; 0
    6574:	50 e0       	ldi	r21, 0x00	; 0
    6576:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__mulsi3>
    657a:	5b 01       	movw	r10, r22
    657c:	6c 01       	movw	r12, r24
    657e:	c8 01       	movw	r24, r16
    6580:	b7 01       	movw	r22, r14
    6582:	2c ee       	ldi	r18, 0xEC	; 236
    6584:	34 ef       	ldi	r19, 0xF4	; 244
    6586:	4f ef       	ldi	r20, 0xFF	; 255
    6588:	5f ef       	ldi	r21, 0xFF	; 255
    658a:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__mulsi3>
    658e:	6a 0d       	add	r22, r10
    6590:	7b 1d       	adc	r23, r11
    6592:	8c 1d       	adc	r24, r12
    6594:	9d 1d       	adc	r25, r13
    6596:	97 ff       	sbrs	r25, 7
    6598:	04 c0       	rjmp	.+8      	; 0x65a2 <do_rand+0x6c>
    659a:	61 50       	subi	r22, 0x01	; 1
    659c:	70 40       	sbci	r23, 0x00	; 0
    659e:	80 40       	sbci	r24, 0x00	; 0
    65a0:	90 48       	sbci	r25, 0x80	; 128
    65a2:	68 83       	st	Y, r22
    65a4:	79 83       	std	Y+1, r23	; 0x01
    65a6:	8a 83       	std	Y+2, r24	; 0x02
    65a8:	9b 83       	std	Y+3, r25	; 0x03
    65aa:	7f 77       	andi	r23, 0x7F	; 127
    65ac:	cb 01       	movw	r24, r22
    65ae:	cd b7       	in	r28, 0x3d	; 61
    65b0:	de b7       	in	r29, 0x3e	; 62
    65b2:	ea e0       	ldi	r30, 0x0A	; 10
    65b4:	0c 94 ff 33 	jmp	0x67fe	; 0x67fe <__epilogue_restores__+0x10>

000065b8 <rand_r>:
    65b8:	0e 94 9b 32 	call	0x6536	; 0x6536 <do_rand>
    65bc:	08 95       	ret

000065be <rand>:
    65be:	89 e0       	ldi	r24, 0x09	; 9
    65c0:	91 e0       	ldi	r25, 0x01	; 1
    65c2:	0e 94 9b 32 	call	0x6536	; 0x6536 <do_rand>
    65c6:	08 95       	ret

000065c8 <srand>:
    65c8:	a0 e0       	ldi	r26, 0x00	; 0
    65ca:	b0 e0       	ldi	r27, 0x00	; 0
    65cc:	80 93 09 01 	sts	0x0109, r24
    65d0:	90 93 0a 01 	sts	0x010A, r25
    65d4:	a0 93 0b 01 	sts	0x010B, r26
    65d8:	b0 93 0c 01 	sts	0x010C, r27
    65dc:	08 95       	ret

000065de <memcpy>:
    65de:	fb 01       	movw	r30, r22
    65e0:	dc 01       	movw	r26, r24
    65e2:	02 c0       	rjmp	.+4      	; 0x65e8 <memcpy+0xa>
    65e4:	01 90       	ld	r0, Z+
    65e6:	0d 92       	st	X+, r0
    65e8:	41 50       	subi	r20, 0x01	; 1
    65ea:	50 40       	sbci	r21, 0x00	; 0
    65ec:	d8 f7       	brcc	.-10     	; 0x65e4 <memcpy+0x6>
    65ee:	08 95       	ret

000065f0 <memset>:
    65f0:	dc 01       	movw	r26, r24
    65f2:	01 c0       	rjmp	.+2      	; 0x65f6 <memset+0x6>
    65f4:	6d 93       	st	X+, r22
    65f6:	41 50       	subi	r20, 0x01	; 1
    65f8:	50 40       	sbci	r21, 0x00	; 0
    65fa:	e0 f7       	brcc	.-8      	; 0x65f4 <memset+0x4>
    65fc:	08 95       	ret

000065fe <strncpy>:
    65fe:	fb 01       	movw	r30, r22
    6600:	dc 01       	movw	r26, r24
    6602:	41 50       	subi	r20, 0x01	; 1
    6604:	50 40       	sbci	r21, 0x00	; 0
    6606:	48 f0       	brcs	.+18     	; 0x661a <strncpy+0x1c>
    6608:	01 90       	ld	r0, Z+
    660a:	0d 92       	st	X+, r0
    660c:	00 20       	and	r0, r0
    660e:	c9 f7       	brne	.-14     	; 0x6602 <strncpy+0x4>
    6610:	01 c0       	rjmp	.+2      	; 0x6614 <strncpy+0x16>
    6612:	1d 92       	st	X+, r1
    6614:	41 50       	subi	r20, 0x01	; 1
    6616:	50 40       	sbci	r21, 0x00	; 0
    6618:	e0 f7       	brcc	.-8      	; 0x6612 <strncpy+0x14>
    661a:	08 95       	ret

0000661c <ltoa>:
    661c:	fa 01       	movw	r30, r20
    661e:	cf 93       	push	r28
    6620:	ff 93       	push	r31
    6622:	ef 93       	push	r30
    6624:	22 30       	cpi	r18, 0x02	; 2
    6626:	44 f1       	brlt	.+80     	; 0x6678 <ltoa+0x5c>
    6628:	25 32       	cpi	r18, 0x25	; 37
    662a:	34 f5       	brge	.+76     	; 0x6678 <ltoa+0x5c>
    662c:	c2 2f       	mov	r28, r18
    662e:	e8 94       	clt
    6630:	ca 30       	cpi	r28, 0x0A	; 10
    6632:	49 f4       	brne	.+18     	; 0x6646 <ltoa+0x2a>
    6634:	97 fb       	bst	r25, 7
    6636:	3e f4       	brtc	.+14     	; 0x6646 <ltoa+0x2a>
    6638:	90 95       	com	r25
    663a:	80 95       	com	r24
    663c:	70 95       	com	r23
    663e:	61 95       	neg	r22
    6640:	7f 4f       	sbci	r23, 0xFF	; 255
    6642:	8f 4f       	sbci	r24, 0xFF	; 255
    6644:	9f 4f       	sbci	r25, 0xFF	; 255
    6646:	2c 2f       	mov	r18, r28
    6648:	33 27       	eor	r19, r19
    664a:	44 27       	eor	r20, r20
    664c:	55 27       	eor	r21, r21
    664e:	ff 93       	push	r31
    6650:	ef 93       	push	r30
    6652:	0e 94 9e 33 	call	0x673c	; 0x673c <__udivmodsi4>
    6656:	ef 91       	pop	r30
    6658:	ff 91       	pop	r31
    665a:	60 5d       	subi	r22, 0xD0	; 208
    665c:	6a 33       	cpi	r22, 0x3A	; 58
    665e:	0c f0       	brlt	.+2      	; 0x6662 <ltoa+0x46>
    6660:	69 5d       	subi	r22, 0xD9	; 217
    6662:	61 93       	st	Z+, r22
    6664:	b9 01       	movw	r22, r18
    6666:	ca 01       	movw	r24, r20
    6668:	60 50       	subi	r22, 0x00	; 0
    666a:	70 40       	sbci	r23, 0x00	; 0
    666c:	80 40       	sbci	r24, 0x00	; 0
    666e:	90 40       	sbci	r25, 0x00	; 0
    6670:	51 f7       	brne	.-44     	; 0x6646 <ltoa+0x2a>
    6672:	16 f4       	brtc	.+4      	; 0x6678 <ltoa+0x5c>
    6674:	cd e2       	ldi	r28, 0x2D	; 45
    6676:	c1 93       	st	Z+, r28
    6678:	10 82       	st	Z, r1
    667a:	8f 91       	pop	r24
    667c:	9f 91       	pop	r25
    667e:	cf 91       	pop	r28
    6680:	0c 94 4e 33 	jmp	0x669c	; 0x669c <strrev>

00006684 <__eerd_word_m32>:
    6684:	a8 e1       	ldi	r26, 0x18	; 24
    6686:	b0 e0       	ldi	r27, 0x00	; 0
    6688:	42 e0       	ldi	r20, 0x02	; 2
    668a:	50 e0       	ldi	r21, 0x00	; 0
    668c:	0c 94 60 33 	jmp	0x66c0	; 0x66c0 <__eerd_blraw_m32>

00006690 <__eeupd_word_m32>:
    6690:	01 96       	adiw	r24, 0x01	; 1
    6692:	27 2f       	mov	r18, r23
    6694:	0e 94 6f 33 	call	0x66de	; 0x66de <__eeupd_r18_m32>
    6698:	0c 94 6e 33 	jmp	0x66dc	; 0x66dc <__eeupd_byte_m32>

0000669c <strrev>:
    669c:	dc 01       	movw	r26, r24
    669e:	fc 01       	movw	r30, r24
    66a0:	67 2f       	mov	r22, r23
    66a2:	71 91       	ld	r23, Z+
    66a4:	77 23       	and	r23, r23
    66a6:	e1 f7       	brne	.-8      	; 0x66a0 <strrev+0x4>
    66a8:	32 97       	sbiw	r30, 0x02	; 2
    66aa:	04 c0       	rjmp	.+8      	; 0x66b4 <strrev+0x18>
    66ac:	7c 91       	ld	r23, X
    66ae:	6d 93       	st	X+, r22
    66b0:	70 83       	st	Z, r23
    66b2:	62 91       	ld	r22, -Z
    66b4:	ae 17       	cp	r26, r30
    66b6:	bf 07       	cpc	r27, r31
    66b8:	c8 f3       	brcs	.-14     	; 0x66ac <strrev+0x10>
    66ba:	08 95       	ret

000066bc <__eerd_block_m32>:
    66bc:	dc 01       	movw	r26, r24
    66be:	cb 01       	movw	r24, r22

000066c0 <__eerd_blraw_m32>:
    66c0:	fc 01       	movw	r30, r24
    66c2:	e1 99       	sbic	0x1c, 1	; 28
    66c4:	fe cf       	rjmp	.-4      	; 0x66c2 <__eerd_blraw_m32+0x2>
    66c6:	06 c0       	rjmp	.+12     	; 0x66d4 <__eerd_blraw_m32+0x14>
    66c8:	ff bb       	out	0x1f, r31	; 31
    66ca:	ee bb       	out	0x1e, r30	; 30
    66cc:	e0 9a       	sbi	0x1c, 0	; 28
    66ce:	31 96       	adiw	r30, 0x01	; 1
    66d0:	0d b2       	in	r0, 0x1d	; 29
    66d2:	0d 92       	st	X+, r0
    66d4:	41 50       	subi	r20, 0x01	; 1
    66d6:	50 40       	sbci	r21, 0x00	; 0
    66d8:	b8 f7       	brcc	.-18     	; 0x66c8 <__eerd_blraw_m32+0x8>
    66da:	08 95       	ret

000066dc <__eeupd_byte_m32>:
    66dc:	26 2f       	mov	r18, r22

000066de <__eeupd_r18_m32>:
    66de:	e1 99       	sbic	0x1c, 1	; 28
    66e0:	fe cf       	rjmp	.-4      	; 0x66de <__eeupd_r18_m32>
    66e2:	9f bb       	out	0x1f, r25	; 31
    66e4:	8e bb       	out	0x1e, r24	; 30
    66e6:	e0 9a       	sbi	0x1c, 0	; 28
    66e8:	01 97       	sbiw	r24, 0x01	; 1
    66ea:	0d b2       	in	r0, 0x1d	; 29
    66ec:	02 16       	cp	r0, r18
    66ee:	31 f0       	breq	.+12     	; 0x66fc <__eeupd_r18_m32+0x1e>
    66f0:	2d bb       	out	0x1d, r18	; 29
    66f2:	0f b6       	in	r0, 0x3f	; 63
    66f4:	f8 94       	cli
    66f6:	e2 9a       	sbi	0x1c, 2	; 28
    66f8:	e1 9a       	sbi	0x1c, 1	; 28
    66fa:	0f be       	out	0x3f, r0	; 63
    66fc:	08 95       	ret

000066fe <__mulsi3>:
    66fe:	62 9f       	mul	r22, r18
    6700:	d0 01       	movw	r26, r0
    6702:	73 9f       	mul	r23, r19
    6704:	f0 01       	movw	r30, r0
    6706:	82 9f       	mul	r24, r18
    6708:	e0 0d       	add	r30, r0
    670a:	f1 1d       	adc	r31, r1
    670c:	64 9f       	mul	r22, r20
    670e:	e0 0d       	add	r30, r0
    6710:	f1 1d       	adc	r31, r1
    6712:	92 9f       	mul	r25, r18
    6714:	f0 0d       	add	r31, r0
    6716:	83 9f       	mul	r24, r19
    6718:	f0 0d       	add	r31, r0
    671a:	74 9f       	mul	r23, r20
    671c:	f0 0d       	add	r31, r0
    671e:	65 9f       	mul	r22, r21
    6720:	f0 0d       	add	r31, r0
    6722:	99 27       	eor	r25, r25
    6724:	72 9f       	mul	r23, r18
    6726:	b0 0d       	add	r27, r0
    6728:	e1 1d       	adc	r30, r1
    672a:	f9 1f       	adc	r31, r25
    672c:	63 9f       	mul	r22, r19
    672e:	b0 0d       	add	r27, r0
    6730:	e1 1d       	adc	r30, r1
    6732:	f9 1f       	adc	r31, r25
    6734:	bd 01       	movw	r22, r26
    6736:	cf 01       	movw	r24, r30
    6738:	11 24       	eor	r1, r1
    673a:	08 95       	ret

0000673c <__udivmodsi4>:
    673c:	a1 e2       	ldi	r26, 0x21	; 33
    673e:	1a 2e       	mov	r1, r26
    6740:	aa 1b       	sub	r26, r26
    6742:	bb 1b       	sub	r27, r27
    6744:	fd 01       	movw	r30, r26
    6746:	0d c0       	rjmp	.+26     	; 0x6762 <__udivmodsi4_ep>

00006748 <__udivmodsi4_loop>:
    6748:	aa 1f       	adc	r26, r26
    674a:	bb 1f       	adc	r27, r27
    674c:	ee 1f       	adc	r30, r30
    674e:	ff 1f       	adc	r31, r31
    6750:	a2 17       	cp	r26, r18
    6752:	b3 07       	cpc	r27, r19
    6754:	e4 07       	cpc	r30, r20
    6756:	f5 07       	cpc	r31, r21
    6758:	20 f0       	brcs	.+8      	; 0x6762 <__udivmodsi4_ep>
    675a:	a2 1b       	sub	r26, r18
    675c:	b3 0b       	sbc	r27, r19
    675e:	e4 0b       	sbc	r30, r20
    6760:	f5 0b       	sbc	r31, r21

00006762 <__udivmodsi4_ep>:
    6762:	66 1f       	adc	r22, r22
    6764:	77 1f       	adc	r23, r23
    6766:	88 1f       	adc	r24, r24
    6768:	99 1f       	adc	r25, r25
    676a:	1a 94       	dec	r1
    676c:	69 f7       	brne	.-38     	; 0x6748 <__udivmodsi4_loop>
    676e:	60 95       	com	r22
    6770:	70 95       	com	r23
    6772:	80 95       	com	r24
    6774:	90 95       	com	r25
    6776:	9b 01       	movw	r18, r22
    6778:	ac 01       	movw	r20, r24
    677a:	bd 01       	movw	r22, r26
    677c:	cf 01       	movw	r24, r30
    677e:	08 95       	ret

00006780 <__divmodsi4>:
    6780:	97 fb       	bst	r25, 7
    6782:	09 2e       	mov	r0, r25
    6784:	05 26       	eor	r0, r21
    6786:	0e d0       	rcall	.+28     	; 0x67a4 <__divmodsi4_neg1>
    6788:	57 fd       	sbrc	r21, 7
    678a:	04 d0       	rcall	.+8      	; 0x6794 <__divmodsi4_neg2>
    678c:	d7 df       	rcall	.-82     	; 0x673c <__udivmodsi4>
    678e:	0a d0       	rcall	.+20     	; 0x67a4 <__divmodsi4_neg1>
    6790:	00 1c       	adc	r0, r0
    6792:	38 f4       	brcc	.+14     	; 0x67a2 <__divmodsi4_exit>

00006794 <__divmodsi4_neg2>:
    6794:	50 95       	com	r21
    6796:	40 95       	com	r20
    6798:	30 95       	com	r19
    679a:	21 95       	neg	r18
    679c:	3f 4f       	sbci	r19, 0xFF	; 255
    679e:	4f 4f       	sbci	r20, 0xFF	; 255
    67a0:	5f 4f       	sbci	r21, 0xFF	; 255

000067a2 <__divmodsi4_exit>:
    67a2:	08 95       	ret

000067a4 <__divmodsi4_neg1>:
    67a4:	f6 f7       	brtc	.-4      	; 0x67a2 <__divmodsi4_exit>
    67a6:	90 95       	com	r25
    67a8:	80 95       	com	r24
    67aa:	70 95       	com	r23
    67ac:	61 95       	neg	r22
    67ae:	7f 4f       	sbci	r23, 0xFF	; 255
    67b0:	8f 4f       	sbci	r24, 0xFF	; 255
    67b2:	9f 4f       	sbci	r25, 0xFF	; 255
    67b4:	08 95       	ret

000067b6 <__prologue_saves__>:
    67b6:	2f 92       	push	r2
    67b8:	3f 92       	push	r3
    67ba:	4f 92       	push	r4
    67bc:	5f 92       	push	r5
    67be:	6f 92       	push	r6
    67c0:	7f 92       	push	r7
    67c2:	8f 92       	push	r8
    67c4:	9f 92       	push	r9
    67c6:	af 92       	push	r10
    67c8:	bf 92       	push	r11
    67ca:	cf 92       	push	r12
    67cc:	df 92       	push	r13
    67ce:	ef 92       	push	r14
    67d0:	ff 92       	push	r15
    67d2:	0f 93       	push	r16
    67d4:	1f 93       	push	r17
    67d6:	cf 93       	push	r28
    67d8:	df 93       	push	r29
    67da:	cd b7       	in	r28, 0x3d	; 61
    67dc:	de b7       	in	r29, 0x3e	; 62
    67de:	ca 1b       	sub	r28, r26
    67e0:	db 0b       	sbc	r29, r27
    67e2:	0f b6       	in	r0, 0x3f	; 63
    67e4:	f8 94       	cli
    67e6:	de bf       	out	0x3e, r29	; 62
    67e8:	0f be       	out	0x3f, r0	; 63
    67ea:	cd bf       	out	0x3d, r28	; 61
    67ec:	09 94       	ijmp

000067ee <__epilogue_restores__>:
    67ee:	2a 88       	ldd	r2, Y+18	; 0x12
    67f0:	39 88       	ldd	r3, Y+17	; 0x11
    67f2:	48 88       	ldd	r4, Y+16	; 0x10
    67f4:	5f 84       	ldd	r5, Y+15	; 0x0f
    67f6:	6e 84       	ldd	r6, Y+14	; 0x0e
    67f8:	7d 84       	ldd	r7, Y+13	; 0x0d
    67fa:	8c 84       	ldd	r8, Y+12	; 0x0c
    67fc:	9b 84       	ldd	r9, Y+11	; 0x0b
    67fe:	aa 84       	ldd	r10, Y+10	; 0x0a
    6800:	b9 84       	ldd	r11, Y+9	; 0x09
    6802:	c8 84       	ldd	r12, Y+8	; 0x08
    6804:	df 80       	ldd	r13, Y+7	; 0x07
    6806:	ee 80       	ldd	r14, Y+6	; 0x06
    6808:	fd 80       	ldd	r15, Y+5	; 0x05
    680a:	0c 81       	ldd	r16, Y+4	; 0x04
    680c:	1b 81       	ldd	r17, Y+3	; 0x03
    680e:	aa 81       	ldd	r26, Y+2	; 0x02
    6810:	b9 81       	ldd	r27, Y+1	; 0x01
    6812:	ce 0f       	add	r28, r30
    6814:	d1 1d       	adc	r29, r1
    6816:	0f b6       	in	r0, 0x3f	; 63
    6818:	f8 94       	cli
    681a:	de bf       	out	0x3e, r29	; 62
    681c:	0f be       	out	0x3f, r0	; 63
    681e:	cd bf       	out	0x3d, r28	; 61
    6820:	ed 01       	movw	r28, r26
    6822:	08 95       	ret

00006824 <_exit>:
    6824:	f8 94       	cli

00006826 <__stop_program>:
    6826:	ff cf       	rjmp	.-2      	; 0x6826 <__stop_program>

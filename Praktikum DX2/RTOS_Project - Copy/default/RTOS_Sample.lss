
RTOS_Sample.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000066fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000146  00800060  000066fc  00006790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000698  008001a6  008001a6  000068d6  2**0
                  ALLOC
  3 .stab         00000ed0  00000000  00000000  000068d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000403  00000000  00000000  000077a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000178  00000000  00000000  00007bab  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000006f0  00000000  00000000  00007d23  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002ca6  00000000  00000000  00008413  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eca  00000000  00000000  0000b0b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002cba  00000000  00000000  0000bf83  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000005c0  00000000  00000000  0000ec40  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000122c  00000000  00000000  0000f200  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001c4a  00000000  00000000  0001042c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000465  00000000  00000000  00012076  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000a0  00000000  00000000  000124db  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 21 	jmp	0x4254	; 0x4254 <__ctors_end>
       4:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       8:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
       c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      10:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      14:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      18:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      1c:	0c 94 36 2f 	jmp	0x5e6c	; 0x5e6c <__vector_7>
      20:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      24:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      28:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      2c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      30:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      34:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      38:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      3c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      40:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      44:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      48:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      4c:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>
      50:	0c 94 47 21 	jmp	0x428e	; 0x428e <__bad_interrupt>

00000054 <sample_data>:
      54:	85 85 85 83 81 81 83 85 87 8a 8b 89 88 87 85 84     ................
      64:	85 84 84 85 82 82 84 86 8a 8d 91 91 91 90 90 8f     ................
      74:	8d 8c 8b 8b 8c 8b 8a 89 89 89 87 84 82 7f 7a 76     ..............zv
      84:	75 75 77 77 78 7d 82 85 86 88 88 87 84 81 7f 7e     uuwwx}.........~
      94:	7d 7f 7f 81 85 85 87 89 8c 8d 8e 91 90 90 90 8e     }...............
      a4:	8c 8a 88 86 83 83 82 84 86 88 8b 8f 94 94 95 96     ................
      b4:	97 97 98 98 98 99 97 95 91 8d 89 84 81 80 80 80     ................
      c4:	7f 7f 80 80 7f 7f 80 82 83 85 86 8a 8e 91 93 93     ................
      d4:	93 91 90 8f 8e 8f 90 91 93 92 91 91 8e 8b 87 7f     ................
      e4:	77 70 6b 67 68 6a 6f 72 75 7a 7f 84 8a 8d 91 95     wpkghjoruz......
      f4:	97 97 98 99 99 96 90 8a 85 82 80 7e 7e 7d 79 75     ...........~~}yu
     104:	71 6f 6f 6e 6d 6e 73 79 80 87 8d 91 93 94 94 91     qoonmnsy........
     114:	89 81 78 71 6d 6b 6c 70 76 7c 82 88 8b 8c 8f 8f     ..xqmklpv|......
     124:	8d 8a 88 88 8a 89 87 86 85 87 87 87 87 8a 8b 8b     ................
     134:	88 86 85 83 81 80 7e 7e 80 81 84 88 8c 8d 8d 8d     ......~~........
     144:	8c 8a 88 86 85 85 83 82 81 80 7f 80 80 81 81 83     ................
     154:	85 86 88 8a 8a 89 89 88 85 83 82 82 84 86 8a 8d     ................
     164:	90 91 92 93 92 90 8c 88 85 82 7f 7e 7e 7e 7f 81     ...........~~~..
     174:	85 88 8b 8d 8d 8c 8c 8a 88 86 84 83 85 88 8b 8e     ................
     184:	8f 8f 8d 89 84 80 7c 7a 79 78 78 7b 7d 7f 82 83     ......|zyxx{}...
     194:	85 87 87 88 8a 8d 90 93 96 9a 9b 9b 9b 9a 9a 99     ................
     1a4:	98 96 93 91 8e 8c 8a 87 84 82 80 80 80 80 80 81     ................
     1b4:	82 83 85 84 86 88 89 87 86 86 87 86 86 86 88 8a     ................
     1c4:	8c 8d 8e 8f 8f 8d 8a 88 86 85 82 80 7f 7f 81 84     ................
     1d4:	88 8a 8e 91 93 94 95 95 93 90 8d 8c 8b 8b 8c 90     ................
     1e4:	93 96 98 99 9b 9b 96 91 8c 86 83 80 7d 7b 7c 7c     ............}{||
     1f4:	7e 81 84 88 8a 8d 8f 90 92 90 8c 8a 86 81 7c 7a     ~.............|z
     204:	78 77 76 73 73 73 75 79 7c 7f 80 82 83 83 83 81     xwvsssuy|.......
     214:	7d 79 76 74 72 73 75 77 7a 7c 7f 80 82 85 88 8b     }yvtrsuwz|......
     224:	8d 8e 8f 91 92 93 93 93 92 90 8f 8c 8b 8c 8a 8a     ................
     234:	8a 88 86 82 7c 79 76 74 74 73 73 75 79 7e 82 85     ....|yvttssuy~..
     244:	86 88 89 89 87 85 85 84 83 82 7f 7d 7b 77 75 75     ...........}{wuu
     254:	76 75 75 73 74 76 79 7c 7d 7f 81 83 84 86 86 84     vuustvy|}.......
     264:	80 7e 7d 7d 7d 7e 81 86 8b 8c 8d 8e 8e 8c 89 85     .~}}}~..........
     274:	81 7e 7b 79 77 77 78 77 7a 7e 80 84 85 85 86 86     .~{ywwxwz~......
     284:	86 86 86 84 81 80 7f 7d 7b 7b 7a 7a 7c 7d 7f 81     .......}{{zz|}..
     294:	81 80 7f 81 81 81 81 81 83 84 85 85 85 84 82 81     ................
     2a4:	81 7f 7e 7f 7e 7d 80 80 80 7f 7d 7c 7a 79 77 75     ..~.~}....}|zywu
     2b4:	76 75 76 77 79 7c 7f 83 83 82 82 82 83 81 82 83     vuvwy|..........
     2c4:	84 84 84 87 8b 8d 90 92 97 9a 9b 9b 9b 9a 95 8e     ................
     2d4:	86 81 7d 7a 75 72 70 71 71 70 71 74 77 7a 7e 81     ..}zurpqqpqtwz~.
     2e4:	84 85 86 86 85 85 85 85 86 89 8e 91 91 8f 8d 8c     ................
     2f4:	87 7f 77 6e 68 63 5f 5f 61 64 67 6b 6f 74 7b 84     ..wnhc__adgkot{.
     304:	88 87 84 81 81 83 85 85 85 85 85 86 87 88 87 85     ................
     314:	83 7f 7d 78 77 75 73 71 71 72 72 75 77 7b 80 82     ..}xwusqqrruw{..
     324:	84 85 87 87 84 81 7f 7e 80 83 86 8a 8b 8c 8d 8d     .......~........
     334:	8e 90 92 91 8c 87 84 84 82 7c 77 73 71 6f 6f 71     .........|wsqooq
     344:	75 77 74 71 70 72 75 75 77 7b 82 87 89 8c 8f 93     uwtqpruuw{......
     354:	94 91 8f 8c 87 82 7d 77 71 6c 68 64 62 62 62 66     ......}wqlhdbbbf
     364:	6c 72 77 78 7c 7f 7f 80 80 7f 7e 7f 80 81 7f 7d     lrwx|.....~....}
     374:	7b 7b 7a 77 76 77 78 79 7d 82 85 85 85 84 84 83     {{zwvwxy}.......
     384:	80 7c 78 77 77 75 72 6d 6c 6e 71 74 73 76 7c 83     .|xwwurmlnqtsv|.
     394:	8c 92 95 96 94 90 8b 87 82 7d 77 72 70 6f 6e 6e     .........}wrponn
     3a4:	6f 70 71 73 77 7c 7e 7f 80 80 7e 7d 7f 81 81 7d     opqsw|~...~}...}
     3b4:	79 78 78 79 79 7a 79 7b 80 83 84 80 7d 7c 7b 7b     yxxyyzy{....}|{{
     3c4:	7b 7d 7f 81 83 86 88 89 8a 88 88 8a 8c 8f 8f 8e     {}..............
     3d4:	8f 8e 8e 8d 8b 88 85 86 89 8a 8a 8b 8a 86 83 82     ................
     3e4:	82 81 7e 7b 79 78 7a 79 78 78 7b 7d 7e 81 85 8c     ..~{yxzyxx{}~...
     3f4:	8e 8c 8f 8f 8d 84 7d 7b 79 76 73 6f 6d 71 74 74     ......}{yvsomqtt
     404:	74 77 7b 7e 7d 7a 7e 82 82 81 80 83 84 84 84 87     tw{~}z~.........
     414:	8b 8f 90 8e 8b 89 86 82 7d 79 77 75 75 76 77 79     ........}ywuuvwy
     424:	7a 7b 7f 84 88 89 8a 8d 8f 91 94 97 99 98 98 99     z{..............
     434:	9a 98 92 8f 8d 8a 87 86 87 87 8a 88 86 85 86 89     ................
     444:	8a 8e 8f 8d 8b 8a 8b 8d 8e 8f 8f 92 95 96 94 8e     ................
     454:	89 84 7f 7c 7b 7b 7b 7b 79 78 7b 7d 7a 77 76 77     ...|{{{{yx{}zwvw
     464:	7a 7c 7d 80 86 89 89 89 88 87 85 80 7b 79 7b 7f     z|}.........{y{.
     474:	82 83 87 8a 8b 88 83 80 7e 7a 75 76 7b 80 85 8a     ........~zuv{...
     484:	90 95 96 94 90 8d 88 83 80 7e 7d 7f 7f 80 80 80     .........~}.....
     494:	81 80 80 82 83 86 8a 90 95 9b a0 a4 a3 a1 9d 99     ................
     4a4:	95 8e 85 7e 7b 7a 77 75 74 76 78 79 77 75 75 7a     ...~{zwutvxywuuz
     4b4:	80 82 84 8a 92 95 92 90 91 94 92 8e 88 83 80 7b     ...............{
     4c4:	76 73 71 6c 69 6a 6e 74 77 79 7e 87 8e 92 94 92     vsqlijntwy~.....
     4d4:	8f 8a 86 83 81 82 84 86 87 88 88 89 89 84 7d 78     ..............}x
     4e4:	77 79 77 73 6e 6c 6c 6d 70 78 82 8d 93 95 96 98     wywsnllmpx......
     4f4:	98 92 88 7e 7c 7d 7d 7c 7c 81 87 8a 88 85 84 85     ...~|}}||.......
     504:	82 7a 74 76 79 7a 7d 7f 82 88 8b 8d 8e 8f 8c 87     .ztvyz}.........
     514:	83 82 87 8a 87 81 7e 7e 80 81 81 81 83 86 8a 8c     ......~~........
     524:	8b 8a 87 83 7f 7c 76 73 72 76 7a 7a 7b 7e 85 89     .....|vsrvzz{~..
     534:	87 85 83 82 81 83 88 8b 89 86 87 89 8c 8d 8b 87     ................
     544:	87 8a 8c 8a 87 86 87 86 83 7f 7f 81 83 84 83 80     ................
     554:	7b 7b 7f 82 81 79 77 7e 85 84 80 7e 82 89 8d 90     {{...yw~...~....
     564:	90 8f 8d 8b 87 83 7e 78 72 71 70 6f 70 77 7d 7c     ......~xrqpopw}|
     574:	78 79 80 87 88 83 81 82 84 85 8a 8f 93 91 8d 8e     xy..............
     584:	92 92 89 7e 7a 7b 7b 7b 7b 79 77 77 7d 86 89 8d     ...~z{{{{yww}...
     594:	90 94 97 96 92 90 90 8c 86 80 80 86 8c 8e 8b 8b     ................
     5a4:	8e 8f 8e 8f 90 8e 89 86 89 90 92 90 8d 8b 90 8d     ................
     5b4:	85 83 81 88 7f 77 7e 87 91 8a 86 86 8a 8f 91 97     .....w~.........
     5c4:	97 95 91 8c 90 92 8c 7c 6d 6c 70 72 6d 67 65 67     .......|mlprmgeg
     5d4:	6a 6e 76 7b 7c 7d 7f 86 8b 87 80 79 78 79 72 6a     jnv{|}.....yxyrj
     5e4:	67 6a 6c 67 63 61 66 6c 6a 66 68 6d 74 77 77 7b     gjlgcafljfhmtww{
     5f4:	80 84 84 84 83 80 7d 7b 7c 7e 82 83 84 84 86 86     ......}{|~......
     604:	82 7d 7b 80 87 8e 91 93 9a a0 a3 a1 9c 97 93 90     .}{.............
     614:	8c 8a 8b 90 8e 87 82 83 88 83 79 73 77 80 87 8c     ..........ysw...
     624:	91 97 9e a2 a2 a5 a6 9f 93 8a 86 80 78 6d 65 65     ............xmee
     634:	6c 71 70 6d 6f 7a 86 8c 8f 94 99 9b 9c 9f a5 a4     lqpmoz..........
     644:	98 8c 8a 91 94 8e 82 7a 78 79 7b 7d 7e 78 71 71     .......zxy{}~xqq
     654:	7c 88 8d 85 7b 77 7c 81 7f 7b 77 76 77 77 75 78     |...{w|..{wvwwux
     664:	7f 84 85 83 84 8d 96 99 99 95 90 8d 8d 90 90 88     ................
     674:	7f 79 77 76 75 72 6d 6d 71 76 76 77 7f 8a 8e 87     .ywvurmmqvvw....
     684:	81 87 91 96 97 93 8f 8f 94 9c a0 9c 92 88 8a 94     ................
     694:	9c 9a 8f 84 80 82 84 81 7c 78 75 75 77 7a 7c 7b     ........|xuuwz|{
     6a4:	79 78 79 7f 86 88 89 8d 8f 8c 86 84 87 84 7d 75     yxy...........}u
     6b4:	72 75 78 7a 7c 7f 7f 7c 76 78 83 8c 8d 85 7f 82     ruxz|..|vx......
     6c4:	8b 8e 87 7f 7b 79 7b 7a 78 78 75 74 75 78 7d 7f     ....{y{zxxutux}.
     6d4:	7e 7d 7e 7e 7c 7c 7f 84 8a 8b 89 87 89 8b 8a 85     ~}~~||..........
     6e4:	7e 7a 79 7a 82 87 86 87 89 8c 8a 86 88 8e 91 8a     ~zyz............
     6f4:	82 81 83 86 87 85 7f 77 72 77 85 8c 88 84 85 91     .......wrw......
     704:	a0 a5 9d 8d 82 80 83 84 7d 79 7d 86 8a 89 87 88     ........}y}.....
     714:	8b 88 83 7f 80 83 84 88 90 96 98 95 92 93 93 91     ................
     724:	8f 8f 8d 87 83 84 8b 8f 89 80 7c 83 8f 97 93 88     ..........|.....
     734:	82 84 8c 92 8f 85 7a 7c 84 88 87 84 84 83 7f 82     ......z|........
     744:	89 8f 8a 82 7d 81 8a 8d 87 83 87 8d 8d 87 81 83     ....}...........
     754:	86 87 85 82 80 83 89 90 93 8e 85 85 8b 8e 8b 86     ................
     764:	84 86 88 87 87 87 84 80 82 88 8e 92 93 95 98 9a     ................
     774:	98 92 8c 85 7f 7b 7a 7a 79 79 7a 80 86 88 87 87     .....{zzyyz.....
     784:	88 90 98 99 91 88 87 8d 8e 89 87 88 89 88 8a 93     ................
     794:	9a 96 8b 83 85 8f 91 86 7a 7a 84 8a 82 7d 83 8b     ........zz...}..
     7a4:	8e 8c 8e 94 99 99 95 92 91 8c 86 80 80 84 8b 8f     ................
     7b4:	8d 8c 90 98 a0 a1 99 8e 90 97 97 8f 84 82 85 87     ................
     7c4:	85 80 80 83 86 81 74 73 81 8d 8a 7c 76 7f 88 87     ......ts...|v...
     7d4:	7d 76 76 79 7a 7d 81 83 7c 73 71 7a 81 7e 76 74     }vvyz}..|sqz.~vt
     7e4:	7c 80 80 84 8f 97 92 8a 8f 9c a2 9a 90 93 9e a4     |...............
     7f4:	9d 91 91 99 9b 8a 78 77 7e 83 81 7b 78 7a 82 8b     ......xw~..{xz..
     804:	8d 89 8c 95 97 92 8b 8d 91 8e 85 80 85 8c 8f 8c     ................
     814:	89 8d 94 95 92 8e 91 91 89 81 84 88 82 77 73 79     .............wsy
     824:	80 80 7e 81 85 85 85 8c 8d 80 7a 84 91 8c 7c 7b     ..~.......z...|{
     834:	8f a1 9f 91 8b 97 a5 9e 87 75 76 83 83 74 66 63     .........uv..tfc
     844:	6c 74 77 78 7b 7e 7c 7b 7d 88 90 8a 7b 71 73 7c     ltwx{~|{}...{qs|
     854:	7d 76 70 70 76 77 75 75 7a 7e 79 73 71 76 7a 79     }vppvwuuz~ysqvzy
     864:	7c 7e 78 6c 68 76 86 84 73 6c 78 8b 92 8e 8c 8f     |~xlhv..slx.....
     874:	94 93 8b 84 86 87 80 79 73 72 76 7b 81 85 7d 6e     .......ysrv{..}n
     884:	67 6c 79 83 7e 76 77 7d 85 8d 96 9a 8c 74 6a 7a     gly.~vw}.....tjz
     894:	93 97 89 7a 7a 85 92 9b 9a 94 8b 81 7e 7f 84 83     ...zz.......~...
     8a4:	79 6d 61 5b 60 6d 77 74 66 5d 6a 82 8c 85 7f 7f     yma[`mwtf]j.....
     8b4:	7b 78 7c 84 88 81 76 6e 72 7d 87 86 7a 71 6e 70     {x|...vnr}..zqnp
     8c4:	71 73 77 76 6f 6b 6f 74 7c 8b 98 98 8a 7f 88 9d     qswvokot|.......
     8d4:	a7 96 7e 71 70 77 81 8d 8f 83 75 72 82 99 a5 96     ..~qpw....ur....
     8e4:	79 65 6a 81 92 91 7f 6c 66 73 88 92 8e 86 81 7d     yej....lfs.....}
     8f4:	7f 8b a0 ad a1 88 79 82 95 9f 9a 89 76 70 7b 8f     ......y.....vp{.
     904:	9a 96 85 71 6a 7c 95 a0 97 84 78 78 87 9b a0 8f     ...qj|....xx....
     914:	76 6e 77 82 88 8a 8c 8a 88 8c 97 a4 ad aa 99 86     vnw.............
     924:	81 88 94 9b 92 7f 70 73 82 90 94 8a 81 7a 79 85     ......ps.....zy.
     934:	97 9a 81 62 58 6d 88 8d 7d 69 65 74 87 90 90 8c     ...bXm..}iet....
     944:	82 79 7c 8b 92 8a 81 7e 7a 70 6c 77 83 7c 65 55     .y|....~zplw.|eU
     954:	5c 74 84 7c 6b 66 6d 74 79 84 8f 89 75 6d 81 9f     \t.|kfmty...um..
     964:	a8 92 79 6f 7c 91 94 88 7b 73 74 7f 8b 8e 88 7e     ..yo|...{st....~
     974:	79 7c 7f 85 8f 92 84 6f 6f 89 a0 9d 88 7f 8a 95     y|.....oo.......
     984:	98 9b 9f 99 8a 7c 7d 91 a1 99 7d 63 63 7e 97 94     .....|}...}cc~..
     994:	7a 63 63 7b 97 9b 86 71 72 83 8f 93 95 95 91 81     zcc{...qr.......
     9a4:	76 85 9a 9d 87 66 57 60 76 86 81 6f 5c 5d 6d 7c     v....fW`v..o\]m|
     9b4:	84 87 81 6e 63 70 8c 9a 91 7a 6a 6f 87 9e 9c 8a     ...ncp...zjo....
     9c4:	75 6c 6d 7a 8e 91 78 5b 5a 77 8d 85 72 6a 6e 79     ulmz..x[Zw..rjny
     9d4:	81 84 8e 93 8b 79 72 87 9c 98 7f 6a 72 90 a1 96     .....yr....jr...
     9e4:	82 7d 8c 9d 9a 86 79 7c 83 7f 74 6a 70 7d 83 79     .}....y|..tjp}.y
     9f4:	6f 7e 96 9b 88 72 7a 97 a0 90 80 7f 88 8f 91 90     o~...rz.........
     a04:	8a 85 88 8f 90 8c 8b 8d 88 76 70 81 97 96 7c 66     .........vp...|f
     a14:	73 9a ae 9c 7c 71 86 a4 aa 95 7e 7b 89 8f 89 83     s...|q....~{....
     a24:	7f 7a 77 7d 87 85 76 6f 7b 88 87 73 5c 5d 75 8a     .zw}..vo{..s\]u.
     a34:	88 74 64 6d 86 93 88 7a 7d 85 82 78 7b 88 8a 7d     .tdm...z}..x{..}
     a44:	77 83 8f 91 8c 87 88 8d 8d 86 7e 80 88 7f 64 55     w.........~...dU
     a54:	67 82 84 6c 5f 6e 87 99 9a 90 8c 90 95 99 9f a9     g..l_n..........
     a64:	aa 9b 8b 92 a1 a0 8f 7e 7e 83 7e 73 6f 74 7d 83     .......~~.~sot}.
     a74:	7f 78 7a 83 85 83 80 7d 77 71 76 84 87 79 6d 71     .xz....}wqv..ymq
     a84:	84 96 99 8a 7a 7f 94 a0 95 84 81 86 84 7a 76 79     ....z........zvy
     a94:	79 74 72 71 6f 72 7d 85 82 79 7f 8d 8a 7d 7d 86     ytrqor}..y...}}.
     aa4:	89 7e 70 78 8e 98 8c 82 8b 97 94 8b 85 83 82 7e     .~px...........~
     ab4:	7a 75 6f 6c 71 78 79 77 75 73 79 88 92 8c 80 7d     zuolqxywusy....}
     ac4:	83 88 82 78 6b 64 6b 77 7c 76 6f 73 7c 7e 7d 85     ...xkdkw|vos|~}.
     ad4:	8c 83 71 70 80 8e 8a 80 77 73 72 73 77 7a 77 73     ..qp....wsrswzws
     ae4:	6f 6f 7b 8e 9b 98 8d 85 8e a9 bd b2 92 7c 82 9c     oo{..........|..
     af4:	ab 9c 80 6f 74 86 8b 83 7f 80 7d 73 6e 78 82 7c     ...ot.....}snx.|
     b04:	6f 67 69 71 7b 80 80 83 8c 90 8c 8c 98 a2 96 7b     ogiq{..........{
     b14:	74 87 96 8e 7a 6e 74 7f 7b 6b 63 6b 75 6f 60 68     t...znt.{kckuo`h
     b24:	81 8b 7b 69 6b 79 83 89 8e 8c 7f 7b 85 92 96 8a     ..{iky.....{....
     b34:	7d 77 77 7e 83 7f 71 66 6c 7e 8b 85 76 73 80 8d     }ww~..qfl~..vs..
     b44:	8d 83 79 78 81 85 7e 79 83 90 89 78 74 83 98 99     ..yx..~y...xt...
     b54:	8a 84 92 a2 9e 92 91 9b a1 95 85 82 86 87 7e 74     ..............~t
     b64:	71 77 81 85 7e 78 83 91 91 87 86 92 99 93 86 83     qw..~x..........
     b74:	8c 94 8c 78 6d 74 82 87 85 89 8b 86 7f 81 93 a5     ...xmt..........
     b84:	a4 94 8a 92 a1 a6 9a 86 7b 84 93 98 8f 81 80 8c     ........{.......
     b94:	94 8f 82 7c 7c 78 73 73 7a 7e 81 85 85 7f 7b 7f     ...||xssz~....{.
     ba4:	8b 98 96 88 7e 83 8f 95 91 8e 94 92 87 81 89 97     ....~...........
     bb4:	95 84 7e 87 90 90 83 72 71 82 90 8c 7b 6f 73 82     ..~....rq...{os.
     bc4:	93 9b 95 88 7b 77 81 8a 87 7c 6f 6c 77 88 90 8c     ....{w...|olw...
     bd4:	83 7e 87 99 a7 a7 9a 8e 95 a6 af a5 93 8c 8c 8f     .~..............
     be4:	93 95 8b 75 65 6a 7f 8b 82 72 70 80 93 93 89 87     ...uej...rp.....
     bf4:	8f 91 88 85 88 7e 71 6d 77 85 86 78 6d 6d 78 85     .....~qmw..xmmx.
     c04:	87 7d 75 7b 88 92 94 8d 84 83 8a 8a 80 70 6e 82     .}u{.........pn.
     c14:	91 87 72 6f 7f 88 83 80 84 86 7e 72 6e 72 7c 7b     ..ro......~rnr|{
     c24:	73 6b 68 6e 77 7c 80 82 81 7e 81 86 81 79 7a 81     skhnw|...~...yz.
     c34:	83 7b 76 79 7f 7f 7a 7e 89 8c 84 79 77 7d 82 82     .{vy..z~...yw}..
     c44:	7a 74 71 6e 73 7e 88 82 71 6d 77 7c 78 76 79 7e     ztqns~..qmw|xvy~
     c54:	80 82 83 82 8a 95 95 8a 82 87 8f 8b 83 84 8c 8f     ................
     c64:	85 77 73 75 7d 7d 73 6b 70 7a 81 88 8b 87 7f 7c     .wsu}}skpz.....|
     c74:	87 94 8e 7f 7d 8e 9e 98 85 77 73 79 7f 81 7d 74     ....}....wsy..}t
     c84:	72 7a 8b 9a 9c 93 88 85 87 89 88 86 7d 69 63 79     rz..........}icy
     c94:	91 89 6c 63 77 87 86 7a 73 79 81 85 87 88 8d 92     ..lcw..zsy......
     ca4:	8b 7f 7f 88 8d 87 77 77 87 8f 8f 84 81 87 8b 8a     ......ww........
     cb4:	81 74 70 83 9d a2 91 84 91 a5 a8 9a 8d 87 7f 71     .tp............q
     cc4:	6e 7c 89 87 75 6b 80 a3 af 99 86 8f a7 ae 9a 83     n|..uk..........
     cd4:	81 91 9c 94 7e 6e 70 80 90 8c 7a 6d 6e 7e 8c 8a     ....~np...zmn~..
     ce4:	7f 77 7c 88 93 95 90 8a 86 89 94 96 8a 7f 7a 80     .w|...........z.
     cf4:	90 9a 92 7d 69 6f 87 93 88 70 69 7c 92 8d 76 6c     ...}io...pi|..vl
     d04:	7c 92 8e 78 72 83 96 97 88 7b 80 8c 91 86 7d 7f     |..xr....{....}.
     d14:	80 80 7f 7d 7b 78 71 6c 69 6e 7b 7f 73 6d 7a 8d     ...}{xqlin{.smz.
     d24:	92 8a 7f 80 8c 93 8f 84 7e 8c 98 8b 6e 63 75 95     ........~...ncu.
     d34:	9b 7f 6a 6e 82 8f 83 72 71 7d 86 7c 76 85 97 93     ..jn...rq}.|v...
     d44:	7e 72 79 85 84 74 6b 6e 76 79 7a 80 85 8a 89 80     ~ry..tknvyz.....
     d54:	79 7b 88 89 7c 6f 73 85 95 98 92 8f 8f 95 a2 a6     y{..|os.........
     d64:	9b 8d 8d 93 8e 85 8a 91 89 74 69 73 83 88 80 74     .........tis...t
     d74:	72 79 88 8e 89 86 88 88 8b 95 98 87 7b 85 96 97     ry..........{...
     d84:	83 74 73 79 81 85 7a 64 58 69 88 8e 75 56 53 6f     .tsy..zdXi..uVSo
     d94:	85 81 71 6e 76 7f 88 93 96 8a 7a 76 84 98 9f 92     ..qnv.....zv....
     da4:	80 80 93 9f 91 7d 7d 8b 8f 7b 65 6c 83 8a 7c 6d     .....}}..{el..|m
     db4:	6f 76 78 7e 8f 99 8c 77 79 97 b2 b0 9c 8a 8e a3     ovx~...wy.......
     dc4:	ab a0 96 92 93 8e 82 82 91 9b 92 81 76 73 77 7d     ............vsw}
     dd4:	7c 75 6d 67 6b 75 80 89 8e 8a 87 98 ad b1 a1 8f     |umgku..........
     de4:	8b 8d 87 7c 79 7e 81 75 5c 4e 5f 7f 83 63 49 5e     ...|y~.u\N_..cI^
     df4:	84 8b 7e 80 94 9c 88 76 8b ab a8 82 64 66 80 90     ..~....v....df..
     e04:	86 7c 80 89 86 7f 80 8e 93 83 6a 5d 64 77 83 77     .|........j]dw.w
     e14:	5c 50 61 7a 85 82 7a 71 6a 6e 83 98 98 86 77 78     \Paz..zqjn....wx
     e24:	8c 9a 97 91 92 95 8c 78 70 80 98 94 77 56 52 80     .......xp...wVR.
     e34:	b5 be 8b 4e 4b 7f a3 96 74 5f 65 6c 75 8d ad ac     ...NK...t_elu...
     e44:	81 58 64 a2 cc b2 72 50 69 94 a0 8c 74 71 7e 86     .Xd...rPi...tq~.
     e54:	8d 9d a1 8f 77 78 90 9f 8d 77 71 75 79 79 85 8a     ....wx...wquyy..
     e64:	7f 73 81 a0 a6 96 84 86 95 9d 96 86 75 6c 7e 8f     .s..........ul~.
     e74:	88 70 5f 61 72 7f 7b 78 78 7b 7d 85 91 9e 9d 87     .p_ar.{xx{}.....
     e84:	73 7a 9e b5 a9 85 71 7b 92 a1 93 75 63 76 99 a9     sz....q{...ucv..
     e94:	90 72 73 8a 94 88 7e 86 93 8a 77 73 8c a1 95 75     .rs...~...ws...u
     ea4:	68 85 a7 ae 93 7b 87 aa b4 9e 8a 8f a3 a3 92 89     h....{..........
     eb4:	90 92 89 7b 7a 86 8e 8d 7d 73 72 7c 84 8a 8a 85     ...{z...}sr|....
     ec4:	82 82 88 8c 8b 94 9d 9a 93 93 9d a6 9d 82 6c 72     ..............lr
     ed4:	7d 7c 72 6a 72 80 7e 7c 88 9f ad a3 8d 87 95 a1     }|rjr.~|........
     ee4:	9d 8d 85 89 88 87 8f 9f 9f 8b 75 75 8c a3 9d 79     ..........uu...y
     ef4:	5c 5b 77 91 90 77 67 71 85 95 9b 9c 92 7f 70 71     \[w..wgq......pq
     f04:	88 a0 9d 7c 66 73 93 a3 98 8e 8d 89 82 84 8f 8e     ...|fs..........
     f14:	7c 6b 65 65 6d 7e 83 6e 53 55 71 85 82 74 68 64     |keem~.nSUq..thd
     f24:	68 6f 75 7a 7a 7a 7c 7e 8d a4 ac 96 76 73 88 90     houzzz|~....vs..
     f34:	81 6e 6c 70 70 73 7c 7f 76 70 7c 8c 8a 82 88 95     .nlpps|.vp|.....
     f44:	96 88 7c 89 9c a0 97 8e 93 a2 a4 96 8e 8f 92 8d     ..|.............
     f54:	85 84 87 81 70 68 70 76 75 72 6f 70 6f 72 86 95     ....phpvuropor..
     f64:	8e 84 88 9b a9 a1 91 8f 9d a4 9f 95 91 90 8e 8f     ................
     f74:	96 95 86 75 70 77 7a 73 70 75 7f 86 82 7c 7e 85     ...upwzspu...|~.
     f84:	8a 84 7e 88 95 95 88 81 8b 97 96 88 82 87 86 82     ..~.............
     f94:	84 8c 92 8e 84 7c 7a 82 8b 8c 7a 6a 6f 85 9f a4     .....|z...zjo...
     fa4:	8e 7e 86 9c a5 95 83 80 81 82 87 94 9a 94 88 81     .~..............
     fb4:	8b 97 9c 97 86 7a 80 88 85 77 66 63 6d 78 7c 7c     .....z...wfcmx||
     fc4:	7e 81 86 8a 89 8b 89 88 8d 92 9a a3 9f 91 84 84     ~...............
     fd4:	97 a3 96 7f 74 7b 88 86 75 68 68 75 82 7e 78 7a     ....t{..uhhu.~xz
     fe4:	84 8d 8c 88 83 85 8f 97 90 8a 90 95 93 8a 80 82     ................
     ff4:	85 82 84 8a 82 70 69 72 7d 7a 6a 5c 58 63 75 7f     .....pir}zj\Xcu.
    1004:	7e 76 70 71 72 77 81 83 75 69 71 81 88 7c 70 75     ~vpqrw..uiq..|pu
    1014:	80 83 80 85 89 81 74 71 75 7b 75 6c 6f 75 82 8f     ......tqu{ulou..
    1024:	95 92 8e 8e 8c 8d 8e 8e 8c 84 84 84 7c 7c 87 97     ............||..
    1034:	9b 8f 8b 99 a5 9f 8d 86 93 9a 8b 7a 74 85 98 92     ...........zt...
    1044:	80 7a 88 9c a0 95 8e 91 93 8c 85 86 88 7c 6e 71     .z...........|nq
    1054:	7e 88 87 7c 77 77 7b 87 8b 82 76 78 86 8c 86 79     ~..|ww{...vx...y
    1064:	74 7b 80 81 7a 76 7c 84 84 7a 71 75 80 86 87 7c     t{..zv|..zqu...|
    1074:	75 79 7f 85 81 7f 84 89 89 84 80 83 88 8c 84 7d     uy.............}
    1084:	81 8d 91 8a 88 8e 99 92 82 7e 88 8d 83 71 6b 79     .........~...qky
    1094:	86 83 7a 74 7c 8a 92 90 8b 90 9c a3 9d 93 90 8f     ..zt|...........
    10a4:	90 8e 83 82 88 8b 8b 8b 8c 8b 88 84 86 8c 88 7e     ...............~
    10b4:	78 7d 8a 95 90 88 8e 97 99 95 90 91 94 94 94 93     x}..............
    10c4:	8f 89 86 85 81 76 69 63 6b 78 7b 79 7a 85 90 94     .....vickx{yz...
    10d4:	91 8a 86 81 83 86 88 87 82 81 8a 8e 85 7c 78 7d     .............|x}
    10e4:	8a 96 98 93 92 9a a2 a0 97 88 7e 7a 74 6c 65 62     ..........~ztleb
    10f4:	62 62 5f 61 69 6f 6e 6d 6b 6d 6d 65 5d 5d 63 64     bb_aionmkmme]]cd
    1104:	5d 5a 60 68 64 59 53 59 64 6a 6a 68 69 71 79 7d     ]Z`hdYSYdjjhiqy}
    1114:	80 83 86 86 88 8a 8d 8f 8d 8d 8e 8e 8e 8d 8b 87     ................
    1124:	82 7c 79 77 74 72 77 7e 86 88 85 88 93 9a 9a 94     .|ywtrw~........
    1134:	8f 8f 8e 87 7e 79 79 7c 7b 76 72 72 72 6e 6a 6a     ....~yy|{vrrrnjj
    1144:	6b 67 61 60 66 6d 70 71 73 77 7f 85 8d 8e 86 80     kga`fmpqsw......
    1154:	7f 7e 7a 73 6a 67 69 6f 73 72 71 75 7b 7d 7c 7d     .~zsjgiosrqu{}|}
    1164:	81 80 7a 74 76 7d 80 7e 7b 7a 7e 84 88 8a 8d 92     ..ztv}.~{z~.....
    1174:	99 9d 9e 9f a1 a1 9c 9a 9b 9a 97 91 8c 89 85 80     ................
    1184:	7c 79 74 70 70 70 6d 6e 72 78 7d 80 84 8c 97 9b     |ytpppmnrx}.....
    1194:	9a 99 98 98 98 95 93 8f 8a 8a 8d 90 92 90 8a 85     ................
    11a4:	84 85 80 78 71 70 70 70 77 79 78 78 7e 85 87 85     ...xqpppwyxx~...
    11b4:	82 83 83 84 83 81 85 86 87 8a 8c 90 91 92 93 95     ................
    11c4:	93 8e 8d 91 96 91 84 7a 79 7f 7e 78 75 74 75 77     .......zy.~xutuw
    11d4:	7a 7e 81 83 84 83 85 86 85 82 81 82 82 7f 7d 7d     z~............}}
    11e4:	7e 7c 76 73 72 71 6d 68 64 5e 5b 5e 63 67 69 6c     ~|vsrqmhd^[^cgil
    11f4:	70 76 7e 84 86 88 8a 8b 8d 8c 8c 87 82 7d 76 70     pv~..........}vp
    1204:	6c 6a 68 65 62 5e 5d 61 65 69 6c 6e 6d 6d 6e 70     ljheb^]aeilnmmnp
    1214:	72 70 6e 70 74 7c 83 85 88 8b 8f 90 90 90 90 8f     rpnpt|..........
    1224:	8c 88 86 82 7d 7a 78 76 74 72 73 74 75 76 76 76     ....}zxvtrstuvvv
    1234:	77 79 79 7a 7c 7f 7f 7f 7c 79 79 7b 7d 7f 81 84     wyyz|...|yy{}...
    1244:	87 88 8a 8b 8a 86 7c 75 72 70 6f 6e 6b 6c 6d 6e     ......|urponklmn
    1254:	71 73 73 76 79 7b 7d 7f 7f 7f 7f 7e 7d 7e 81 82     qssvy{}....~}~..
    1264:	85 88 8a 89 87 83 82 80 7f 7c 77 74 73 74 71 6e     .........|wtstqn
    1274:	6c 6d 6e 71 76 7b 80 85 8a 8d 8d 8d 8c 89 86 81     lmnqv{..........
    1284:	7e 7b 79 78 7a 7e 81 82 82 81 7f 7c 77 75 74 73     ~{yxz~.....|wuts
    1294:	72 75 78 7e 82 86 8e 96 9d a1 a3 a3 a2 a0 9c 97     rux~............
    12a4:	94 91 8d 87 84 85 87 8a 8a 8b 8c 8c 8b 8c 8e 90     ................
    12b4:	93 93 91 91 91 8f 8f 92 93 95 97 9d a2 a3 a3 a4     ................
    12c4:	a3 9f 98 91 8a 83 7d 7a 77 74 75 7a 7f 83 83 84     ......}zwtuz....
    12d4:	85 85 84 85 89 8e 95 9a 9f a3 a2 a0 99 8f 88 82     ................
    12e4:	7c 76 73 74 79 7f 83 88 8d 8f 90 90 8e 8d 89 83     |vsty...........
    12f4:	7e 78 76 73 6f 6f 71 74 76 79 7d 7e 7f 7f 7d 7b     ~xvsooqtvy}~..}{
    1304:	76 72 71 70 6f 6e 72 77 7b 7d 79 78 78 76 73 6f     vrqponrw{}yxxvso
    1314:	6c 6c 6c 6a 66 62 61 5f 5e 61 67 6d 72 77 7c 82     llljfba_^agmrw|.
    1324:	83 81 7f 7c 7a 79 79 77 74 74 73 72 71 6d 6b 69     ...|zyywttsrqmki
    1334:	67 66 65 66 68 65 64 65 68 69 68 69 6b 6d 6d 6d     gfefhedehihikmmm
    1344:	70 73 74 72 70 70 70 6c 69 6b 6e 6f 6b 68 69 6b     pstrpppliknokhik
    1354:	6b 68 66 63 65 65 61 60 63 66 6a 6c 6e 76 81 87     khfceea`cfjlnv..
    1364:	89 88 88 8b 8b 8a 8a 8c 90 94 98 9c a3 a8 aa ac     ................
    1374:	ac ad ae ae ae b3 b8 be c3 c6 c9 cd d0 cf cc c8     ................
    1384:	c4 c2 c3 c2 c2 c2 c4 c7 c8 cb ce d3 d3 d3 d5 d4     ................
    1394:	d3 cf cb ca c9 c7 c5 c5 c4 c3 c0 bc b9 b5 b2 af     ................
    13a4:	aa a8 a6 a4 a3 a3 a7 aa ac af b4 b9 bb b9 b6 b4     ................
    13b4:	b1 ab a7 a3 9f 9a 96 90 8d 8b 8a 87 86 86 85 84     ................
    13c4:	83 83 86 89 89 8a 8d 8f 8f 8d 8b 8a 87 82 7c 76     ..............|v
    13d4:	71 6b 63 5e 59 53 4e 4d 4b 4a 45 41 41 3e 3a 34     qkc^YSNMKJEAA>:4
    13e4:	30 30 2f 2b 27 25 23 1f 18 15 13 11 10 0e 0d 0f     00/+'%#.........
    13f4:	13 14 0f 09 03 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1410:	00 00 00 01 01 01 02 00 18 51 8e d3 fc fe fe fe     .........Q......
    1420:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1430:	ff ff fe ff f7 d6 bc a5 94 86 79 6d 66 63 63 64     ..........ymfccd
    1440:	64 63 64 64 5f 54 46 35 21 0a 00 00 00 00 00 00     dcdd_TF5!.......
	...
    1458:	00 01 00 02 00 0a 35 5f 88 b0 d7 f8 ff fe ff ff     ......5_........
    1468:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1478:	ff ff ff ff ff ff ff ff ff ff ff fe ff f6 e1 d0     ................
    1488:	bf ab 94 7b 61 48 30 17 04 00 01 00 01 00 00 00     ...{aH0.........
    1498:	01 11 27 3d 55 6d 89 a4 c1 dc f4 ff fe ff ff ff     ..'=Um..........
    14a8:	ff ff ff ff ff ff ff ff ff ff ff ff f3 e8 e5 e5     ................
    14b8:	e5 e7 ea ee f1 f1 f0 f0 ee ed ea e7 e4 de d4 c8     ................
    14c8:	bd b1 a3 94 84 74 67 5d 56 51 4d 4c 4a 46 46 47     .....tg]VQMLJFFG
    14d8:	49 4b 4f 54 5c 65 6d 75 7e 87 8d 90 91 91 92 92     IKOT\emu~.......
    14e8:	91 8d 89 87 81 77 6b 5b 4b 39 27 16 05 00 00 00     .....wk[K9'.....
	...
    1518:	00 01 01 02 00 03 00 12 66 c6 fe fe fe fe fe fe     ........f.......
    1528:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff fd ff     ................
    1538:	f1 b5 81 57 38 21 12 09 06 08 10 1c 29 34 40 4d     ...W8!......)4@M
    1548:	55 59 57 4f 41 2e 15 02 00 00 00 00 00 00 00 00     UYWOA...........
    1558:	00 00 00 00 00 00 01 01 02 00 06 37 71 a4 dc fe     ...........7q...
    1568:	fe fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1578:	ff ff ff ff fe ef e2 d7 ce c6 bf bb ba bb ba b9     ................
    1588:	b6 b3 ad a2 98 89 73 57 38 17 02 00 00 00 00 00     ......sW8.......
    1598:	00 00 00 00 00 00 00 01 01 01 1d 46 6d 97 bc e3     ...........Fm...
    15a8:	fd fe fe ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    15c8:	fe ff f8 e5 d0 b8 a2 8d 77 5f 47 31 23 17 0c 05     ........w_G1#...
    15d8:	01 00 02 0c 17 22 33 47 5c 71 87 98 ab ba c5 cd     ....."3G\q......
    15e8:	ce cd ca c6 c1 bb b6 b2 af ae ab ab aa a9 a9 aa     ................
    15f8:	ad ae ae b0 b3 b6 b7 b7 b5 b0 a9 a0 93 85 74 60     ..............t`
    1608:	4a 33 1c 07 00 00 00 00 00 00 00 00 00 00 00 00     J3..............
	...
    1630:	00 01 01 01 00 03 00 33 ae fa ff fe fe fe fe ff     .......3........
    1640:	ff ff ff ff ff ff ff ff ff ff fe fe fe fe fc c2     ................
    1650:	78 3c 0a 00 02 01 02 01 00 01 00 08 25 3a 4c 58     x<..........%:LX
    1660:	5c 56 45 2b 0c 00 00 00 00 00 00 00 00 00 00 00     \VE+............
    1670:	00 00 00 00 02 01 02 00 06 48 9a e7 ff fc ff fd     .........H......
    1680:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1690:	ff ff ff ff ff ff ff ff fc fa f9 f7 f1 e8 da c8     ................
    16a0:	b2 95 74 50 25 03 00 01 00 00 00 00 00 00 00 00     ..tP%...........
    16b0:	00 00 00 01 01 01 01 01 29 5e 8e bf ef ff fd fe     ........)^......
    16c0:	fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    16e0:	ff fe ff f8 e1 ce ba a4 8e 79 65 53 43 36 2d 29     .........yeSC6-)
    16f0:	27 25 26 29 2e 36 3e 48 55 67 7c 93 aa c1 d5 e8     '%&).6>HUg|.....
    1700:	f7 fe ff ff ff ff fb f0 e8 de d4 cc c3 ba b2 ad     ................
    1710:	a9 a4 a0 9d 98 94 93 90 8d 8a 88 85 81 7d 77 72     .............}wr
    1720:	6b 63 59 4e 41 32 24 17 08 00 00 00 00 00 00 00     kcYNA2$.........
	...
    1750:	00 01 01 02 00 02 00 0e 8b f6 fe fe fe fe fe fe     ................
    1760:	ff ff ff ff ff ff ff ff ff ff ff fe fe fe fe ff     ................
    1770:	d3 93 64 3e 25 15 0d 08 0d 1d 31 46 57 62 67 66     ..d>%.....1FWbgf
    1780:	57 3f 19 00 00 00 00 00 00 00 00 00 00 00 00 00     W?..............
    1790:	00 00 00 01 00 02 00 08 49 8d ce fc fe fe fe fe     ........I.......
    17a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17b0:	ff ff ff ff ff ff ff ff ff fe ff f7 d6 b5 92 6a     ...............j
    17c0:	44 19 00 01 00 01 00 00 00 00 00 00 00 00 00 00     D...............
    17d0:	00 00 00 00 00 01 00 07 24 3f 5f 81 a0 c0 df fa     ........$?_.....
    17e0:	ff fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17f0:	ff ff ff ff ff ff ff ff fe ff f7 db c7 b5 a8 9e     ................
    1800:	97 95 95 97 9c a2 a5 a6 a6 a5 a6 a2 9b 97 94 91     ................
    1810:	8d 87 7e 77 6f 66 60 5c 5a 5b 5d 62 6c 77 82 8d     ..~wof`\Z[]blw..
    1820:	98 a3 ae b8 c2 cd d6 dc e0 e3 e3 e3 e2 df dd d9     ................
    1830:	d4 d0 cc ca c7 c4 c0 be bb b6 b2 ae aa a6 a3 a0     ................
    1840:	9f 9c 97 91 8a 81 75 67 58 47 36 22 0f 01 00 00     ......ugXG6"....
	...
    1874:	01 01 02 00 04 00 31 c7 ff fc ff fd fe fe ff ff     ......1.........
    1884:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1894:	fe e5 d2 c8 c1 bb b7 b7 b7 b7 b0 a2 89 67 3c 0d     .............g<.
    18a4:	00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18b4:	00 00 01 01 02 00 21 5c 8d bc e9 ff fd fe fe ff     ......!\........
    18c4:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    18d4:	ff ff ff ff ff ff fe ff fe fe fc d8 ac 81 53 26     ..............S&
    18e4:	04 01 01 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
    18f4:	00 00 00 00 00 00 01 00 02 00 0a 2e 52 79 a0 c5     ............Ry..
    1904:	ea fe fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1914:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1924:	ff ff ff ff fe ff f4 db c7 b1 99 81 6d 5b 4b 40     ............m[K@
    1934:	39 35 36 37 38 3e 46 4f 57 60 6a 76 80 86 89 8c     95678>FOW`jv....
    1944:	8d 8c 8a 84 7d 77 72 6e 6b 6c 70 79 84 8d 99 a7     ....}wrnklpy....
    1954:	b5 c3 cf dc e7 ed f1 f3 f2 f0 ea e0 d3 c3 b2 a0     ................
    1964:	8f 7d 6c 61 59 55 53 54 55 57 58 55 51 4b 43 3d     .}laYUSTUWXUQKC=
    1974:	36 2b 20 11 04 00 00 00 00 00 00 00 00 00 00 00     6+ .............
	...
    1998:	00 01 01 01 01 01 01 07 87 fb fd ff fe fe fe fe     ................
    19a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    19b8:	ff ff ff ff ff ff ff ff fe fe fd ff f9 ca 91 52     ...............R
    19c8:	10 00 02 01 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    19e0:	01 00 0b 2f 4c 65 79 89 99 aa bf d9 f7 ff fe ff     .../Ley.........
    19f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a00:	ff ff ff ff ff fe ff f4 dd c8 b0 96 7b 61 46 2c     ............{aF,
    1a10:	0f 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1a20:	00 00 01 00 01 00 08 33 57 72 86 94 9f a7 ab ad     .......3Wr......
    1a30:	b1 b7 be c8 d3 e0 f0 fe ff ff ff ff ff ff ff ff     ................
    1a40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a50:	ff ff ff ff ff ff ff fc ed e0 d4 c7 ba aa 9b 89     ................
    1a60:	77 68 59 4c 42 39 31 2a 25 21 1d 1d 1d 1d 1d 1d     whYLB91*%!......
    1a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    1ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    20f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    21f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    22f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    23f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    24f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    25f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    26f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    27f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    28f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    29f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    2ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    30f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    31f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3250:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3260:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3270:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3280:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3290:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    32f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3300:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3310:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3320:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3330:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3340:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3350:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3360:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3370:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3380:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3390:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    33f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3400:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3410:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3420:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3430:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3440:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3450:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3460:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3470:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3480:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3490:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    34f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3500:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3510:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3520:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3530:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3540:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3550:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3560:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3570:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3580:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3590:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    35f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3600:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3610:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3620:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3630:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3640:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3650:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3660:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3670:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3680:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3690:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    36f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3700:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3710:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3720:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3730:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3740:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3750:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3760:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3770:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3780:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3790:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    37f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3800:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3810:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3820:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3830:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3840:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3850:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3860:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3870:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3880:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3890:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    38f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3900:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3910:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3920:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3930:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3940:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3950:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3960:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3970:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3980:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3990:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    39f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3a90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3aa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ab0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ac0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ad0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ae0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3af0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3b90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ba0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3be0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3bf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3c90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ca0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ce0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3cf0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3d90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3da0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3db0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3dd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3de0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3df0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3e90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ea0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3eb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ec0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ed0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ee0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ef0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f00:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f10:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f20:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f30:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f40:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f50:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f60:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f70:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f80:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3f90:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fa0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fb0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fc0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fd0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3fe0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    3ff0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4000:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4010:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4020:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4030:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4040:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4050:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4060:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4070:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4080:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4090:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    40f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4100:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4110:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4120:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4130:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4140:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4150:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4160:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4170:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4180:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4190:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41a0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41b0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41c0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41d0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41e0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    41f0:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4200:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4210:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4220:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4230:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4240:	1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d     ................
    4250:	1d 1d 1d 1d                                         ....

00004254 <__ctors_end>:
    4254:	11 24       	eor	r1, r1
    4256:	1f be       	out	0x3f, r1	; 63
    4258:	cf e5       	ldi	r28, 0x5F	; 95
    425a:	d8 e0       	ldi	r29, 0x08	; 8
    425c:	de bf       	out	0x3e, r29	; 62
    425e:	cd bf       	out	0x3d, r28	; 61

00004260 <__do_copy_data>:
    4260:	11 e0       	ldi	r17, 0x01	; 1
    4262:	a0 e6       	ldi	r26, 0x60	; 96
    4264:	b0 e0       	ldi	r27, 0x00	; 0
    4266:	ec ef       	ldi	r30, 0xFC	; 252
    4268:	f6 e6       	ldi	r31, 0x66	; 102
    426a:	02 c0       	rjmp	.+4      	; 0x4270 <__do_copy_data+0x10>
    426c:	05 90       	lpm	r0, Z+
    426e:	0d 92       	st	X+, r0
    4270:	a6 3a       	cpi	r26, 0xA6	; 166
    4272:	b1 07       	cpc	r27, r17
    4274:	d9 f7       	brne	.-10     	; 0x426c <__do_copy_data+0xc>

00004276 <__do_clear_bss>:
    4276:	18 e0       	ldi	r17, 0x08	; 8
    4278:	a6 ea       	ldi	r26, 0xA6	; 166
    427a:	b1 e0       	ldi	r27, 0x01	; 1
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <.do_clear_bss_start>

0000427e <.do_clear_bss_loop>:
    427e:	1d 92       	st	X+, r1

00004280 <.do_clear_bss_start>:
    4280:	ae 33       	cpi	r26, 0x3E	; 62
    4282:	b1 07       	cpc	r27, r17
    4284:	e1 f7       	brne	.-8      	; 0x427e <.do_clear_bss_loop>
    4286:	0e 94 f5 23 	call	0x47ea	; 0x47ea <main>
    428a:	0c 94 7c 33 	jmp	0x66f8	; 0x66f8 <_exit>

0000428e <__bad_interrupt>:
    428e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00004292 <vMainGameTask>:
		vTaskDelay(1);		
	}	
}


void vMainGameTask(void *pvParameters){
    4292:	8f 92       	push	r8
    4294:	9f 92       	push	r9
    4296:	af 92       	push	r10
    4298:	bf 92       	push	r11
    429a:	cf 92       	push	r12
    429c:	df 92       	push	r13
    429e:	ef 92       	push	r14
    42a0:	ff 92       	push	r15
    42a2:	0f 93       	push	r16
    42a4:	1f 93       	push	r17
    42a6:	cf 93       	push	r28
    42a8:	df 93       	push	r29
    second = 0;
    42aa:	10 92 a7 01 	sts	0x01A7, r1
    42ae:	10 92 a6 01 	sts	0x01A6, r1
	current_state = STARTSCREEN;
    42b2:	10 92 ba 00 	sts	0x00BA, r1
    42b6:	10 92 b9 00 	sts	0x00B9, r1
	int firstloading = 1;
    42ba:	c1 e0       	ldi	r28, 0x01	; 1
    42bc:	d0 e0       	ldi	r29, 0x00	; 0
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
				led_current_state = LED_STOP;
    42be:	34 e0       	ldi	r19, 0x04	; 4
    42c0:	e3 2e       	mov	r14, r19
    42c2:	f1 2c       	mov	r15, r1
				current_lcd_state = LCD_WRITE;
    42c4:	22 e0       	ldi	r18, 0x02	; 2
    42c6:	c2 2e       	mov	r12, r18
    42c8:	d1 2c       	mov	r13, r1
				current_state = RESULT;
    42ca:	93 e0       	ldi	r25, 0x03	; 3
    42cc:	a9 2e       	mov	r10, r25
    42ce:	b1 2c       	mov	r11, r1
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    42d0:	01 e0       	ldi	r16, 0x01	; 1
    42d2:	10 e0       	ldi	r17, 0x00	; 0
			}else{
				set_mode(SLOW_MODE);
				led_current_state = LED_STOP;
			}
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
    42d4:	8d ed       	ldi	r24, 0xDD	; 221
    42d6:	88 2e       	mov	r8, r24
    42d8:	91 2c       	mov	r9, r1
    second = 0;
	current_state = STARTSCREEN;
	int firstloading = 1;
	
	while(1){
		if(current_state == STARTSCREEN){
    42da:	80 91 b9 00 	lds	r24, 0x00B9
    42de:	90 91 ba 00 	lds	r25, 0x00BA
    42e2:	00 97       	sbiw	r24, 0x00	; 0
    42e4:	81 f4       	brne	.+32     	; 0x4306 <vMainGameTask+0x74>
			if(firstloading){
    42e6:	20 97       	sbiw	r28, 0x00	; 0
    42e8:	09 f4       	brne	.+2      	; 0x42ec <vMainGameTask+0x5a>
    42ea:	93 c0       	rjmp	.+294    	; 0x4412 <vMainGameTask+0x180>
				led_current_state = LED_START;
    42ec:	10 93 a9 01 	sts	0x01A9, r17
    42f0:	00 93 a8 01 	sts	0x01A8, r16
				current_lcd_state = LCD_START;
    42f4:	10 93 bc 00 	sts	0x00BC, r17
    42f8:	00 93 bb 00 	sts	0x00BB, r16
				firstloading = 0;
				second = 0;
    42fc:	10 92 a7 01 	sts	0x01A7, r1
    4300:	10 92 a6 01 	sts	0x01A6, r1
    4304:	84 c0       	rjmp	.+264    	; 0x440e <vMainGameTask+0x17c>
			}
		}else if(current_state == LOADING){
    4306:	81 30       	cpi	r24, 0x01	; 1
    4308:	91 05       	cpc	r25, r1
    430a:	39 f5       	brne	.+78     	; 0x435a <vMainGameTask+0xc8>
			if(firstloading){
    430c:	20 97       	sbiw	r28, 0x00	; 0
    430e:	61 f0       	breq	.+24     	; 0x4328 <vMainGameTask+0x96>
				led_current_state = LED_START;
    4310:	90 93 a9 01 	sts	0x01A9, r25
    4314:	80 93 a8 01 	sts	0x01A8, r24
				current_lcd_state = LCD_START;
    4318:	90 93 bc 00 	sts	0x00BC, r25
    431c:	80 93 bb 00 	sts	0x00BB, r24
				firstloading = 0;
				second = 0;
    4320:	10 92 a7 01 	sts	0x01A7, r1
    4324:	10 92 a6 01 	sts	0x01A6, r1
			}

			if(second > LOADING_INTERVAL){
    4328:	80 91 a6 01 	lds	r24, 0x01A6
    432c:	90 91 a7 01 	lds	r25, 0x01A7
    4330:	8b 30       	cpi	r24, 0x0B	; 11
    4332:	91 05       	cpc	r25, r1
    4334:	0c f4       	brge	.+2      	; 0x4338 <vMainGameTask+0xa6>
    4336:	6b c0       	rjmp	.+214    	; 0x440e <vMainGameTask+0x17c>
				second = 0;
    4338:	10 92 a7 01 	sts	0x01A7, r1
    433c:	10 92 a6 01 	sts	0x01A6, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    4340:	f0 92 a9 01 	sts	0x01A9, r15
    4344:	e0 92 a8 01 	sts	0x01A8, r14
				current_lcd_state = LCD_EMPTY;
    4348:	b0 92 bc 00 	sts	0x00BC, r11
    434c:	a0 92 bb 00 	sts	0x00BB, r10
				current_state = GAME;
    4350:	d0 92 ba 00 	sts	0x00BA, r13
    4354:	c0 92 b9 00 	sts	0x00B9, r12
    4358:	57 c0       	rjmp	.+174    	; 0x4408 <vMainGameTask+0x176>
			}
		}else if(current_state == GAME){
    435a:	82 30       	cpi	r24, 0x02	; 2
    435c:	91 05       	cpc	r25, r1
    435e:	09 f0       	breq	.+2      	; 0x4362 <vMainGameTask+0xd0>
    4360:	58 c0       	rjmp	.+176    	; 0x4412 <vMainGameTask+0x180>
			current_lcd_state = LCD_WRITE;
    4362:	90 93 bc 00 	sts	0x00BC, r25
    4366:	80 93 bb 00 	sts	0x00BB, r24
			if(firstloading){
    436a:	20 97       	sbiw	r28, 0x00	; 0
    436c:	31 f0       	breq	.+12     	; 0x437a <vMainGameTask+0xe8>
				init_game();
    436e:	0e 94 63 30 	call	0x60c6	; 0x60c6 <init_game>
				firstloading = 0;
				second = 0;
    4372:	10 92 a7 01 	sts	0x01A7, r1
    4376:	10 92 a6 01 	sts	0x01A6, r1
			}

			//switchinput = PORTD;
			update_game();
    437a:	0e 94 ce 30 	call	0x619c	; 0x619c <update_game>
			
			if (global_sonar_cm<10){
    437e:	80 91 aa 01 	lds	r24, 0x01AA
    4382:	90 91 ab 01 	lds	r25, 0x01AB
    4386:	8a 30       	cpi	r24, 0x0A	; 10
    4388:	91 05       	cpc	r25, r1
    438a:	4c f4       	brge	.+18     	; 0x439e <vMainGameTask+0x10c>
				set_mode(FAST_MODE);
    438c:	82 e0       	ldi	r24, 0x02	; 2
    438e:	90 e0       	ldi	r25, 0x00	; 0
    4390:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <set_mode>
				led_current_state = LED_START;
    4394:	10 93 a9 01 	sts	0x01A9, r17
    4398:	00 93 a8 01 	sts	0x01A8, r16
    439c:	08 c0       	rjmp	.+16     	; 0x43ae <vMainGameTask+0x11c>
			}else{
				set_mode(SLOW_MODE);
    439e:	81 e0       	ldi	r24, 0x01	; 1
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <set_mode>
				led_current_state = LED_STOP;
    43a6:	f0 92 a9 01 	sts	0x01A9, r15
    43aa:	e0 92 a8 01 	sts	0x01A8, r14
			}
			if(!firstsrand){
    43ae:	80 91 ac 01 	lds	r24, 0x01AC
    43b2:	90 91 ad 01 	lds	r25, 0x01AD
    43b6:	00 97       	sbiw	r24, 0x00	; 0
    43b8:	91 f4       	brne	.+36     	; 0x43de <vMainGameTask+0x14c>
				srand(global_sonar_cm*17*13);
    43ba:	80 91 aa 01 	lds	r24, 0x01AA
    43be:	90 91 ab 01 	lds	r25, 0x01AB
    43c2:	9c 01       	movw	r18, r24
    43c4:	28 9d       	mul	r18, r8
    43c6:	c0 01       	movw	r24, r0
    43c8:	29 9d       	mul	r18, r9
    43ca:	90 0d       	add	r25, r0
    43cc:	38 9d       	mul	r19, r8
    43ce:	90 0d       	add	r25, r0
    43d0:	11 24       	eor	r1, r1
    43d2:	0e 94 4e 32 	call	0x649c	; 0x649c <srand>
				firstsrand=1;
    43d6:	10 93 ad 01 	sts	0x01AD, r17
    43da:	00 93 ac 01 	sts	0x01AC, r16
			}

			if(get_state() == GAME_FINAL){
    43de:	0e 94 cf 31 	call	0x639e	; 0x639e <get_state>
    43e2:	81 30       	cpi	r24, 0x01	; 1
    43e4:	91 05       	cpc	r25, r1
    43e6:	99 f4       	brne	.+38     	; 0x440e <vMainGameTask+0x17c>
				second = 0;
    43e8:	10 92 a7 01 	sts	0x01A7, r1
    43ec:	10 92 a6 01 	sts	0x01A6, r1
				firstloading = 1;
				led_current_state = LED_STOP;
    43f0:	f0 92 a9 01 	sts	0x01A9, r15
    43f4:	e0 92 a8 01 	sts	0x01A8, r14
				current_lcd_state = LCD_WRITE;
    43f8:	d0 92 bc 00 	sts	0x00BC, r13
    43fc:	c0 92 bb 00 	sts	0x00BB, r12
				current_state = RESULT;
    4400:	b0 92 ba 00 	sts	0x00BA, r11
    4404:	a0 92 b9 00 	sts	0x00B9, r10
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
				second = 0;
				firstloading = 1;
    4408:	c1 e0       	ldi	r28, 0x01	; 1
    440a:	d0 e0       	ldi	r29, 0x00	; 0
    440c:	02 c0       	rjmp	.+4      	; 0x4412 <vMainGameTask+0x180>
			if(!firstsrand){
				srand(global_sonar_cm*17*13);
				firstsrand=1;
			}

			if(get_state() == GAME_FINAL){
    440e:	c0 e0       	ldi	r28, 0x00	; 0
    4410:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_STOP;
				current_lcd_state = LCD_WRITE;
				current_state = RESULT;
			}
		}
		second++;
    4412:	80 91 a6 01 	lds	r24, 0x01A6
    4416:	90 91 a7 01 	lds	r25, 0x01A7
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	90 93 a7 01 	sts	0x01A7, r25
    4420:	80 93 a6 01 	sts	0x01A6, r24
		vTaskDelay(20 * TICKS_PER_MS);
    4424:	84 e6       	ldi	r24, 0x64	; 100
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
	}	
    442c:	56 cf       	rjmp	.-340    	; 0x42da <vMainGameTask+0x48>

0000442e <vMusicTask>:


/** 	
This task plays a series of musical notes in order to produce a "song"
*/
void vMusicTask( void * pvParameters ){
    442e:	cf 93       	push	r28
    4430:	df 93       	push	r29
	int i;
	DDRB = 0x11111100;
    4432:	17 ba       	out	0x17, r1	; 23
	Timer/Counter 0
	Clock value = 11.719 KHz
	Mode = CTC top=OCR0
	OC0 output: Toggle on compare match
	*/
	TCCR0=0x1A;
    4434:	8a e1       	ldi	r24, 0x1A	; 26
    4436:	83 bf       	out	0x33, r24	; 51
	TCNT0=0x00;
    4438:	12 be       	out	0x32, r1	; 50
	OCR0=0x00;
    443a:	1c be       	out	0x3c, r1	; 60

	while(1){
		for(i=0; i<31; i++){
    443c:	c0 e0       	ldi	r28, 0x00	; 0
    443e:	d0 e0       	ldi	r29, 0x00	; 0
			// Set the new desired frequency
			OCR0 = notes[song2[i]+8];
    4440:	fe 01       	movw	r30, r28
    4442:	ee 0f       	add	r30, r30
    4444:	ff 1f       	adc	r31, r31
    4446:	e3 54       	subi	r30, 0x43	; 67
    4448:	ff 4f       	sbci	r31, 0xFF	; 255
    444a:	01 90       	ld	r0, Z+
    444c:	f0 81       	ld	r31, Z
    444e:	e0 2d       	mov	r30, r0
    4450:	e1 58       	subi	r30, 0x81	; 129
    4452:	fe 4f       	sbci	r31, 0xFE	; 254
    4454:	80 85       	ldd	r24, Z+8	; 0x08
    4456:	8c bf       	out	0x3c, r24	; 60

			// Delay for half a second
			vTaskDelay(10 * TICKS_PER_MS);
    4458:	82 e3       	ldi	r24, 0x32	; 50
    445a:	90 e0       	ldi	r25, 0x00	; 0
    445c:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
	TCCR0=0x1A;
	TCNT0=0x00;
	OCR0=0x00;

	while(1){
		for(i=0; i<31; i++){
    4460:	21 96       	adiw	r28, 0x01	; 1
    4462:	cf 31       	cpi	r28, 0x1F	; 31
    4464:	d1 05       	cpc	r29, r1
    4466:	54 f7       	brge	.-44     	; 0x443c <vMusicTask+0xe>
    4468:	eb cf       	rjmp	.-42     	; 0x4440 <vMusicTask+0x12>

0000446a <vInputTask>:
		vTaskDelay(20 * TICKS_PER_MS);
	}
}


void vInputTask(void *pvParameters){
    446a:	ef 92       	push	r14
    446c:	ff 92       	push	r15
    446e:	0f 93       	push	r16
    4470:	1f 93       	push	r17
    4472:	cf 93       	push	r28
    4474:	df 93       	push	r29
	DDRB = 0x11111100;
    4476:	17 ba       	out	0x17, r1	; 23
			}else if(((~input) & 0b00000010) == 0b00000010){
				set_mario(0);
			}
		}else if(current_state==RESULT && (((~input) & 0b00000001) == 1)){
			clear_lcd();
			led_current_state = LED_STOP;
    4478:	04 e0       	ldi	r16, 0x04	; 4
    447a:	10 e0       	ldi	r17, 0x00	; 0
			current_lcd_state = LCD_EMPTY;
			current_state = LOADING;
    447c:	c1 e0       	ldi	r28, 0x01	; 1
    447e:	d0 e0       	ldi	r29, 0x00	; 0


void vInputTask(void *pvParameters){
	DDRB = 0x11111100;
	while(1){
		int input = PINB;
    4480:	86 b3       	in	r24, 0x16	; 22
		if(current_state == STARTSCREEN){
    4482:	e0 90 b9 00 	lds	r14, 0x00B9
    4486:	f0 90 ba 00 	lds	r15, 0x00BA
    448a:	e1 14       	cp	r14, r1
    448c:	f1 04       	cpc	r15, r1
    448e:	71 f4       	brne	.+28     	; 0x44ac <vInputTask+0x42>
			if(((~input) & 0b00000001) == 1){
    4490:	80 fd       	sbrc	r24, 0
    4492:	03 c0       	rjmp	.+6      	; 0x449a <vInputTask+0x30>
				clear_lcd();
    4494:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
    4498:	36 c0       	rjmp	.+108    	; 0x4506 <vInputTask+0x9c>
				current_state = LOADING;
				second = 0;
				
			}else if(((~input) & 0b00000010) == 0b00000010){
    449a:	81 fd       	sbrc	r24, 1
    449c:	3c c0       	rjmp	.+120    	; 0x4516 <vInputTask+0xac>
				clear_lcd();
    449e:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
				current_state = HISCORESCREEN;
    44a2:	10 93 ba 00 	sts	0x00BA, r17
    44a6:	00 93 b9 00 	sts	0x00B9, r16
    44aa:	35 c0       	rjmp	.+106    	; 0x4516 <vInputTask+0xac>
			}
		}else if(current_state == HISCORESCREEN){
    44ac:	94 e0       	ldi	r25, 0x04	; 4
    44ae:	e9 16       	cp	r14, r25
    44b0:	f1 04       	cpc	r15, r1
    44b2:	49 f4       	brne	.+18     	; 0x44c6 <vInputTask+0x5c>
			if(((~input) & 0b00000001) == 1){
    44b4:	80 fd       	sbrc	r24, 0
    44b6:	2f c0       	rjmp	.+94     	; 0x4516 <vInputTask+0xac>
				clear_lcd();
    44b8:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
				current_state = STARTSCREEN;
    44bc:	10 92 ba 00 	sts	0x00BA, r1
    44c0:	10 92 b9 00 	sts	0x00B9, r1
    44c4:	28 c0       	rjmp	.+80     	; 0x4516 <vInputTask+0xac>
			}
		}else if(current_state == GAME){
    44c6:	92 e0       	ldi	r25, 0x02	; 2
    44c8:	e9 16       	cp	r14, r25
    44ca:	f1 04       	cpc	r15, r1
    44cc:	61 f4       	brne	.+24     	; 0x44e6 <vInputTask+0x7c>
			if(((~input) & 0b00000001) == 1){
    44ce:	80 fd       	sbrc	r24, 0
    44d0:	03 c0       	rjmp	.+6      	; 0x44d8 <vInputTask+0x6e>
				set_mario(1);
    44d2:	81 e0       	ldi	r24, 0x01	; 1
    44d4:	90 e0       	ldi	r25, 0x00	; 0
    44d6:	04 c0       	rjmp	.+8      	; 0x44e0 <vInputTask+0x76>
			}else if(((~input) & 0b00000010) == 0b00000010){
    44d8:	81 fd       	sbrc	r24, 1
    44da:	1d c0       	rjmp	.+58     	; 0x4516 <vInputTask+0xac>
				set_mario(0);
    44dc:	80 e0       	ldi	r24, 0x00	; 0
    44de:	90 e0       	ldi	r25, 0x00	; 0
    44e0:	0e 94 bc 31 	call	0x6378	; 0x6378 <set_mario>
    44e4:	18 c0       	rjmp	.+48     	; 0x4516 <vInputTask+0xac>
			}
		}else if(current_state==RESULT && (((~input) & 0b00000001) == 1)){
    44e6:	93 e0       	ldi	r25, 0x03	; 3
    44e8:	e9 16       	cp	r14, r25
    44ea:	f1 04       	cpc	r15, r1
    44ec:	a1 f4       	brne	.+40     	; 0x4516 <vInputTask+0xac>
    44ee:	80 fd       	sbrc	r24, 0
    44f0:	12 c0       	rjmp	.+36     	; 0x4516 <vInputTask+0xac>
			clear_lcd();
    44f2:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
			led_current_state = LED_STOP;
    44f6:	10 93 a9 01 	sts	0x01A9, r17
    44fa:	00 93 a8 01 	sts	0x01A8, r16
			current_lcd_state = LCD_EMPTY;
    44fe:	f0 92 bc 00 	sts	0x00BC, r15
    4502:	e0 92 bb 00 	sts	0x00BB, r14
			current_state = LOADING;
    4506:	d0 93 ba 00 	sts	0x00BA, r29
    450a:	c0 93 b9 00 	sts	0x00B9, r28
			second = 0;
    450e:	10 92 a7 01 	sts	0x01A7, r1
    4512:	10 92 a6 01 	sts	0x01A6, r1
		}
		
		vTaskDelay(3 * TICKS_PER_MS);
    4516:	8f e0       	ldi	r24, 0x0F	; 15
    4518:	90 e0       	ldi	r25, 0x00	; 0
    451a:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
	}
    451e:	b0 cf       	rjmp	.-160    	; 0x4480 <vInputTask+0x16>

00004520 <vLCDTask>:
	}
}



void vLCDTask( void * pvParameters) {
    4520:	af 92       	push	r10
    4522:	bf 92       	push	r11
    4524:	cf 92       	push	r12
    4526:	df 92       	push	r13
    4528:	ef 92       	push	r14
    452a:	ff 92       	push	r15
    452c:	0f 93       	push	r16
    452e:	1f 93       	push	r17
    4530:	df 93       	push	r29
    4532:	cf 93       	push	r28
    4534:	cd b7       	in	r28, 0x3d	; 61
    4536:	de b7       	in	r29, 0x3e	; 62
    4538:	60 97       	sbiw	r28, 0x10	; 16
    453a:	0f b6       	in	r0, 0x3f	; 63
    453c:	f8 94       	cli
    453e:	de bf       	out	0x3e, r29	; 62
    4540:	0f be       	out	0x3f, r0	; 63
    4542:	cd bf       	out	0x3d, r28	; 61
	init_lcd();
    4544:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <init_lcd>
				eeprom_update_word((uint16_t*)46,pas);
			}else{
				tulis_string("SCORE: ",1,0);
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    4548:	7e 01       	movw	r14, r28
    454a:	08 94       	sec
    454c:	e1 1c       	adc	r14, r1
    454e:	f1 1c       	adc	r15, r1
		}else if(current_state == STARTSCREEN){
			tulis_string("0.START",0,0);
			tulis_string("1.HISKOR",0,1);
		}else if(current_state == LOADING){
			if(current_lcd_state == LCD_START){	
				current_lcd_state = LCD_WRITE;
    4550:	52 e0       	ldi	r21, 0x02	; 2
    4552:	a5 2e       	mov	r10, r21
    4554:	b1 2c       	mov	r11, r1
	tulis_data_ram_lcd(0x20); 		// Tulis spasi
	*/
	
	int ii = 0;
	while (1){
		if (current_lcd_state == LCD_EMPTY){
    4556:	20 91 bb 00 	lds	r18, 0x00BB
    455a:	30 91 bc 00 	lds	r19, 0x00BC
    455e:	23 30       	cpi	r18, 0x03	; 3
    4560:	31 05       	cpc	r19, r1
    4562:	21 f4       	brne	.+8      	; 0x456c <vLCDTask+0x4c>
			kirim_perintah_lcd(0x01);
    4564:	81 e0       	ldi	r24, 0x01	; 1
    4566:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
    456a:	88 c0       	rjmp	.+272    	; 0x467c <vLCDTask+0x15c>
		}else if(current_state == HISCORESCREEN){
    456c:	80 91 b9 00 	lds	r24, 0x00B9
    4570:	90 91 ba 00 	lds	r25, 0x00BA
    4574:	84 30       	cpi	r24, 0x04	; 4
    4576:	91 05       	cpc	r25, r1
    4578:	b9 f4       	brne	.+46     	; 0x45a8 <vLCDTask+0x88>
			tulis_string("HISCORE",0,0);
    457a:	80 e6       	ldi	r24, 0x60	; 96
    457c:	90 e0       	ldi	r25, 0x00	; 0
    457e:	60 e0       	ldi	r22, 0x00	; 0
    4580:	70 e0       	ldi	r23, 0x00	; 0
    4582:	40 e0       	ldi	r20, 0x00	; 0
    4584:	50 e0       	ldi	r21, 0x00	; 0
    4586:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>
			int highscore = eeprom_read_word((uint16_t*)46);
    458a:	8e e2       	ldi	r24, 0x2E	; 46
    458c:	90 e0       	ldi	r25, 0x00	; 0
    458e:	0e 94 ac 32 	call	0x6558	; 0x6558 <__eerd_word_m32>
			if(highscore<0){
				highscore=0;
			}
			char lcdstr[16];
			ltoa(highscore, lcdstr, 10);
    4592:	68 2f       	mov	r22, r24
    4594:	79 2f       	mov	r23, r25
    4596:	77 ff       	sbrs	r23, 7
    4598:	02 c0       	rjmp	.+4      	; 0x459e <vLCDTask+0x7e>
    459a:	60 e0       	ldi	r22, 0x00	; 0
    459c:	70 e0       	ldi	r23, 0x00	; 0
    459e:	88 27       	eor	r24, r24
    45a0:	77 fd       	sbrc	r23, 7
    45a2:	80 95       	com	r24
    45a4:	98 2f       	mov	r25, r24
    45a6:	5e c0       	rjmp	.+188    	; 0x4664 <vLCDTask+0x144>
			tulis_string(lcdstr,3,1);
		}else if(current_state == STARTSCREEN){
    45a8:	00 97       	sbiw	r24, 0x00	; 0
    45aa:	69 f4       	brne	.+26     	; 0x45c6 <vLCDTask+0xa6>
			tulis_string("0.START",0,0);
    45ac:	88 e6       	ldi	r24, 0x68	; 104
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	60 e0       	ldi	r22, 0x00	; 0
    45b2:	70 e0       	ldi	r23, 0x00	; 0
    45b4:	40 e0       	ldi	r20, 0x00	; 0
    45b6:	50 e0       	ldi	r21, 0x00	; 0
    45b8:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>
			tulis_string("1.HISKOR",0,1);
    45bc:	80 e7       	ldi	r24, 0x70	; 112
    45be:	90 e0       	ldi	r25, 0x00	; 0
    45c0:	60 e0       	ldi	r22, 0x00	; 0
    45c2:	70 e0       	ldi	r23, 0x00	; 0
    45c4:	57 c0       	rjmp	.+174    	; 0x4674 <vLCDTask+0x154>
		}else if(current_state == LOADING){
    45c6:	81 30       	cpi	r24, 0x01	; 1
    45c8:	91 05       	cpc	r25, r1
    45ca:	c9 f4       	brne	.+50     	; 0x45fe <vLCDTask+0xde>
			if(current_lcd_state == LCD_START){	
    45cc:	21 30       	cpi	r18, 0x01	; 1
    45ce:	31 05       	cpc	r19, r1
    45d0:	29 f4       	brne	.+10     	; 0x45dc <vLCDTask+0xbc>
				current_lcd_state = LCD_WRITE;
    45d2:	b0 92 bc 00 	sts	0x00BC, r11
    45d6:	a0 92 bb 00 	sts	0x00BB, r10
    45da:	50 c0       	rjmp	.+160    	; 0x467c <vLCDTask+0x15c>
			}else if (current_lcd_state == LCD_WRITE){
    45dc:	22 30       	cpi	r18, 0x02	; 2
    45de:	31 05       	cpc	r19, r1
    45e0:	09 f0       	breq	.+2      	; 0x45e4 <vLCDTask+0xc4>
    45e2:	4c c0       	rjmp	.+152    	; 0x467c <vLCDTask+0x15c>
				tulis_string("LOADING.",0,0);
    45e4:	89 e7       	ldi	r24, 0x79	; 121
    45e6:	90 e0       	ldi	r25, 0x00	; 0
    45e8:	60 e0       	ldi	r22, 0x00	; 0
    45ea:	70 e0       	ldi	r23, 0x00	; 0
    45ec:	40 e0       	ldi	r20, 0x00	; 0
    45ee:	50 e0       	ldi	r21, 0x00	; 0
    45f0:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>
				tulis_string("GAME...",1,1);
    45f4:	82 e8       	ldi	r24, 0x82	; 130
    45f6:	90 e0       	ldi	r25, 0x00	; 0
    45f8:	61 e0       	ldi	r22, 0x01	; 1
    45fa:	70 e0       	ldi	r23, 0x00	; 0
    45fc:	3b c0       	rjmp	.+118    	; 0x4674 <vLCDTask+0x154>
			}
		}else if(current_state == GAME){
    45fe:	82 30       	cpi	r24, 0x02	; 2
    4600:	91 05       	cpc	r25, r1
    4602:	29 f4       	brne	.+10     	; 0x460e <vLCDTask+0xee>
			clear_lcd();
    4604:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
			draw_game();
    4608:	0e 94 6e 31 	call	0x62dc	; 0x62dc <draw_game>
    460c:	37 c0       	rjmp	.+110    	; 0x467c <vLCDTask+0x15c>
			//tulis_string("MULAI",0,0);
		}else if(current_state == RESULT){
    460e:	83 30       	cpi	r24, 0x03	; 3
    4610:	91 05       	cpc	r25, r1
    4612:	a1 f5       	brne	.+104    	; 0x467c <vLCDTask+0x15c>
			clear_lcd();
    4614:	0e 94 f0 2f 	call	0x5fe0	; 0x5fe0 <clear_lcd>
			
			int highscore = eeprom_read_word((uint16_t*)46);
    4618:	8e e2       	ldi	r24, 0x2E	; 46
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	0e 94 ac 32 	call	0x6558	; 0x6558 <__eerd_word_m32>
    4620:	6c 01       	movw	r12, r24
			int pas = getpass();
    4622:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <getpass>
    4626:	8c 01       	movw	r16, r24
			if(pas>=highscore){
    4628:	8c 15       	cp	r24, r12
    462a:	9d 05       	cpc	r25, r13
    462c:	74 f0       	brlt	.+28     	; 0x464a <vLCDTask+0x12a>
				tulis_string("HISCORE: ",0,0);
    462e:	8a e8       	ldi	r24, 0x8A	; 138
    4630:	90 e0       	ldi	r25, 0x00	; 0
    4632:	60 e0       	ldi	r22, 0x00	; 0
    4634:	70 e0       	ldi	r23, 0x00	; 0
    4636:	40 e0       	ldi	r20, 0x00	; 0
    4638:	50 e0       	ldi	r21, 0x00	; 0
    463a:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>
				eeprom_update_word((uint16_t*)46,pas);
    463e:	8e e2       	ldi	r24, 0x2E	; 46
    4640:	90 e0       	ldi	r25, 0x00	; 0
    4642:	b8 01       	movw	r22, r16
    4644:	0e 94 b2 32 	call	0x6564	; 0x6564 <__eeupd_word_m32>
    4648:	08 c0       	rjmp	.+16     	; 0x465a <vLCDTask+0x13a>
			}else{
				tulis_string("SCORE: ",1,0);
    464a:	84 e9       	ldi	r24, 0x94	; 148
    464c:	90 e0       	ldi	r25, 0x00	; 0
    464e:	61 e0       	ldi	r22, 0x01	; 1
    4650:	70 e0       	ldi	r23, 0x00	; 0
    4652:	40 e0       	ldi	r20, 0x00	; 0
    4654:	50 e0       	ldi	r21, 0x00	; 0
    4656:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>
			}		
			char lcdstr[16];
			ltoa(pas, lcdstr, 10);
    465a:	b8 01       	movw	r22, r16
    465c:	88 27       	eor	r24, r24
    465e:	77 fd       	sbrc	r23, 7
    4660:	80 95       	com	r24
    4662:	98 2f       	mov	r25, r24
    4664:	a7 01       	movw	r20, r14
    4666:	2a e0       	ldi	r18, 0x0A	; 10
    4668:	30 e0       	ldi	r19, 0x00	; 0
    466a:	0e 94 78 32 	call	0x64f0	; 0x64f0 <ltoa>
			tulis_string(lcdstr,3,1);
    466e:	c7 01       	movw	r24, r14
    4670:	63 e0       	ldi	r22, 0x03	; 3
    4672:	70 e0       	ldi	r23, 0x00	; 0
    4674:	41 e0       	ldi	r20, 0x01	; 1
    4676:	50 e0       	ldi	r21, 0x00	; 0
    4678:	0e 94 17 30 	call	0x602e	; 0x602e <tulis_string>

			
		}	
		
		vTaskDelay(20 * TICKS_PER_MS);
    467c:	84 e6       	ldi	r24, 0x64	; 100
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
		
		
	}
    4684:	68 cf       	rjmp	.-304    	; 0x4556 <vLCDTask+0x36>

00004686 <vSonarTask>:
This task measures distance using the SRF08 every 100 ms 
and display the result in cm to LCD
*/
static int global_sonar_cm = 0;
void vSonarTask( void * pvParameters )
{
    4686:	ef 92       	push	r14
    4688:	ff 92       	push	r15
    468a:	cf 93       	push	r28
    468c:	df 93       	push	r29
    char lcd[16];
	int i = 0;
	init_lcd();
    468e:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <init_lcd>
	
	while(1){
		unsigned int data = 0;
		// Send command to start measurement
 		i2c_transmit(0xE0, 0, 81);
    4692:	80 ee       	ldi	r24, 0xE0	; 224
    4694:	60 e0       	ldi	r22, 0x00	; 0
    4696:	41 e5       	ldi	r20, 0x51	; 81
    4698:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <i2c_transmit>
		// Wait for the measurement to be done
		vTaskDelay(70 * TICKS_PER_MS);
    469c:	8e e5       	ldi	r24, 0x5E	; 94
    469e:	91 e0       	ldi	r25, 0x01	; 1
    46a0:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
		// Read the 16 bit result
		data = i2cRead(0xE0, 2) << 8;
    46a4:	80 ee       	ldi	r24, 0xE0	; 224
    46a6:	62 e0       	ldi	r22, 0x02	; 2
    46a8:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <i2cRead>
    46ac:	98 2f       	mov	r25, r24
    46ae:	80 e0       	ldi	r24, 0x00	; 0
    46b0:	ec 01       	movw	r28, r24
		data |= i2cRead(0xE0, 3);
    46b2:	80 ee       	ldi	r24, 0xE0	; 224
    46b4:	63 e0       	ldi	r22, 0x03	; 3
    46b6:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <i2cRead>
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	8c 2b       	or	r24, r28
    46be:	9d 2b       	or	r25, r29
		global_sonar_cm = data;
    46c0:	90 93 ab 01 	sts	0x01AB, r25
    46c4:	80 93 aa 01 	sts	0x01AA, r24
			//tulis_data_ram_lcd(lcd[i]);
		}
		*/
		
		// Delay for another 100 ms
		vTaskDelay(20 * TICKS_PER_MS);
    46c8:	84 e6       	ldi	r24, 0x64	; 100
    46ca:	90 e0       	ldi	r25, 0x00	; 0
    46cc:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
    46d0:	e0 cf       	rjmp	.-64     	; 0x4692 <vSonarTask+0xc>

000046d2 <vLEDTask>:
	}
}



void vLEDTask ( void * pvParameters ) {
    46d2:	ef 92       	push	r14
    46d4:	ff 92       	push	r15
    46d6:	0f 93       	push	r16
    46d8:	1f 93       	push	r17
    46da:	cf 93       	push	r28
    46dc:	df 93       	push	r29
	int current = 0;
	// Set PORTB as LED output //
	DDRD = 0xFF;
    46de:	8f ef       	ldi	r24, 0xFF	; 255
    46e0:	81 bb       	out	0x11, r24	; 17
	PORTD = current;
    46e2:	12 ba       	out	0x12, r1	; 18
	led_current_state = LED_START;
    46e4:	81 e0       	ldi	r24, 0x01	; 1
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	90 93 a9 01 	sts	0x01A9, r25
    46ec:	80 93 a8 01 	sts	0x01A8, r24
}



void vLEDTask ( void * pvParameters ) {
	int current = 0;
    46f0:	c0 e0       	ldi	r28, 0x00	; 0
    46f2:	d0 e0       	ldi	r29, 0x00	; 0
			}else{
				current = current >> 1;
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
			if (current == 0b11100000){
				led_current_state = LED_MOVE_LEFT;
    46f4:	02 e0       	ldi	r16, 0x02	; 2
    46f6:	10 e0       	ldi	r17, 0x00	; 0
		}else if(led_current_state == LED_START){
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
			if (current == 0b00000111){
				led_current_state = LED_MOVE_RIGHT;
    46f8:	e3 e0       	ldi	r30, 0x03	; 3
    46fa:	ee 2e       	mov	r14, r30
    46fc:	f1 2c       	mov	r15, r1
	// Set PORTB as LED output //
	DDRD = 0xFF;
	PORTD = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
    46fe:	80 91 a8 01 	lds	r24, 0x01A8
    4702:	90 91 a9 01 	lds	r25, 0x01A9
    4706:	84 30       	cpi	r24, 0x04	; 4
    4708:	91 05       	cpc	r25, r1
    470a:	31 f1       	breq	.+76     	; 0x4758 <vLEDTask+0x86>
			current = 0;	
		}else if(led_current_state == LED_START){
    470c:	81 30       	cpi	r24, 0x01	; 1
    470e:	91 05       	cpc	r25, r1
    4710:	39 f4       	brne	.+14     	; 0x4720 <vLEDTask+0x4e>
			current = 0b11100000;
			led_current_state = LED_MOVE_LEFT;
    4712:	10 93 a9 01 	sts	0x01A9, r17
    4716:	00 93 a8 01 	sts	0x01A8, r16
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
		}else if(led_current_state == LED_START){
			current = 0b11100000;
    471a:	c0 ee       	ldi	r28, 0xE0	; 224
    471c:	d0 e0       	ldi	r29, 0x00	; 0
    471e:	1e c0       	rjmp	.+60     	; 0x475c <vLEDTask+0x8a>
			led_current_state = LED_MOVE_LEFT;
		}else if(led_current_state == LED_MOVE_LEFT){
    4720:	82 30       	cpi	r24, 0x02	; 2
    4722:	91 05       	cpc	r25, r1
    4724:	59 f4       	brne	.+22     	; 0x473c <vLEDTask+0x6a>
			if (current == 0b00000111){
    4726:	c7 30       	cpi	r28, 0x07	; 7
    4728:	d1 05       	cpc	r29, r1
    472a:	29 f4       	brne	.+10     	; 0x4736 <vLEDTask+0x64>
				led_current_state = LED_MOVE_RIGHT;
    472c:	f0 92 a9 01 	sts	0x01A9, r15
    4730:	e0 92 a8 01 	sts	0x01A8, r14
    4734:	13 c0       	rjmp	.+38     	; 0x475c <vLEDTask+0x8a>
			}else{
				current = current >> 1;
    4736:	d5 95       	asr	r29
    4738:	c7 95       	ror	r28
    473a:	10 c0       	rjmp	.+32     	; 0x475c <vLEDTask+0x8a>
			}
		}else if(led_current_state == LED_MOVE_RIGHT){
    473c:	83 30       	cpi	r24, 0x03	; 3
    473e:	91 05       	cpc	r25, r1
    4740:	69 f4       	brne	.+26     	; 0x475c <vLEDTask+0x8a>
			if (current == 0b11100000){
    4742:	c0 3e       	cpi	r28, 0xE0	; 224
    4744:	d1 05       	cpc	r29, r1
    4746:	29 f4       	brne	.+10     	; 0x4752 <vLEDTask+0x80>
				led_current_state = LED_MOVE_LEFT;
    4748:	10 93 a9 01 	sts	0x01A9, r17
    474c:	00 93 a8 01 	sts	0x01A8, r16
    4750:	05 c0       	rjmp	.+10     	; 0x475c <vLEDTask+0x8a>
			}else{
				current = current << 1;
    4752:	cc 0f       	add	r28, r28
    4754:	dd 1f       	adc	r29, r29
    4756:	02 c0       	rjmp	.+4      	; 0x475c <vLEDTask+0x8a>
	DDRD = 0xFF;
	PORTD = current;
	led_current_state = LED_START;
	while (1) {
		if(led_current_state == LED_STOP){
			current = 0;	
    4758:	c0 e0       	ldi	r28, 0x00	; 0
    475a:	d0 e0       	ldi	r29, 0x00	; 0
				led_current_state = LED_MOVE_LEFT;
			}else{
				current = current << 1;
			}
		}
		PORTD = current ^ 0b11111111;
    475c:	9e 01       	movw	r18, r28
    475e:	20 95       	com	r18
    4760:	22 bb       	out	0x12, r18	; 18
		vTaskDelay(20 * TICKS_PER_MS);
    4762:	84 e6       	ldi	r24, 0x64	; 100
    4764:	90 e0       	ldi	r25, 0x00	; 0
    4766:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
	}
    476a:	c9 cf       	rjmp	.-110    	; 0x46fe <vLEDTask+0x2c>

0000476c <vServoTask>:
	}

}


void vServoTask(void *pvParameters){
    476c:	0f 93       	push	r16
    476e:	1f 93       	push	r17
    4770:	cf 93       	push	r28
    4772:	df 93       	push	r29
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
    4774:	80 91 b9 00 	lds	r24, 0x00B9
    4778:	90 91 ba 00 	lds	r25, 0x00BA
    477c:	82 30       	cpi	r24, 0x02	; 2
    477e:	91 05       	cpc	r25, r1
    4780:	79 f5       	brne	.+94     	; 0x47e0 <vServoTask+0x74>
    4782:	c8 e2       	ldi	r28, 0x28	; 40
    4784:	d0 e0       	ldi	r29, 0x00	; 0
			i = 1;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
    4786:	c0 9a       	sbi	0x18, 0	; 24
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    4788:	81 e0       	ldi	r24, 0x01	; 1
    478a:	90 e0       	ldi	r25, 0x00	; 0
    478c:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
    4790:	81 e0       	ldi	r24, 0x01	; 1
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
				}
				PORTB &= 0b11111110;
    4798:	c0 98       	cbi	0x18, 0	; 24
		
				vTaskDelay(10 * TICKS_PER_MS);
    479a:	82 e3       	ldi	r24, 0x32	; 50
    479c:	90 e0       	ldi	r25, 0x00	; 0
    479e:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
    47a2:	21 97       	sbiw	r28, 0x01	; 1
void vServoTask(void *pvParameters){
	int i, j, k;
	while (1) {
		if (current_state == GAME) {
			i = 1;
			for (k = 0; k < 40; k++) {
    47a4:	81 f7       	brne	.-32     	; 0x4786 <vServoTask+0x1a>
				}
				PORTB &= 0b11111110;
		
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    47a6:	81 e0       	ldi	r24, 0x01	; 1
    47a8:	90 e0       	ldi	r25, 0x00	; 0
    47aa:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
		
			i = 45;
			for (k = 0; k < 40; k++) {
    47ae:	c0 e0       	ldi	r28, 0x00	; 0
    47b0:	d0 e0       	ldi	r29, 0x00	; 0
				PORTB |= 0b00000001;
    47b2:	c0 9a       	sbi	0x18, 0	; 24
    47b4:	0e e2       	ldi	r16, 0x2E	; 46
    47b6:	10 e0       	ldi	r17, 0x00	; 0
				for (j = 0; j <= i; j++) {
					vTaskDelay(1);
    47b8:	81 e0       	ldi	r24, 0x01	; 1
    47ba:	90 e0       	ldi	r25, 0x00	; 0
    47bc:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
    47c0:	01 50       	subi	r16, 0x01	; 1
    47c2:	10 40       	sbci	r17, 0x00	; 0
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
				PORTB |= 0b00000001;
				for (j = 0; j <= i; j++) {
    47c4:	c9 f7       	brne	.-14     	; 0x47b8 <vServoTask+0x4c>
					vTaskDelay(1);
				}
				PORTB &= 0b11111110;
    47c6:	c0 98       	cbi	0x18, 0	; 24
			
				vTaskDelay(10 * TICKS_PER_MS);
    47c8:	82 e3       	ldi	r24, 0x32	; 50
    47ca:	90 e0       	ldi	r25, 0x00	; 0
    47cc:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
		
			i = 45;
			for (k = 0; k < 40; k++) {
    47d0:	21 96       	adiw	r28, 0x01	; 1
    47d2:	c8 32       	cpi	r28, 0x28	; 40
    47d4:	d1 05       	cpc	r29, r1
    47d6:	69 f7       	brne	.-38     	; 0x47b2 <vServoTask+0x46>
				}
				PORTB &= 0b11111110;
			
				vTaskDelay(10 * TICKS_PER_MS);
			}
			vTaskDelay(1);
    47d8:	81 e0       	ldi	r24, 0x01	; 1
    47da:	90 e0       	ldi	r25, 0x00	; 0
    47dc:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
		}
		vTaskDelay(1);		
    47e0:	81 e0       	ldi	r24, 0x01	; 1
    47e2:	90 e0       	ldi	r25, 0x00	; 0
    47e4:	0e 94 a3 2c 	call	0x5946	; 0x5946 <vTaskDelay>
	}	
    47e8:	c5 cf       	rjmp	.-118    	; 0x4774 <vServoTask+0x8>

000047ea <main>:
}




int main(){
    47ea:	af 92       	push	r10
    47ec:	bf 92       	push	r11
    47ee:	cf 92       	push	r12
    47f0:	df 92       	push	r13
    47f2:	ef 92       	push	r14
    47f4:	ff 92       	push	r15
    47f6:	0f 93       	push	r16
    47f8:	df 93       	push	r29
    47fa:	cf 93       	push	r28
    47fc:	cd b7       	in	r28, 0x3d	; 61
    47fe:	de b7       	in	r29, 0x3e	; 62
    4800:	2a 97       	sbiw	r28, 0x0a	; 10
    4802:	0f b6       	in	r0, 0x3f	; 63
    4804:	f8 94       	cli
    4806:	de bf       	out	0x3e, r29	; 62
    4808:	0f be       	out	0x3f, r0	; 63
    480a:	cd bf       	out	0x3d, r28	; 61
	xTaskHandle xSonarTaskHandle, xMusicTaskHandle, xSoundTaskHandle, xLEDTaskHandle, xLCDTaskHandle, xMainGameTaskHandle;
	xTaskHandle xInputTaskHandle;
	
	/* set the I2C bit rate generator to 100 kb/s */
	
	TWSR &= ~0x03;
    480c:	81 b1       	in	r24, 0x01	; 1
    480e:	8c 7f       	andi	r24, 0xFC	; 252
    4810:	81 b9       	out	0x01, r24	; 1
	TWBR  = 28;
    4812:	8c e1       	ldi	r24, 0x1C	; 28
    4814:	80 b9       	out	0x00, r24	; 0
	TWCR |= _BV(TWEN);
    4816:	86 b7       	in	r24, 0x36	; 54
    4818:	84 60       	ori	r24, 0x04	; 4
    481a:	86 bf       	out	0x36, r24	; 54

	LCD_CONTROL_DDR	 = _BV(LCD_RS_BIT) | _BV(LCD_EN_BIT) | _BV(LCD_RW_BIT);
    481c:	80 ee       	ldi	r24, 0xE0	; 224
    481e:	84 bb       	out	0x14, r24	; 20
	DDRA = 0xFF;
    4820:	8f ef       	ldi	r24, 0xFF	; 255
    4822:	8a bb       	out	0x1a, r24	; 26
	

	/*
	Create the tasks
	*/
	xTaskCreate( vMainGameTask, "GAME", 100, NULL, tskIDLE_PRIORITY, &xMainGameTaskHandle);
    4824:	89 e4       	ldi	r24, 0x49	; 73
    4826:	91 e2       	ldi	r25, 0x21	; 33
    4828:	6c e9       	ldi	r22, 0x9C	; 156
    482a:	70 e0       	ldi	r23, 0x00	; 0
    482c:	44 e6       	ldi	r20, 0x64	; 100
    482e:	50 e0       	ldi	r21, 0x00	; 0
    4830:	20 e0       	ldi	r18, 0x00	; 0
    4832:	30 e0       	ldi	r19, 0x00	; 0
    4834:	00 e0       	ldi	r16, 0x00	; 0
    4836:	e7 e0       	ldi	r30, 0x07	; 7
    4838:	ee 2e       	mov	r14, r30
    483a:	f1 2c       	mov	r15, r1
    483c:	ec 0e       	add	r14, r28
    483e:	fd 1e       	adc	r15, r29
    4840:	cc 24       	eor	r12, r12
    4842:	dd 24       	eor	r13, r13
    4844:	aa 24       	eor	r10, r10
    4846:	bb 24       	eor	r11, r11
    4848:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>
	xTaskCreate( vLCDTask, "LCD", 100, NULL, tskIDLE_PRIORITY, &xLCDTaskHandle);
    484c:	80 e9       	ldi	r24, 0x90	; 144
    484e:	92 e2       	ldi	r25, 0x22	; 34
    4850:	61 ea       	ldi	r22, 0xA1	; 161
    4852:	70 e0       	ldi	r23, 0x00	; 0
    4854:	44 e6       	ldi	r20, 0x64	; 100
    4856:	50 e0       	ldi	r21, 0x00	; 0
    4858:	20 e0       	ldi	r18, 0x00	; 0
    485a:	30 e0       	ldi	r19, 0x00	; 0
    485c:	b5 e0       	ldi	r27, 0x05	; 5
    485e:	eb 2e       	mov	r14, r27
    4860:	f1 2c       	mov	r15, r1
    4862:	ec 0e       	add	r14, r28
    4864:	fd 1e       	adc	r15, r29
    4866:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>
	//xTaskCreate( vLEDTask, "LED", 100, NULL, tskIDLE_PRIORITY, &xLEDTaskHandle);
	xTaskCreate( vSonarTask, "Sonar", 100, NULL , tskIDLE_PRIORITY, &xSonarTaskHandle );
    486a:	83 e4       	ldi	r24, 0x43	; 67
    486c:	93 e2       	ldi	r25, 0x23	; 35
    486e:	65 ea       	ldi	r22, 0xA5	; 165
    4870:	70 e0       	ldi	r23, 0x00	; 0
    4872:	44 e6       	ldi	r20, 0x64	; 100
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	20 e0       	ldi	r18, 0x00	; 0
    4878:	30 e0       	ldi	r19, 0x00	; 0
    487a:	7e 01       	movw	r14, r28
    487c:	08 94       	sec
    487e:	e1 1c       	adc	r14, r1
    4880:	f1 1c       	adc	r15, r1
    4882:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>
	xTaskCreate( vInputTask, "Input", 100, NULL , tskIDLE_PRIORITY, &xInputTaskHandle );
    4886:	85 e3       	ldi	r24, 0x35	; 53
    4888:	92 e2       	ldi	r25, 0x22	; 34
    488a:	6b ea       	ldi	r22, 0xAB	; 171
    488c:	70 e0       	ldi	r23, 0x00	; 0
    488e:	44 e6       	ldi	r20, 0x64	; 100
    4890:	50 e0       	ldi	r21, 0x00	; 0
    4892:	20 e0       	ldi	r18, 0x00	; 0
    4894:	30 e0       	ldi	r19, 0x00	; 0
    4896:	a9 e0       	ldi	r26, 0x09	; 9
    4898:	ea 2e       	mov	r14, r26
    489a:	f1 2c       	mov	r15, r1
    489c:	ec 0e       	add	r14, r28
    489e:	fd 1e       	adc	r15, r29
    48a0:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>
	xTaskCreate( vMusicTask, "Sound", 100, NULL , tskIDLE_PRIORITY, &xMusicTaskHandle );
    48a4:	87 e1       	ldi	r24, 0x17	; 23
    48a6:	92 e2       	ldi	r25, 0x22	; 34
    48a8:	61 eb       	ldi	r22, 0xB1	; 177
    48aa:	70 e0       	ldi	r23, 0x00	; 0
    48ac:	44 e6       	ldi	r20, 0x64	; 100
    48ae:	50 e0       	ldi	r21, 0x00	; 0
    48b0:	20 e0       	ldi	r18, 0x00	; 0
    48b2:	30 e0       	ldi	r19, 0x00	; 0
    48b4:	f3 e0       	ldi	r31, 0x03	; 3
    48b6:	ef 2e       	mov	r14, r31
    48b8:	f1 2c       	mov	r15, r1
    48ba:	ec 0e       	add	r14, r28
    48bc:	fd 1e       	adc	r15, r29
    48be:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>

	// Start the scheduler
	vTaskStartScheduler();
    48c2:	0e 94 37 2b 	call	0x566e	; 0x566e <vTaskStartScheduler>
}
    48c6:	80 e0       	ldi	r24, 0x00	; 0
    48c8:	90 e0       	ldi	r25, 0x00	; 0
    48ca:	2a 96       	adiw	r28, 0x0a	; 10
    48cc:	0f b6       	in	r0, 0x3f	; 63
    48ce:	f8 94       	cli
    48d0:	de bf       	out	0x3e, r29	; 62
    48d2:	0f be       	out	0x3f, r0	; 63
    48d4:	cd bf       	out	0x3d, r28	; 61
    48d6:	cf 91       	pop	r28
    48d8:	df 91       	pop	r29
    48da:	0f 91       	pop	r16
    48dc:	ff 90       	pop	r15
    48de:	ef 90       	pop	r14
    48e0:	df 90       	pop	r13
    48e2:	cf 90       	pop	r12
    48e4:	bf 90       	pop	r11
    48e6:	af 90       	pop	r10
    48e8:	08 95       	ret

000048ea <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    48ea:	af 92       	push	r10
    48ec:	bf 92       	push	r11
    48ee:	cf 92       	push	r12
    48f0:	df 92       	push	r13
    48f2:	ef 92       	push	r14
    48f4:	ff 92       	push	r15
    48f6:	0f 93       	push	r16
    48f8:	1f 93       	push	r17
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	6c 01       	movw	r12, r24
    4900:	b6 2e       	mov	r11, r22
    4902:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    4904:	8a e1       	ldi	r24, 0x1A	; 26
    4906:	90 e0       	ldi	r25, 0x00	; 0
    4908:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <pvPortMalloc>
    490c:	e8 2e       	mov	r14, r24
    490e:	e7 01       	movw	r28, r14
    4910:	7e 01       	movw	r14, r28
    4912:	f9 2e       	mov	r15, r25
    4914:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    4916:	20 97       	sbiw	r28, 0x00	; 0
    4918:	09 f4       	brne	.+2      	; 0x491c <xCoRoutineCreate+0x32>
    491a:	5e c0       	rjmp	.+188    	; 0x49d8 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    491c:	80 91 ae 01 	lds	r24, 0x01AE
    4920:	90 91 af 01 	lds	r25, 0x01AF
    4924:	00 97       	sbiw	r24, 0x00	; 0
    4926:	21 f5       	brne	.+72     	; 0x4970 <xCoRoutineCreate+0x86>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4928:	f0 92 af 01 	sts	0x01AF, r15
    492c:	e0 92 ae 01 	sts	0x01AE, r14
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    4930:	8a eb       	ldi	r24, 0xBA	; 186
    4932:	91 e0       	ldi	r25, 0x01	; 1
    4934:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
    4938:	83 ec       	ldi	r24, 0xC3	; 195
    493a:	91 e0       	ldi	r25, 0x01	; 1
    493c:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    4940:	56 ed       	ldi	r21, 0xD6	; 214
    4942:	e5 2e       	mov	r14, r21
    4944:	51 e0       	ldi	r21, 0x01	; 1
    4946:	f5 2e       	mov	r15, r21
    4948:	c7 01       	movw	r24, r14
    494a:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    494e:	0f ed       	ldi	r16, 0xDF	; 223
    4950:	11 e0       	ldi	r17, 0x01	; 1
    4952:	c8 01       	movw	r24, r16
    4954:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    4958:	80 eb       	ldi	r24, 0xB0	; 176
    495a:	91 e0       	ldi	r25, 0x01	; 1
    495c:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    4960:	f0 92 d3 01 	sts	0x01D3, r15
    4964:	e0 92 d2 01 	sts	0x01D2, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    4968:	10 93 d5 01 	sts	0x01D5, r17
    496c:	00 93 d4 01 	sts	0x01D4, r16
    4970:	bb 20       	and	r11, r11
    4972:	11 f0       	breq	.+4      	; 0x4978 <xCoRoutineCreate+0x8e>
    4974:	bb 24       	eor	r11, r11
    4976:	b3 94       	inc	r11
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4978:	19 8e       	std	Y+25, r1	; 0x19
    497a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    497c:	be 8a       	std	Y+22, r11	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    497e:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4980:	fe 01       	movw	r30, r28
    4982:	c1 92       	st	Z+, r12
    4984:	d1 92       	st	Z+, r13
    4986:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4988:	cf 01       	movw	r24, r30
    498a:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    498e:	ce 01       	movw	r24, r28
    4990:	0c 96       	adiw	r24, 0x0c	; 12
    4992:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4996:	d9 87       	std	Y+9, r29	; 0x09
    4998:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    499a:	db 8b       	std	Y+19, r29	; 0x13
    499c:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    499e:	84 e0       	ldi	r24, 0x04	; 4
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	8b 19       	sub	r24, r11
    49a4:	91 09       	sbc	r25, r1
    49a6:	9d 87       	std	Y+13, r25	; 0x0d
    49a8:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    49aa:	2e 89       	ldd	r18, Y+22	; 0x16
    49ac:	80 91 b9 01 	lds	r24, 0x01B9
    49b0:	82 17       	cp	r24, r18
    49b2:	10 f4       	brcc	.+4      	; 0x49b8 <xCoRoutineCreate+0xce>
    49b4:	20 93 b9 01 	sts	0x01B9, r18
    49b8:	30 e0       	ldi	r19, 0x00	; 0
    49ba:	c9 01       	movw	r24, r18
    49bc:	43 e0       	ldi	r20, 0x03	; 3
    49be:	88 0f       	add	r24, r24
    49c0:	99 1f       	adc	r25, r25
    49c2:	4a 95       	dec	r20
    49c4:	e1 f7       	brne	.-8      	; 0x49be <xCoRoutineCreate+0xd4>
    49c6:	82 0f       	add	r24, r18
    49c8:	93 1f       	adc	r25, r19
    49ca:	86 54       	subi	r24, 0x46	; 70
    49cc:	9e 4f       	sbci	r25, 0xFE	; 254
    49ce:	b8 01       	movw	r22, r16
    49d0:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>

		xReturn = pdPASS;
    49d4:	81 e0       	ldi	r24, 0x01	; 1
    49d6:	01 c0       	rjmp	.+2      	; 0x49da <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    49d8:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    49da:	df 91       	pop	r29
    49dc:	cf 91       	pop	r28
    49de:	1f 91       	pop	r17
    49e0:	0f 91       	pop	r16
    49e2:	ff 90       	pop	r15
    49e4:	ef 90       	pop	r14
    49e6:	df 90       	pop	r13
    49e8:	cf 90       	pop	r12
    49ea:	bf 90       	pop	r11
    49ec:	af 90       	pop	r10
    49ee:	08 95       	ret

000049f0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    49f0:	0f 93       	push	r16
    49f2:	1f 93       	push	r17
    49f4:	cf 93       	push	r28
    49f6:	df 93       	push	r29
    49f8:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    49fa:	00 91 d0 01 	lds	r16, 0x01D0
    49fe:	10 91 d1 01 	lds	r17, 0x01D1
    4a02:	08 0f       	add	r16, r24
    4a04:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4a06:	80 91 ae 01 	lds	r24, 0x01AE
    4a0a:	90 91 af 01 	lds	r25, 0x01AF
    4a0e:	02 96       	adiw	r24, 0x02	; 2
    4a10:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    4a14:	60 91 ae 01 	lds	r22, 0x01AE
    4a18:	70 91 af 01 	lds	r23, 0x01AF
    4a1c:	fb 01       	movw	r30, r22
    4a1e:	13 83       	std	Z+3, r17	; 0x03
    4a20:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    4a22:	80 91 d0 01 	lds	r24, 0x01D0
    4a26:	90 91 d1 01 	lds	r25, 0x01D1
    4a2a:	6e 5f       	subi	r22, 0xFE	; 254
    4a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a2e:	08 17       	cp	r16, r24
    4a30:	19 07       	cpc	r17, r25
    4a32:	28 f4       	brcc	.+10     	; 0x4a3e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4a34:	80 91 d4 01 	lds	r24, 0x01D4
    4a38:	90 91 d5 01 	lds	r25, 0x01D5
    4a3c:	04 c0       	rjmp	.+8      	; 0x4a46 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4a3e:	80 91 d2 01 	lds	r24, 0x01D2
    4a42:	90 91 d3 01 	lds	r25, 0x01D3
    4a46:	0e 94 84 26 	call	0x4d08	; 0x4d08 <vListInsert>
	}

	if( pxEventList )
    4a4a:	20 97       	sbiw	r28, 0x00	; 0
    4a4c:	49 f0       	breq	.+18     	; 0x4a60 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4a4e:	60 91 ae 01 	lds	r22, 0x01AE
    4a52:	70 91 af 01 	lds	r23, 0x01AF
    4a56:	64 5f       	subi	r22, 0xF4	; 244
    4a58:	7f 4f       	sbci	r23, 0xFF	; 255
    4a5a:	ce 01       	movw	r24, r28
    4a5c:	0e 94 84 26 	call	0x4d08	; 0x4d08 <vListInsert>
	}
}
    4a60:	df 91       	pop	r29
    4a62:	cf 91       	pop	r28
    4a64:	1f 91       	pop	r17
    4a66:	0f 91       	pop	r16
    4a68:	08 95       	ret

00004a6a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    4a6a:	0f 93       	push	r16
    4a6c:	1f 93       	push	r17
    4a6e:	cf 93       	push	r28
    4a70:	df 93       	push	r29
    4a72:	27 c0       	rjmp	.+78     	; 0x4ac2 <vCoRoutineSchedule+0x58>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    4a74:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4a76:	e0 91 b5 01 	lds	r30, 0x01B5
    4a7a:	f0 91 b6 01 	lds	r31, 0x01B6
    4a7e:	c6 81       	ldd	r28, Z+6	; 0x06
    4a80:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4a82:	ce 01       	movw	r24, r28
    4a84:	0c 96       	adiw	r24, 0x0c	; 12
    4a86:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4a8a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4a8c:	8e 01       	movw	r16, r28
    4a8e:	0e 5f       	subi	r16, 0xFE	; 254
    4a90:	1f 4f       	sbci	r17, 0xFF	; 255
    4a92:	c8 01       	movw	r24, r16
    4a94:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4a98:	2e 89       	ldd	r18, Y+22	; 0x16
    4a9a:	80 91 b9 01 	lds	r24, 0x01B9
    4a9e:	82 17       	cp	r24, r18
    4aa0:	10 f4       	brcc	.+4      	; 0x4aa6 <vCoRoutineSchedule+0x3c>
    4aa2:	20 93 b9 01 	sts	0x01B9, r18
    4aa6:	30 e0       	ldi	r19, 0x00	; 0
    4aa8:	c9 01       	movw	r24, r18
    4aaa:	f3 e0       	ldi	r31, 0x03	; 3
    4aac:	88 0f       	add	r24, r24
    4aae:	99 1f       	adc	r25, r25
    4ab0:	fa 95       	dec	r31
    4ab2:	e1 f7       	brne	.-8      	; 0x4aac <vCoRoutineSchedule+0x42>
    4ab4:	82 0f       	add	r24, r18
    4ab6:	93 1f       	adc	r25, r19
    4ab8:	86 54       	subi	r24, 0x46	; 70
    4aba:	9e 4f       	sbci	r25, 0xFE	; 254
    4abc:	b8 01       	movw	r22, r16
    4abe:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4ac2:	80 91 b0 01 	lds	r24, 0x01B0
    4ac6:	88 23       	and	r24, r24
    4ac8:	a9 f6       	brne	.-86     	; 0x4a74 <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4aca:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <xTaskGetTickCount>
    4ace:	20 91 cc 01 	lds	r18, 0x01CC
    4ad2:	30 91 cd 01 	lds	r19, 0x01CD
    4ad6:	82 1b       	sub	r24, r18
    4ad8:	93 0b       	sbc	r25, r19
    4ada:	90 93 cf 01 	sts	0x01CF, r25
    4ade:	80 93 ce 01 	sts	0x01CE, r24
    4ae2:	59 c0       	rjmp	.+178    	; 0x4b96 <vCoRoutineSchedule+0x12c>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4ae4:	01 96       	adiw	r24, 0x01	; 1
    4ae6:	90 93 d1 01 	sts	0x01D1, r25
    4aea:	80 93 d0 01 	sts	0x01D0, r24
		xPassedTicks--;
    4aee:	21 50       	subi	r18, 0x01	; 1
    4af0:	30 40       	sbci	r19, 0x00	; 0
    4af2:	30 93 cf 01 	sts	0x01CF, r19
    4af6:	20 93 ce 01 	sts	0x01CE, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    4afa:	00 97       	sbiw	r24, 0x00	; 0
    4afc:	09 f0       	breq	.+2      	; 0x4b00 <vCoRoutineSchedule+0x96>
    4afe:	44 c0       	rjmp	.+136    	; 0x4b88 <vCoRoutineSchedule+0x11e>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    4b00:	80 91 d2 01 	lds	r24, 0x01D2
    4b04:	90 91 d3 01 	lds	r25, 0x01D3
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4b08:	20 91 d4 01 	lds	r18, 0x01D4
    4b0c:	30 91 d5 01 	lds	r19, 0x01D5
    4b10:	30 93 d3 01 	sts	0x01D3, r19
    4b14:	20 93 d2 01 	sts	0x01D2, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    4b18:	90 93 d5 01 	sts	0x01D5, r25
    4b1c:	80 93 d4 01 	sts	0x01D4, r24
    4b20:	33 c0       	rjmp	.+102    	; 0x4b88 <vCoRoutineSchedule+0x11e>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4b22:	05 80       	ldd	r0, Z+5	; 0x05
    4b24:	f6 81       	ldd	r31, Z+6	; 0x06
    4b26:	e0 2d       	mov	r30, r0
    4b28:	c6 81       	ldd	r28, Z+6	; 0x06
    4b2a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4b2c:	20 91 d0 01 	lds	r18, 0x01D0
    4b30:	30 91 d1 01 	lds	r19, 0x01D1
    4b34:	8a 81       	ldd	r24, Y+2	; 0x02
    4b36:	9b 81       	ldd	r25, Y+3	; 0x03
    4b38:	28 17       	cp	r18, r24
    4b3a:	39 07       	cpc	r19, r25
    4b3c:	60 f1       	brcs	.+88     	; 0x4b96 <vCoRoutineSchedule+0x12c>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4b3e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4b40:	8e 01       	movw	r16, r28
    4b42:	0e 5f       	subi	r16, 0xFE	; 254
    4b44:	1f 4f       	sbci	r17, 0xFF	; 255
    4b46:	c8 01       	movw	r24, r16
    4b48:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4b4c:	8c 89       	ldd	r24, Y+20	; 0x14
    4b4e:	9d 89       	ldd	r25, Y+21	; 0x15
    4b50:	00 97       	sbiw	r24, 0x00	; 0
    4b52:	21 f0       	breq	.+8      	; 0x4b5c <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4b54:	ce 01       	movw	r24, r28
    4b56:	0c 96       	adiw	r24, 0x0c	; 12
    4b58:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4b5c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    4b5e:	2e 89       	ldd	r18, Y+22	; 0x16
    4b60:	80 91 b9 01 	lds	r24, 0x01B9
    4b64:	82 17       	cp	r24, r18
    4b66:	10 f4       	brcc	.+4      	; 0x4b6c <vCoRoutineSchedule+0x102>
    4b68:	20 93 b9 01 	sts	0x01B9, r18
    4b6c:	30 e0       	ldi	r19, 0x00	; 0
    4b6e:	c9 01       	movw	r24, r18
    4b70:	e3 e0       	ldi	r30, 0x03	; 3
    4b72:	88 0f       	add	r24, r24
    4b74:	99 1f       	adc	r25, r25
    4b76:	ea 95       	dec	r30
    4b78:	e1 f7       	brne	.-8      	; 0x4b72 <vCoRoutineSchedule+0x108>
    4b7a:	82 0f       	add	r24, r18
    4b7c:	93 1f       	adc	r25, r19
    4b7e:	86 54       	subi	r24, 0x46	; 70
    4b80:	9e 4f       	sbci	r25, 0xFE	; 254
    4b82:	b8 01       	movw	r22, r16
    4b84:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4b88:	e0 91 d2 01 	lds	r30, 0x01D2
    4b8c:	f0 91 d3 01 	lds	r31, 0x01D3
    4b90:	80 81       	ld	r24, Z
    4b92:	88 23       	and	r24, r24
    4b94:	31 f6       	brne	.-116    	; 0x4b22 <vCoRoutineSchedule+0xb8>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4b96:	20 91 ce 01 	lds	r18, 0x01CE
    4b9a:	30 91 cf 01 	lds	r19, 0x01CF
    4b9e:	80 91 d0 01 	lds	r24, 0x01D0
    4ba2:	90 91 d1 01 	lds	r25, 0x01D1
    4ba6:	21 15       	cp	r18, r1
    4ba8:	31 05       	cpc	r19, r1
    4baa:	09 f0       	breq	.+2      	; 0x4bae <vCoRoutineSchedule+0x144>
    4bac:	9b cf       	rjmp	.-202    	; 0x4ae4 <vCoRoutineSchedule+0x7a>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    4bae:	90 93 cd 01 	sts	0x01CD, r25
    4bb2:	80 93 cc 01 	sts	0x01CC, r24
    4bb6:	40 91 b9 01 	lds	r20, 0x01B9

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4bba:	06 c0       	rjmp	.+12     	; 0x4bc8 <vCoRoutineSchedule+0x15e>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4bbc:	44 23       	and	r20, r20
    4bbe:	19 f4       	brne	.+6      	; 0x4bc6 <vCoRoutineSchedule+0x15c>
    4bc0:	10 92 b9 01 	sts	0x01B9, r1
    4bc4:	40 c0       	rjmp	.+128    	; 0x4c46 <vCoRoutineSchedule+0x1dc>
    4bc6:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4bc8:	84 2f       	mov	r24, r20
    4bca:	90 e0       	ldi	r25, 0x00	; 0
    4bcc:	9c 01       	movw	r18, r24
    4bce:	73 e0       	ldi	r23, 0x03	; 3
    4bd0:	22 0f       	add	r18, r18
    4bd2:	33 1f       	adc	r19, r19
    4bd4:	7a 95       	dec	r23
    4bd6:	e1 f7       	brne	.-8      	; 0x4bd0 <vCoRoutineSchedule+0x166>
    4bd8:	28 0f       	add	r18, r24
    4bda:	39 1f       	adc	r19, r25
    4bdc:	f9 01       	movw	r30, r18
    4bde:	e6 54       	subi	r30, 0x46	; 70
    4be0:	fe 4f       	sbci	r31, 0xFE	; 254
    4be2:	50 81       	ld	r21, Z
    4be4:	55 23       	and	r21, r21
    4be6:	51 f3       	breq	.-44     	; 0x4bbc <vCoRoutineSchedule+0x152>
    4be8:	40 93 b9 01 	sts	0x01B9, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4bec:	a1 81       	ldd	r26, Z+1	; 0x01
    4bee:	b2 81       	ldd	r27, Z+2	; 0x02
    4bf0:	12 96       	adiw	r26, 0x02	; 2
    4bf2:	0d 90       	ld	r0, X+
    4bf4:	bc 91       	ld	r27, X
    4bf6:	a0 2d       	mov	r26, r0
    4bf8:	b2 83       	std	Z+2, r27	; 0x02
    4bfa:	a1 83       	std	Z+1, r26	; 0x01
    4bfc:	23 54       	subi	r18, 0x43	; 67
    4bfe:	3e 4f       	sbci	r19, 0xFE	; 254
    4c00:	a2 17       	cp	r26, r18
    4c02:	b3 07       	cpc	r27, r19
    4c04:	31 f4       	brne	.+12     	; 0x4c12 <vCoRoutineSchedule+0x1a8>
    4c06:	12 96       	adiw	r26, 0x02	; 2
    4c08:	2d 91       	ld	r18, X+
    4c0a:	3c 91       	ld	r19, X
    4c0c:	13 97       	sbiw	r26, 0x03	; 3
    4c0e:	32 83       	std	Z+2, r19	; 0x02
    4c10:	21 83       	std	Z+1, r18	; 0x01
    4c12:	fc 01       	movw	r30, r24
    4c14:	63 e0       	ldi	r22, 0x03	; 3
    4c16:	ee 0f       	add	r30, r30
    4c18:	ff 1f       	adc	r31, r31
    4c1a:	6a 95       	dec	r22
    4c1c:	e1 f7       	brne	.-8      	; 0x4c16 <vCoRoutineSchedule+0x1ac>
    4c1e:	e8 0f       	add	r30, r24
    4c20:	f9 1f       	adc	r31, r25
    4c22:	e6 54       	subi	r30, 0x46	; 70
    4c24:	fe 4f       	sbci	r31, 0xFE	; 254
    4c26:	01 80       	ldd	r0, Z+1	; 0x01
    4c28:	f2 81       	ldd	r31, Z+2	; 0x02
    4c2a:	e0 2d       	mov	r30, r0
    4c2c:	a6 81       	ldd	r26, Z+6	; 0x06
    4c2e:	b7 81       	ldd	r27, Z+7	; 0x07
    4c30:	b0 93 af 01 	sts	0x01AF, r27
    4c34:	a0 93 ae 01 	sts	0x01AE, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    4c38:	ed 91       	ld	r30, X+
    4c3a:	fc 91       	ld	r31, X
    4c3c:	11 97       	sbiw	r26, 0x01	; 1
    4c3e:	cd 01       	movw	r24, r26
    4c40:	57 96       	adiw	r26, 0x17	; 23
    4c42:	6c 91       	ld	r22, X
    4c44:	09 95       	icall

	return;
}
    4c46:	df 91       	pop	r29
    4c48:	cf 91       	pop	r28
    4c4a:	1f 91       	pop	r17
    4c4c:	0f 91       	pop	r16
    4c4e:	08 95       	ret

00004c50 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    4c50:	0f 93       	push	r16
    4c52:	1f 93       	push	r17
    4c54:	cf 93       	push	r28
    4c56:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4c58:	dc 01       	movw	r26, r24
    4c5a:	15 96       	adiw	r26, 0x05	; 5
    4c5c:	ed 91       	ld	r30, X+
    4c5e:	fc 91       	ld	r31, X
    4c60:	16 97       	sbiw	r26, 0x06	; 6
    4c62:	c6 81       	ldd	r28, Z+6	; 0x06
    4c64:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4c66:	8e 01       	movw	r16, r28
    4c68:	04 5f       	subi	r16, 0xF4	; 244
    4c6a:	1f 4f       	sbci	r17, 0xFF	; 255
    4c6c:	c8 01       	movw	r24, r16
    4c6e:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    4c72:	80 eb       	ldi	r24, 0xB0	; 176
    4c74:	91 e0       	ldi	r25, 0x01	; 1
    4c76:	b8 01       	movw	r22, r16
    4c78:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    4c7c:	e0 91 ae 01 	lds	r30, 0x01AE
    4c80:	f0 91 af 01 	lds	r31, 0x01AF
	{
		xReturn = pdTRUE;
    4c84:	81 e0       	ldi	r24, 0x01	; 1
    4c86:	2e 89       	ldd	r18, Y+22	; 0x16
    4c88:	96 89       	ldd	r25, Z+22	; 0x16
    4c8a:	29 17       	cp	r18, r25
    4c8c:	08 f4       	brcc	.+2      	; 0x4c90 <xCoRoutineRemoveFromEventList+0x40>
    4c8e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    4c90:	df 91       	pop	r29
    4c92:	cf 91       	pop	r28
    4c94:	1f 91       	pop	r17
    4c96:	0f 91       	pop	r16
    4c98:	08 95       	ret

00004c9a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4c9a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    4c9c:	03 96       	adiw	r24, 0x03	; 3
    4c9e:	92 83       	std	Z+2, r25	; 0x02
    4ca0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4ca2:	2f ef       	ldi	r18, 0xFF	; 255
    4ca4:	3f ef       	ldi	r19, 0xFF	; 255
    4ca6:	34 83       	std	Z+4, r19	; 0x04
    4ca8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    4caa:	96 83       	std	Z+6, r25	; 0x06
    4cac:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    4cae:	90 87       	std	Z+8, r25	; 0x08
    4cb0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    4cb2:	10 82       	st	Z, r1
}
    4cb4:	08 95       	ret

00004cb6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    4cb6:	fc 01       	movw	r30, r24
    4cb8:	11 86       	std	Z+9, r1	; 0x09
    4cba:	10 86       	std	Z+8, r1	; 0x08
}
    4cbc:	08 95       	ret

00004cbe <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4cbe:	cf 93       	push	r28
    4cc0:	df 93       	push	r29
    4cc2:	fc 01       	movw	r30, r24
    4cc4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    4cc6:	21 81       	ldd	r18, Z+1	; 0x01
    4cc8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    4cca:	e9 01       	movw	r28, r18
    4ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    4cce:	9b 81       	ldd	r25, Y+3	; 0x03
    4cd0:	13 96       	adiw	r26, 0x03	; 3
    4cd2:	9c 93       	st	X, r25
    4cd4:	8e 93       	st	-X, r24
    4cd6:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4cd8:	15 96       	adiw	r26, 0x05	; 5
    4cda:	3c 93       	st	X, r19
    4cdc:	2e 93       	st	-X, r18
    4cde:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ce4:	ec 01       	movw	r28, r24
    4ce6:	7d 83       	std	Y+5, r23	; 0x05
    4ce8:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    4cea:	e9 01       	movw	r28, r18
    4cec:	7b 83       	std	Y+3, r23	; 0x03
    4cee:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4cf0:	72 83       	std	Z+2, r23	; 0x02
    4cf2:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4cf4:	19 96       	adiw	r26, 0x09	; 9
    4cf6:	fc 93       	st	X, r31
    4cf8:	ee 93       	st	-X, r30
    4cfa:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    4cfc:	80 81       	ld	r24, Z
    4cfe:	8f 5f       	subi	r24, 0xFF	; 255
    4d00:	80 83       	st	Z, r24
}
    4d02:	df 91       	pop	r29
    4d04:	cf 91       	pop	r28
    4d06:	08 95       	ret

00004d08 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    4d08:	cf 93       	push	r28
    4d0a:	df 93       	push	r29
    4d0c:	ac 01       	movw	r20, r24
    4d0e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    4d10:	88 81       	ld	r24, Y
    4d12:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4d14:	2f ef       	ldi	r18, 0xFF	; 255
    4d16:	8f 3f       	cpi	r24, 0xFF	; 255
    4d18:	92 07       	cpc	r25, r18
    4d1a:	21 f4       	brne	.+8      	; 0x4d24 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    4d1c:	fa 01       	movw	r30, r20
    4d1e:	a7 81       	ldd	r26, Z+7	; 0x07
    4d20:	b0 85       	ldd	r27, Z+8	; 0x08
    4d22:	11 c0       	rjmp	.+34     	; 0x4d46 <vListInsert+0x3e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    4d24:	da 01       	movw	r26, r20
    4d26:	13 96       	adiw	r26, 0x03	; 3
    4d28:	04 c0       	rjmp	.+8      	; 0x4d32 <vListInsert+0x2a>
    4d2a:	12 96       	adiw	r26, 0x02	; 2
    4d2c:	0d 90       	ld	r0, X+
    4d2e:	bc 91       	ld	r27, X
    4d30:	a0 2d       	mov	r26, r0
    4d32:	12 96       	adiw	r26, 0x02	; 2
    4d34:	2d 91       	ld	r18, X+
    4d36:	3c 91       	ld	r19, X
    4d38:	13 97       	sbiw	r26, 0x03	; 3
    4d3a:	f9 01       	movw	r30, r18
    4d3c:	20 81       	ld	r18, Z
    4d3e:	31 81       	ldd	r19, Z+1	; 0x01
    4d40:	82 17       	cp	r24, r18
    4d42:	93 07       	cpc	r25, r19
    4d44:	90 f7       	brcc	.-28     	; 0x4d2a <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4d46:	12 96       	adiw	r26, 0x02	; 2
    4d48:	8d 91       	ld	r24, X+
    4d4a:	9c 91       	ld	r25, X
    4d4c:	13 97       	sbiw	r26, 0x03	; 3
    4d4e:	9b 83       	std	Y+3, r25	; 0x03
    4d50:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4d52:	fc 01       	movw	r30, r24
    4d54:	d5 83       	std	Z+5, r29	; 0x05
    4d56:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4d58:	bd 83       	std	Y+5, r27	; 0x05
    4d5a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    4d5c:	13 96       	adiw	r26, 0x03	; 3
    4d5e:	dc 93       	st	X, r29
    4d60:	ce 93       	st	-X, r28
    4d62:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4d64:	59 87       	std	Y+9, r21	; 0x09
    4d66:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    4d68:	fa 01       	movw	r30, r20
    4d6a:	80 81       	ld	r24, Z
    4d6c:	8f 5f       	subi	r24, 0xFF	; 255
    4d6e:	80 83       	st	Z, r24
}
    4d70:	df 91       	pop	r29
    4d72:	cf 91       	pop	r28
    4d74:	08 95       	ret

00004d76 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4d76:	cf 93       	push	r28
    4d78:	df 93       	push	r29
    4d7a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4d7c:	a2 81       	ldd	r26, Z+2	; 0x02
    4d7e:	b3 81       	ldd	r27, Z+3	; 0x03
    4d80:	84 81       	ldd	r24, Z+4	; 0x04
    4d82:	95 81       	ldd	r25, Z+5	; 0x05
    4d84:	15 96       	adiw	r26, 0x05	; 5
    4d86:	9c 93       	st	X, r25
    4d88:	8e 93       	st	-X, r24
    4d8a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4d8c:	c4 81       	ldd	r28, Z+4	; 0x04
    4d8e:	d5 81       	ldd	r29, Z+5	; 0x05
    4d90:	bb 83       	std	Y+3, r27	; 0x03
    4d92:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    4d94:	a0 85       	ldd	r26, Z+8	; 0x08
    4d96:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4d98:	11 96       	adiw	r26, 0x01	; 1
    4d9a:	8d 91       	ld	r24, X+
    4d9c:	9c 91       	ld	r25, X
    4d9e:	12 97       	sbiw	r26, 0x02	; 2
    4da0:	8e 17       	cp	r24, r30
    4da2:	9f 07       	cpc	r25, r31
    4da4:	21 f4       	brne	.+8      	; 0x4dae <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    4da6:	12 96       	adiw	r26, 0x02	; 2
    4da8:	dc 93       	st	X, r29
    4daa:	ce 93       	st	-X, r28
    4dac:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    4dae:	11 86       	std	Z+9, r1	; 0x09
    4db0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4db2:	8c 91       	ld	r24, X
    4db4:	81 50       	subi	r24, 0x01	; 1
    4db6:	8c 93       	st	X, r24
}
    4db8:	df 91       	pop	r29
    4dba:	cf 91       	pop	r28
    4dbc:	08 95       	ret

00004dbe <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4dbe:	0f 93       	push	r16
    4dc0:	1f 93       	push	r17
    4dc2:	cf 93       	push	r28
    4dc4:	df 93       	push	r29
    4dc6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4dc8:	0f b6       	in	r0, 0x3f	; 63
    4dca:	f8 94       	cli
    4dcc:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4dce:	8c 01       	movw	r16, r24
    4dd0:	0f 5e       	subi	r16, 0xEF	; 239
    4dd2:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4dd4:	0d c0       	rjmp	.+26     	; 0x4df0 <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4dd6:	89 89       	ldd	r24, Y+17	; 0x11
    4dd8:	88 23       	and	r24, r24
    4dda:	69 f0       	breq	.+26     	; 0x4df6 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4ddc:	c8 01       	movw	r24, r16
    4dde:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    4de2:	88 23       	and	r24, r24
    4de4:	11 f0       	breq	.+4      	; 0x4dea <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4de6:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    4dea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4dec:	81 50       	subi	r24, 0x01	; 1
    4dee:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4df0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4df2:	18 16       	cp	r1, r24
    4df4:	84 f3       	brlt	.-32     	; 0x4dd6 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4df6:	8f ef       	ldi	r24, 0xFF	; 255
    4df8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4dfa:	0f 90       	pop	r0
    4dfc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4dfe:	0f b6       	in	r0, 0x3f	; 63
    4e00:	f8 94       	cli
    4e02:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4e04:	8e 01       	movw	r16, r28
    4e06:	08 5f       	subi	r16, 0xF8	; 248
    4e08:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4e0a:	0d c0       	rjmp	.+26     	; 0x4e26 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4e0c:	88 85       	ldd	r24, Y+8	; 0x08
    4e0e:	88 23       	and	r24, r24
    4e10:	69 f0       	breq	.+26     	; 0x4e2c <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4e12:	c8 01       	movw	r24, r16
    4e14:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    4e18:	88 23       	and	r24, r24
    4e1a:	11 f0       	breq	.+4      	; 0x4e20 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    4e1c:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4e20:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4e22:	81 50       	subi	r24, 0x01	; 1
    4e24:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4e26:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4e28:	18 16       	cp	r1, r24
    4e2a:	84 f3       	brlt	.-32     	; 0x4e0c <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4e2c:	8f ef       	ldi	r24, 0xFF	; 255
    4e2e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4e30:	0f 90       	pop	r0
    4e32:	0f be       	out	0x3f, r0	; 63
}
    4e34:	df 91       	pop	r29
    4e36:	cf 91       	pop	r28
    4e38:	1f 91       	pop	r17
    4e3a:	0f 91       	pop	r16
    4e3c:	08 95       	ret

00004e3e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    4e3e:	af 92       	push	r10
    4e40:	bf 92       	push	r11
    4e42:	cf 92       	push	r12
    4e44:	df 92       	push	r13
    4e46:	ef 92       	push	r14
    4e48:	ff 92       	push	r15
    4e4a:	0f 93       	push	r16
    4e4c:	1f 93       	push	r17
    4e4e:	cf 93       	push	r28
    4e50:	df 93       	push	r29
    4e52:	b8 2e       	mov	r11, r24
    4e54:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4e56:	88 23       	and	r24, r24
    4e58:	09 f4       	brne	.+2      	; 0x4e5c <xQueueCreate+0x1e>
    4e5a:	43 c0       	rjmp	.+134    	; 0x4ee2 <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4e5c:	8f e1       	ldi	r24, 0x1F	; 31
    4e5e:	90 e0       	ldi	r25, 0x00	; 0
    4e60:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <pvPortMalloc>
    4e64:	e8 2e       	mov	r14, r24
    4e66:	e7 01       	movw	r28, r14
    4e68:	7e 01       	movw	r14, r28
    4e6a:	f9 2e       	mov	r15, r25
    4e6c:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    4e6e:	20 97       	sbiw	r28, 0x00	; 0
    4e70:	c1 f1       	breq	.+112    	; 0x4ee2 <xQueueCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4e72:	0b 2d       	mov	r16, r11
    4e74:	10 e0       	ldi	r17, 0x00	; 0
    4e76:	ca 2c       	mov	r12, r10
    4e78:	dd 24       	eor	r13, r13
    4e7a:	c0 9e       	mul	r12, r16
    4e7c:	70 01       	movw	r14, r0
    4e7e:	c1 9e       	mul	r12, r17
    4e80:	f0 0c       	add	r15, r0
    4e82:	d0 9e       	mul	r13, r16
    4e84:	f0 0c       	add	r15, r0
    4e86:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4e88:	c7 01       	movw	r24, r14
    4e8a:	01 96       	adiw	r24, 0x01	; 1
    4e8c:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <pvPortMalloc>
    4e90:	99 83       	std	Y+1, r25	; 0x01
    4e92:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    4e94:	00 97       	sbiw	r24, 0x00	; 0
    4e96:	11 f1       	breq	.+68     	; 0x4edc <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4e98:	e8 0e       	add	r14, r24
    4e9a:	f9 1e       	adc	r15, r25
    4e9c:	fb 82       	std	Y+3, r15	; 0x03
    4e9e:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4ea0:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    4ea2:	9d 83       	std	Y+5, r25	; 0x05
    4ea4:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    4ea6:	01 50       	subi	r16, 0x01	; 1
    4ea8:	10 40       	sbci	r17, 0x00	; 0
    4eaa:	0c 9d       	mul	r16, r12
    4eac:	a0 01       	movw	r20, r0
    4eae:	0d 9d       	mul	r16, r13
    4eb0:	50 0d       	add	r21, r0
    4eb2:	1c 9d       	mul	r17, r12
    4eb4:	50 0d       	add	r21, r0
    4eb6:	11 24       	eor	r1, r1
    4eb8:	48 0f       	add	r20, r24
    4eba:	59 1f       	adc	r21, r25
    4ebc:	5f 83       	std	Y+7, r21	; 0x07
    4ebe:	4e 83       	std	Y+6, r20	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    4ec0:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    4ec2:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    4ec4:	8f ef       	ldi	r24, 0xFF	; 255
    4ec6:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    4ec8:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4eca:	ce 01       	movw	r24, r28
    4ecc:	08 96       	adiw	r24, 0x08	; 8
    4ece:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4ed2:	ce 01       	movw	r24, r28
    4ed4:	41 96       	adiw	r24, 0x11	; 17
    4ed6:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
    4eda:	05 c0       	rjmp	.+10     	; 0x4ee6 <xQueueCreate+0xa8>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    4edc:	ce 01       	movw	r24, r28
    4ede:	0e 94 62 2f 	call	0x5ec4	; 0x5ec4 <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4ee2:	c0 e0       	ldi	r28, 0x00	; 0
    4ee4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    4ee6:	ce 01       	movw	r24, r28
    4ee8:	df 91       	pop	r29
    4eea:	cf 91       	pop	r28
    4eec:	1f 91       	pop	r17
    4eee:	0f 91       	pop	r16
    4ef0:	ff 90       	pop	r15
    4ef2:	ef 90       	pop	r14
    4ef4:	df 90       	pop	r13
    4ef6:	cf 90       	pop	r12
    4ef8:	bf 90       	pop	r11
    4efa:	af 90       	pop	r10
    4efc:	08 95       	ret

00004efe <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4efe:	7f 92       	push	r7
    4f00:	8f 92       	push	r8
    4f02:	9f 92       	push	r9
    4f04:	af 92       	push	r10
    4f06:	bf 92       	push	r11
    4f08:	cf 92       	push	r12
    4f0a:	df 92       	push	r13
    4f0c:	ef 92       	push	r14
    4f0e:	ff 92       	push	r15
    4f10:	0f 93       	push	r16
    4f12:	1f 93       	push	r17
    4f14:	df 93       	push	r29
    4f16:	cf 93       	push	r28
    4f18:	00 d0       	rcall	.+0      	; 0x4f1a <xQueueGenericSend+0x1c>
    4f1a:	00 d0       	rcall	.+0      	; 0x4f1c <xQueueGenericSend+0x1e>
    4f1c:	0f 92       	push	r0
    4f1e:	cd b7       	in	r28, 0x3d	; 61
    4f20:	de b7       	in	r29, 0x3e	; 62
    4f22:	8c 01       	movw	r16, r24
    4f24:	6b 01       	movw	r12, r22
    4f26:	5d 83       	std	Y+5, r21	; 0x05
    4f28:	4c 83       	std	Y+4, r20	; 0x04
    4f2a:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4f2c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4f2e:	7e 01       	movw	r14, r28
    4f30:	08 94       	sec
    4f32:	e1 1c       	adc	r14, r1
    4f34:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4f36:	94 e0       	ldi	r25, 0x04	; 4
    4f38:	a9 2e       	mov	r10, r25
    4f3a:	b1 2c       	mov	r11, r1
    4f3c:	ac 0e       	add	r10, r28
    4f3e:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4f40:	88 e0       	ldi	r24, 0x08	; 8
    4f42:	88 2e       	mov	r8, r24
    4f44:	91 2c       	mov	r9, r1
    4f46:	80 0e       	add	r8, r16
    4f48:	91 1e       	adc	r9, r17
    4f4a:	01 c0       	rjmp	.+2      	; 0x4f4e <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4f4c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4f4e:	0f b6       	in	r0, 0x3f	; 63
    4f50:	f8 94       	cli
    4f52:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4f54:	f8 01       	movw	r30, r16
    4f56:	92 8d       	ldd	r25, Z+26	; 0x1a
    4f58:	83 8d       	ldd	r24, Z+27	; 0x1b
    4f5a:	98 17       	cp	r25, r24
    4f5c:	08 f0       	brcs	.+2      	; 0x4f60 <xQueueGenericSend+0x62>
    4f5e:	4e c0       	rjmp	.+156    	; 0x4ffc <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    4f60:	44 8d       	ldd	r20, Z+28	; 0x1c
    4f62:	44 23       	and	r20, r20
    4f64:	c1 f1       	breq	.+112    	; 0x4fd6 <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    4f66:	77 20       	and	r7, r7
    4f68:	c1 f4       	brne	.+48     	; 0x4f9a <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4f6a:	84 81       	ldd	r24, Z+4	; 0x04
    4f6c:	95 81       	ldd	r25, Z+5	; 0x05
    4f6e:	b6 01       	movw	r22, r12
    4f70:	50 e0       	ldi	r21, 0x00	; 0
    4f72:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4f76:	f8 01       	movw	r30, r16
    4f78:	24 8d       	ldd	r18, Z+28	; 0x1c
    4f7a:	84 81       	ldd	r24, Z+4	; 0x04
    4f7c:	95 81       	ldd	r25, Z+5	; 0x05
    4f7e:	82 0f       	add	r24, r18
    4f80:	91 1d       	adc	r25, r1
    4f82:	95 83       	std	Z+5, r25	; 0x05
    4f84:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    4f86:	22 81       	ldd	r18, Z+2	; 0x02
    4f88:	33 81       	ldd	r19, Z+3	; 0x03
    4f8a:	82 17       	cp	r24, r18
    4f8c:	93 07       	cpc	r25, r19
    4f8e:	18 f1       	brcs	.+70     	; 0x4fd6 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4f90:	80 81       	ld	r24, Z
    4f92:	91 81       	ldd	r25, Z+1	; 0x01
    4f94:	95 83       	std	Z+5, r25	; 0x05
    4f96:	84 83       	std	Z+4, r24	; 0x04
    4f98:	1e c0       	rjmp	.+60     	; 0x4fd6 <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4f9a:	f8 01       	movw	r30, r16
    4f9c:	86 81       	ldd	r24, Z+6	; 0x06
    4f9e:	97 81       	ldd	r25, Z+7	; 0x07
    4fa0:	b6 01       	movw	r22, r12
    4fa2:	50 e0       	ldi	r21, 0x00	; 0
    4fa4:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    4fa8:	f8 01       	movw	r30, r16
    4faa:	24 8d       	ldd	r18, Z+28	; 0x1c
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	30 95       	com	r19
    4fb0:	21 95       	neg	r18
    4fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fb4:	86 81       	ldd	r24, Z+6	; 0x06
    4fb6:	97 81       	ldd	r25, Z+7	; 0x07
    4fb8:	82 0f       	add	r24, r18
    4fba:	93 1f       	adc	r25, r19
    4fbc:	97 83       	std	Z+7, r25	; 0x07
    4fbe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4fc0:	40 81       	ld	r20, Z
    4fc2:	51 81       	ldd	r21, Z+1	; 0x01
    4fc4:	84 17       	cp	r24, r20
    4fc6:	95 07       	cpc	r25, r21
    4fc8:	30 f4       	brcc	.+12     	; 0x4fd6 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4fca:	82 81       	ldd	r24, Z+2	; 0x02
    4fcc:	93 81       	ldd	r25, Z+3	; 0x03
    4fce:	82 0f       	add	r24, r18
    4fd0:	93 1f       	adc	r25, r19
    4fd2:	97 83       	std	Z+7, r25	; 0x07
    4fd4:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4fd6:	f8 01       	movw	r30, r16
    4fd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4fda:	8f 5f       	subi	r24, 0xFF	; 255
    4fdc:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4fde:	81 89       	ldd	r24, Z+17	; 0x11
    4fe0:	88 23       	and	r24, r24
    4fe2:	41 f0       	breq	.+16     	; 0x4ff4 <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    4fe4:	c8 01       	movw	r24, r16
    4fe6:	41 96       	adiw	r24, 0x11	; 17
    4fe8:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    4fec:	81 30       	cpi	r24, 0x01	; 1
    4fee:	11 f4       	brne	.+4      	; 0x4ff4 <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    4ff0:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    4ff4:	0f 90       	pop	r0
    4ff6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    4ff8:	81 e0       	ldi	r24, 0x01	; 1
    4ffa:	4c c0       	rjmp	.+152    	; 0x5094 <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4ffc:	8c 81       	ldd	r24, Y+4	; 0x04
    4ffe:	9d 81       	ldd	r25, Y+5	; 0x05
    5000:	00 97       	sbiw	r24, 0x00	; 0
    5002:	19 f4       	brne	.+6      	; 0x500a <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5004:	0f 90       	pop	r0
    5006:	0f be       	out	0x3f, r0	; 63
    5008:	44 c0       	rjmp	.+136    	; 0x5092 <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    500a:	22 23       	and	r18, r18
    500c:	19 f4       	brne	.+6      	; 0x5014 <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    500e:	c7 01       	movw	r24, r14
    5010:	0e 94 b8 2d 	call	0x5b70	; 0x5b70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    5014:	0f 90       	pop	r0
    5016:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5018:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    501c:	0f b6       	in	r0, 0x3f	; 63
    501e:	f8 94       	cli
    5020:	0f 92       	push	r0
    5022:	f8 01       	movw	r30, r16
    5024:	85 8d       	ldd	r24, Z+29	; 0x1d
    5026:	8f 3f       	cpi	r24, 0xFF	; 255
    5028:	09 f4       	brne	.+2      	; 0x502c <xQueueGenericSend+0x12e>
    502a:	15 8e       	std	Z+29, r1	; 0x1d
    502c:	f8 01       	movw	r30, r16
    502e:	86 8d       	ldd	r24, Z+30	; 0x1e
    5030:	8f 3f       	cpi	r24, 0xFF	; 255
    5032:	09 f4       	brne	.+2      	; 0x5036 <xQueueGenericSend+0x138>
    5034:	16 8e       	std	Z+30, r1	; 0x1e
    5036:	0f 90       	pop	r0
    5038:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    503a:	c7 01       	movw	r24, r14
    503c:	b5 01       	movw	r22, r10
    503e:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <xTaskCheckForTimeOut>
    5042:	88 23       	and	r24, r24
    5044:	09 f5       	brne	.+66     	; 0x5088 <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5046:	0f b6       	in	r0, 0x3f	; 63
    5048:	f8 94       	cli
    504a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    504c:	f8 01       	movw	r30, r16
    504e:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5050:	0f 90       	pop	r0
    5052:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5054:	f8 01       	movw	r30, r16
    5056:	83 8d       	ldd	r24, Z+27	; 0x1b
    5058:	98 17       	cp	r25, r24
    505a:	81 f4       	brne	.+32     	; 0x507c <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    505c:	6c 81       	ldd	r22, Y+4	; 0x04
    505e:	7d 81       	ldd	r23, Y+5	; 0x05
    5060:	c4 01       	movw	r24, r8
    5062:	0e 94 59 2d 	call	0x5ab2	; 0x5ab2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5066:	c8 01       	movw	r24, r16
    5068:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    506c:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
    5070:	88 23       	and	r24, r24
    5072:	09 f0       	breq	.+2      	; 0x5076 <xQueueGenericSend+0x178>
    5074:	6b cf       	rjmp	.-298    	; 0x4f4c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    5076:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
    507a:	68 cf       	rjmp	.-304    	; 0x4f4c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    507c:	c8 01       	movw	r24, r16
    507e:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5082:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
    5086:	62 cf       	rjmp	.-316    	; 0x4f4c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5088:	c8 01       	movw	r24, r16
    508a:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    508e:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5092:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    5094:	0f 90       	pop	r0
    5096:	0f 90       	pop	r0
    5098:	0f 90       	pop	r0
    509a:	0f 90       	pop	r0
    509c:	0f 90       	pop	r0
    509e:	cf 91       	pop	r28
    50a0:	df 91       	pop	r29
    50a2:	1f 91       	pop	r17
    50a4:	0f 91       	pop	r16
    50a6:	ff 90       	pop	r15
    50a8:	ef 90       	pop	r14
    50aa:	df 90       	pop	r13
    50ac:	cf 90       	pop	r12
    50ae:	bf 90       	pop	r11
    50b0:	af 90       	pop	r10
    50b2:	9f 90       	pop	r9
    50b4:	8f 90       	pop	r8
    50b6:	7f 90       	pop	r7
    50b8:	08 95       	ret

000050ba <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    50ba:	0f 93       	push	r16
    50bc:	1f 93       	push	r17
    50be:	cf 93       	push	r28
    50c0:	df 93       	push	r29
    50c2:	ec 01       	movw	r28, r24
    50c4:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    50c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    50c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    50ca:	98 17       	cp	r25, r24
    50cc:	08 f0       	brcs	.+2      	; 0x50d0 <xQueueGenericSendFromISR+0x16>
    50ce:	4c c0       	rjmp	.+152    	; 0x5168 <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    50d0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    50d2:	44 23       	and	r20, r20
    50d4:	99 f1       	breq	.+102    	; 0x513c <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    50d6:	22 23       	and	r18, r18
    50d8:	b1 f4       	brne	.+44     	; 0x5106 <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    50da:	8c 81       	ldd	r24, Y+4	; 0x04
    50dc:	9d 81       	ldd	r25, Y+5	; 0x05
    50de:	50 e0       	ldi	r21, 0x00	; 0
    50e0:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    50e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    50e6:	8c 81       	ldd	r24, Y+4	; 0x04
    50e8:	9d 81       	ldd	r25, Y+5	; 0x05
    50ea:	82 0f       	add	r24, r18
    50ec:	91 1d       	adc	r25, r1
    50ee:	9d 83       	std	Y+5, r25	; 0x05
    50f0:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    50f2:	2a 81       	ldd	r18, Y+2	; 0x02
    50f4:	3b 81       	ldd	r19, Y+3	; 0x03
    50f6:	82 17       	cp	r24, r18
    50f8:	93 07       	cpc	r25, r19
    50fa:	00 f1       	brcs	.+64     	; 0x513c <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    50fc:	88 81       	ld	r24, Y
    50fe:	99 81       	ldd	r25, Y+1	; 0x01
    5100:	9d 83       	std	Y+5, r25	; 0x05
    5102:	8c 83       	std	Y+4, r24	; 0x04
    5104:	1b c0       	rjmp	.+54     	; 0x513c <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5106:	8e 81       	ldd	r24, Y+6	; 0x06
    5108:	9f 81       	ldd	r25, Y+7	; 0x07
    510a:	50 e0       	ldi	r21, 0x00	; 0
    510c:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    5110:	2c 8d       	ldd	r18, Y+28	; 0x1c
    5112:	30 e0       	ldi	r19, 0x00	; 0
    5114:	30 95       	com	r19
    5116:	21 95       	neg	r18
    5118:	3f 4f       	sbci	r19, 0xFF	; 255
    511a:	8e 81       	ldd	r24, Y+6	; 0x06
    511c:	9f 81       	ldd	r25, Y+7	; 0x07
    511e:	82 0f       	add	r24, r18
    5120:	93 1f       	adc	r25, r19
    5122:	9f 83       	std	Y+7, r25	; 0x07
    5124:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    5126:	48 81       	ld	r20, Y
    5128:	59 81       	ldd	r21, Y+1	; 0x01
    512a:	84 17       	cp	r24, r20
    512c:	95 07       	cpc	r25, r21
    512e:	30 f4       	brcc	.+12     	; 0x513c <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    5130:	8a 81       	ldd	r24, Y+2	; 0x02
    5132:	9b 81       	ldd	r25, Y+3	; 0x03
    5134:	82 0f       	add	r24, r18
    5136:	93 1f       	adc	r25, r19
    5138:	9f 83       	std	Y+7, r25	; 0x07
    513a:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    513c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    513e:	8f 5f       	subi	r24, 0xFF	; 255
    5140:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    5142:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5144:	8f 3f       	cpi	r24, 0xFF	; 255
    5146:	69 f4       	brne	.+26     	; 0x5162 <xQueueGenericSendFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5148:	89 89       	ldd	r24, Y+17	; 0x11
    514a:	88 23       	and	r24, r24
    514c:	79 f0       	breq	.+30     	; 0x516c <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    514e:	ce 01       	movw	r24, r28
    5150:	41 96       	adiw	r24, 0x11	; 17
    5152:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    5156:	88 23       	and	r24, r24
    5158:	49 f0       	breq	.+18     	; 0x516c <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    515a:	81 e0       	ldi	r24, 0x01	; 1
    515c:	f8 01       	movw	r30, r16
    515e:	80 83       	st	Z, r24
    5160:	06 c0       	rjmp	.+12     	; 0x516e <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5162:	8f 5f       	subi	r24, 0xFF	; 255
    5164:	8e 8f       	std	Y+30, r24	; 0x1e
    5166:	02 c0       	rjmp	.+4      	; 0x516c <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5168:	80 e0       	ldi	r24, 0x00	; 0
    516a:	01 c0       	rjmp	.+2      	; 0x516e <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    516c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    516e:	df 91       	pop	r29
    5170:	cf 91       	pop	r28
    5172:	1f 91       	pop	r17
    5174:	0f 91       	pop	r16
    5176:	08 95       	ret

00005178 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    5178:	7f 92       	push	r7
    517a:	8f 92       	push	r8
    517c:	9f 92       	push	r9
    517e:	af 92       	push	r10
    5180:	bf 92       	push	r11
    5182:	cf 92       	push	r12
    5184:	df 92       	push	r13
    5186:	ef 92       	push	r14
    5188:	ff 92       	push	r15
    518a:	0f 93       	push	r16
    518c:	1f 93       	push	r17
    518e:	df 93       	push	r29
    5190:	cf 93       	push	r28
    5192:	00 d0       	rcall	.+0      	; 0x5194 <xQueueGenericReceive+0x1c>
    5194:	00 d0       	rcall	.+0      	; 0x5196 <xQueueGenericReceive+0x1e>
    5196:	0f 92       	push	r0
    5198:	cd b7       	in	r28, 0x3d	; 61
    519a:	de b7       	in	r29, 0x3e	; 62
    519c:	8c 01       	movw	r16, r24
    519e:	86 2e       	mov	r8, r22
    51a0:	77 2e       	mov	r7, r23
    51a2:	5d 83       	std	Y+5, r21	; 0x05
    51a4:	4c 83       	std	Y+4, r20	; 0x04
    51a6:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    51a8:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    51aa:	7e 01       	movw	r14, r28
    51ac:	08 94       	sec
    51ae:	e1 1c       	adc	r14, r1
    51b0:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    51b2:	44 e0       	ldi	r20, 0x04	; 4
    51b4:	c4 2e       	mov	r12, r20
    51b6:	d1 2c       	mov	r13, r1
    51b8:	cc 0e       	add	r12, r28
    51ba:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    51bc:	31 e1       	ldi	r19, 0x11	; 17
    51be:	a3 2e       	mov	r10, r19
    51c0:	b1 2c       	mov	r11, r1
    51c2:	a8 0e       	add	r10, r24
    51c4:	b9 1e       	adc	r11, r25
    51c6:	01 c0       	rjmp	.+2      	; 0x51ca <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    51c8:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    51ca:	0f b6       	in	r0, 0x3f	; 63
    51cc:	f8 94       	cli
    51ce:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    51d0:	f8 01       	movw	r30, r16
    51d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    51d4:	88 23       	and	r24, r24
    51d6:	09 f4       	brne	.+2      	; 0x51da <xQueueGenericReceive+0x62>
    51d8:	3d c0       	rjmp	.+122    	; 0x5254 <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    51da:	e6 80       	ldd	r14, Z+6	; 0x06
    51dc:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    51de:	80 81       	ld	r24, Z
    51e0:	91 81       	ldd	r25, Z+1	; 0x01
    51e2:	00 97       	sbiw	r24, 0x00	; 0
    51e4:	a9 f0       	breq	.+42     	; 0x5210 <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    51e6:	44 8d       	ldd	r20, Z+28	; 0x1c
    51e8:	97 01       	movw	r18, r14
    51ea:	24 0f       	add	r18, r20
    51ec:	31 1d       	adc	r19, r1
    51ee:	37 83       	std	Z+7, r19	; 0x07
    51f0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    51f2:	62 81       	ldd	r22, Z+2	; 0x02
    51f4:	73 81       	ldd	r23, Z+3	; 0x03
    51f6:	26 17       	cp	r18, r22
    51f8:	37 07       	cpc	r19, r23
    51fa:	10 f0       	brcs	.+4      	; 0x5200 <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    51fc:	97 83       	std	Z+7, r25	; 0x07
    51fe:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    5200:	f8 01       	movw	r30, r16
    5202:	66 81       	ldd	r22, Z+6	; 0x06
    5204:	77 81       	ldd	r23, Z+7	; 0x07
    5206:	88 2d       	mov	r24, r8
    5208:	97 2d       	mov	r25, r7
    520a:	50 e0       	ldi	r21, 0x00	; 0
    520c:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    5210:	99 20       	and	r9, r9
    5212:	71 f4       	brne	.+28     	; 0x5230 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    5214:	f8 01       	movw	r30, r16
    5216:	82 8d       	ldd	r24, Z+26	; 0x1a
    5218:	81 50       	subi	r24, 0x01	; 1
    521a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    521c:	80 85       	ldd	r24, Z+8	; 0x08
    521e:	88 23       	and	r24, r24
    5220:	a9 f0       	breq	.+42     	; 0x524c <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    5222:	c8 01       	movw	r24, r16
    5224:	08 96       	adiw	r24, 0x08	; 8
    5226:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    522a:	81 30       	cpi	r24, 0x01	; 1
    522c:	79 f4       	brne	.+30     	; 0x524c <xQueueGenericReceive+0xd4>
    522e:	0c c0       	rjmp	.+24     	; 0x5248 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5230:	f8 01       	movw	r30, r16
    5232:	f7 82       	std	Z+7, r15	; 0x07
    5234:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5236:	81 89       	ldd	r24, Z+17	; 0x11
    5238:	88 23       	and	r24, r24
    523a:	41 f0       	breq	.+16     	; 0x524c <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    523c:	c8 01       	movw	r24, r16
    523e:	41 96       	adiw	r24, 0x11	; 17
    5240:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    5244:	88 23       	and	r24, r24
    5246:	11 f0       	breq	.+4      	; 0x524c <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    5248:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    524c:	0f 90       	pop	r0
    524e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5250:	81 e0       	ldi	r24, 0x01	; 1
    5252:	4a c0       	rjmp	.+148    	; 0x52e8 <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5254:	8c 81       	ldd	r24, Y+4	; 0x04
    5256:	9d 81       	ldd	r25, Y+5	; 0x05
    5258:	00 97       	sbiw	r24, 0x00	; 0
    525a:	19 f4       	brne	.+6      	; 0x5262 <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    525c:	0f 90       	pop	r0
    525e:	0f be       	out	0x3f, r0	; 63
    5260:	42 c0       	rjmp	.+132    	; 0x52e6 <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    5262:	22 23       	and	r18, r18
    5264:	19 f4       	brne	.+6      	; 0x526c <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5266:	c7 01       	movw	r24, r14
    5268:	0e 94 b8 2d 	call	0x5b70	; 0x5b70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    526c:	0f 90       	pop	r0
    526e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5270:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5274:	0f b6       	in	r0, 0x3f	; 63
    5276:	f8 94       	cli
    5278:	0f 92       	push	r0
    527a:	f8 01       	movw	r30, r16
    527c:	85 8d       	ldd	r24, Z+29	; 0x1d
    527e:	8f 3f       	cpi	r24, 0xFF	; 255
    5280:	09 f4       	brne	.+2      	; 0x5284 <xQueueGenericReceive+0x10c>
    5282:	15 8e       	std	Z+29, r1	; 0x1d
    5284:	f8 01       	movw	r30, r16
    5286:	86 8d       	ldd	r24, Z+30	; 0x1e
    5288:	8f 3f       	cpi	r24, 0xFF	; 255
    528a:	09 f4       	brne	.+2      	; 0x528e <xQueueGenericReceive+0x116>
    528c:	16 8e       	std	Z+30, r1	; 0x1e
    528e:	0f 90       	pop	r0
    5290:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5292:	c7 01       	movw	r24, r14
    5294:	b6 01       	movw	r22, r12
    5296:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <xTaskCheckForTimeOut>
    529a:	88 23       	and	r24, r24
    529c:	f9 f4       	brne	.+62     	; 0x52dc <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    529e:	0f b6       	in	r0, 0x3f	; 63
    52a0:	f8 94       	cli
    52a2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    52a4:	f8 01       	movw	r30, r16
    52a6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    52a8:	0f 90       	pop	r0
    52aa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    52ac:	88 23       	and	r24, r24
    52ae:	81 f4       	brne	.+32     	; 0x52d0 <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    52b0:	6c 81       	ldd	r22, Y+4	; 0x04
    52b2:	7d 81       	ldd	r23, Y+5	; 0x05
    52b4:	c5 01       	movw	r24, r10
    52b6:	0e 94 59 2d 	call	0x5ab2	; 0x5ab2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    52ba:	c8 01       	movw	r24, r16
    52bc:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    52c0:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
    52c4:	88 23       	and	r24, r24
    52c6:	09 f0       	breq	.+2      	; 0x52ca <xQueueGenericReceive+0x152>
    52c8:	7f cf       	rjmp	.-258    	; 0x51c8 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    52ca:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
    52ce:	7c cf       	rjmp	.-264    	; 0x51c8 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    52d0:	c8 01       	movw	r24, r16
    52d2:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    52d6:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
    52da:	76 cf       	rjmp	.-276    	; 0x51c8 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    52dc:	c8 01       	movw	r24, r16
    52de:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    52e2:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    52e6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    52e8:	0f 90       	pop	r0
    52ea:	0f 90       	pop	r0
    52ec:	0f 90       	pop	r0
    52ee:	0f 90       	pop	r0
    52f0:	0f 90       	pop	r0
    52f2:	cf 91       	pop	r28
    52f4:	df 91       	pop	r29
    52f6:	1f 91       	pop	r17
    52f8:	0f 91       	pop	r16
    52fa:	ff 90       	pop	r15
    52fc:	ef 90       	pop	r14
    52fe:	df 90       	pop	r13
    5300:	cf 90       	pop	r12
    5302:	bf 90       	pop	r11
    5304:	af 90       	pop	r10
    5306:	9f 90       	pop	r9
    5308:	8f 90       	pop	r8
    530a:	7f 90       	pop	r7
    530c:	08 95       	ret

0000530e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    530e:	0f 93       	push	r16
    5310:	1f 93       	push	r17
    5312:	cf 93       	push	r28
    5314:	df 93       	push	r29
    5316:	ec 01       	movw	r28, r24
    5318:	cb 01       	movw	r24, r22
    531a:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    531c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    531e:	22 23       	and	r18, r18
    5320:	71 f1       	breq	.+92     	; 0x537e <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    5322:	e8 81       	ld	r30, Y
    5324:	f9 81       	ldd	r31, Y+1	; 0x01
    5326:	30 97       	sbiw	r30, 0x00	; 0
    5328:	a1 f0       	breq	.+40     	; 0x5352 <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    532a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    532c:	2e 81       	ldd	r18, Y+6	; 0x06
    532e:	3f 81       	ldd	r19, Y+7	; 0x07
    5330:	24 0f       	add	r18, r20
    5332:	31 1d       	adc	r19, r1
    5334:	3f 83       	std	Y+7, r19	; 0x07
    5336:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    5338:	aa 81       	ldd	r26, Y+2	; 0x02
    533a:	bb 81       	ldd	r27, Y+3	; 0x03
    533c:	2a 17       	cp	r18, r26
    533e:	3b 07       	cpc	r19, r27
    5340:	10 f0       	brcs	.+4      	; 0x5346 <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    5342:	ff 83       	std	Y+7, r31	; 0x07
    5344:	ee 83       	std	Y+6, r30	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    5346:	6e 81       	ldd	r22, Y+6	; 0x06
    5348:	2f 81       	ldd	r18, Y+7	; 0x07
    534a:	72 2f       	mov	r23, r18
    534c:	50 e0       	ldi	r21, 0x00	; 0
    534e:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    5352:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5354:	81 50       	subi	r24, 0x01	; 1
    5356:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    5358:	8d 8d       	ldd	r24, Y+29	; 0x1d
    535a:	8f 3f       	cpi	r24, 0xFF	; 255
    535c:	69 f4       	brne	.+26     	; 0x5378 <xQueueReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    535e:	88 85       	ldd	r24, Y+8	; 0x08
    5360:	88 23       	and	r24, r24
    5362:	79 f0       	breq	.+30     	; 0x5382 <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5364:	ce 01       	movw	r24, r28
    5366:	08 96       	adiw	r24, 0x08	; 8
    5368:	0e 94 76 2d 	call	0x5aec	; 0x5aec <xTaskRemoveFromEventList>
    536c:	88 23       	and	r24, r24
    536e:	49 f0       	breq	.+18     	; 0x5382 <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    5370:	81 e0       	ldi	r24, 0x01	; 1
    5372:	f8 01       	movw	r30, r16
    5374:	80 83       	st	Z, r24
    5376:	06 c0       	rjmp	.+12     	; 0x5384 <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    5378:	8f 5f       	subi	r24, 0xFF	; 255
    537a:	8d 8f       	std	Y+29, r24	; 0x1d
    537c:	02 c0       	rjmp	.+4      	; 0x5382 <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    537e:	80 e0       	ldi	r24, 0x00	; 0
    5380:	01 c0       	rjmp	.+2      	; 0x5384 <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    5382:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5384:	df 91       	pop	r29
    5386:	cf 91       	pop	r28
    5388:	1f 91       	pop	r17
    538a:	0f 91       	pop	r16
    538c:	08 95       	ret

0000538e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    538e:	0f b6       	in	r0, 0x3f	; 63
    5390:	f8 94       	cli
    5392:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    5394:	fc 01       	movw	r30, r24
    5396:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    5398:	0f 90       	pop	r0
    539a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    539c:	08 95       	ret

0000539e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    539e:	fc 01       	movw	r30, r24
    53a0:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    53a2:	08 95       	ret

000053a4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    53a4:	cf 93       	push	r28
    53a6:	df 93       	push	r29
    53a8:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    53aa:	88 81       	ld	r24, Y
    53ac:	99 81       	ldd	r25, Y+1	; 0x01
    53ae:	0e 94 62 2f 	call	0x5ec4	; 0x5ec4 <vPortFree>
	vPortFree( pxQueue );
    53b2:	ce 01       	movw	r24, r28
    53b4:	0e 94 62 2f 	call	0x5ec4	; 0x5ec4 <vPortFree>
}
    53b8:	df 91       	pop	r29
    53ba:	cf 91       	pop	r28
    53bc:	08 95       	ret

000053be <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    53be:	fc 01       	movw	r30, r24
    53c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    53c2:	81 e0       	ldi	r24, 0x01	; 1
    53c4:	91 11       	cpse	r25, r1
    53c6:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    53c8:	08 95       	ret

000053ca <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    53ca:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    53cc:	22 8d       	ldd	r18, Z+26	; 0x1a
    53ce:	81 e0       	ldi	r24, 0x01	; 1
    53d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    53d2:	29 13       	cpse	r18, r25
    53d4:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    53d6:	08 95       	ret

000053d8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    53d8:	cf 93       	push	r28
    53da:	df 93       	push	r29
    53dc:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    53de:	e0 91 e8 01 	lds	r30, 0x01E8
    53e2:	f0 91 e9 01 	lds	r31, 0x01E9
    53e6:	93 83       	std	Z+3, r25	; 0x03
    53e8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    53ea:	80 91 ec 01 	lds	r24, 0x01EC
    53ee:	90 91 ed 01 	lds	r25, 0x01ED
    53f2:	c8 17       	cp	r28, r24
    53f4:	d9 07       	cpc	r29, r25
    53f6:	68 f4       	brcc	.+26     	; 0x5412 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    53f8:	80 91 1d 02 	lds	r24, 0x021D
    53fc:	90 91 1e 02 	lds	r25, 0x021E
    5400:	60 91 e8 01 	lds	r22, 0x01E8
    5404:	70 91 e9 01 	lds	r23, 0x01E9
    5408:	6e 5f       	subi	r22, 0xFE	; 254
    540a:	7f 4f       	sbci	r23, 0xFF	; 255
    540c:	0e 94 84 26 	call	0x4d08	; 0x4d08 <vListInsert>
    5410:	17 c0       	rjmp	.+46     	; 0x5440 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5412:	80 91 1f 02 	lds	r24, 0x021F
    5416:	90 91 20 02 	lds	r25, 0x0220
    541a:	60 91 e8 01 	lds	r22, 0x01E8
    541e:	70 91 e9 01 	lds	r23, 0x01E9
    5422:	6e 5f       	subi	r22, 0xFE	; 254
    5424:	7f 4f       	sbci	r23, 0xFF	; 255
    5426:	0e 94 84 26 	call	0x4d08	; 0x4d08 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    542a:	80 91 9b 01 	lds	r24, 0x019B
    542e:	90 91 9c 01 	lds	r25, 0x019C
    5432:	c8 17       	cp	r28, r24
    5434:	d9 07       	cpc	r29, r25
    5436:	20 f4       	brcc	.+8      	; 0x5440 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5438:	d0 93 9c 01 	sts	0x019C, r29
    543c:	c0 93 9b 01 	sts	0x019B, r28
		}
	}
}
    5440:	df 91       	pop	r29
    5442:	cf 91       	pop	r28
    5444:	08 95       	ret

00005446 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    5446:	80 91 f0 01 	lds	r24, 0x01F0
    544a:	82 30       	cpi	r24, 0x02	; 2
    544c:	e0 f3       	brcs	.-8      	; 0x5446 <prvIdleTask>
			{
				taskYIELD();
    544e:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
    5452:	f9 cf       	rjmp	.-14     	; 0x5446 <prvIdleTask>

00005454 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    5454:	2f 92       	push	r2
    5456:	3f 92       	push	r3
    5458:	4f 92       	push	r4
    545a:	5f 92       	push	r5
    545c:	6f 92       	push	r6
    545e:	7f 92       	push	r7
    5460:	8f 92       	push	r8
    5462:	9f 92       	push	r9
    5464:	af 92       	push	r10
    5466:	bf 92       	push	r11
    5468:	cf 92       	push	r12
    546a:	df 92       	push	r13
    546c:	ef 92       	push	r14
    546e:	ff 92       	push	r15
    5470:	0f 93       	push	r16
    5472:	1f 93       	push	r17
    5474:	cf 93       	push	r28
    5476:	df 93       	push	r29
    5478:	1c 01       	movw	r2, r24
    547a:	3b 01       	movw	r6, r22
    547c:	5a 01       	movw	r10, r20
    547e:	29 01       	movw	r4, r18
    5480:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    5482:	81 e2       	ldi	r24, 0x21	; 33
    5484:	90 e0       	ldi	r25, 0x00	; 0
    5486:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <pvPortMalloc>
    548a:	e8 2e       	mov	r14, r24
    548c:	e7 01       	movw	r28, r14
    548e:	7e 01       	movw	r14, r28
    5490:	f9 2e       	mov	r15, r25
    5492:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    5494:	20 97       	sbiw	r28, 0x00	; 0
    5496:	09 f4       	brne	.+2      	; 0x549a <xTaskGenericCreate+0x46>
    5498:	d4 c0       	rjmp	.+424    	; 0x5642 <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    549a:	c1 14       	cp	r12, r1
    549c:	d1 04       	cpc	r13, r1
    549e:	29 f4       	brne	.+10     	; 0x54aa <xTaskGenericCreate+0x56>
    54a0:	c5 01       	movw	r24, r10
    54a2:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <pvPortMalloc>
    54a6:	c8 2e       	mov	r12, r24
    54a8:	d9 2e       	mov	r13, r25
    54aa:	d8 8e       	std	Y+24, r13	; 0x18
    54ac:	cf 8a       	std	Y+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    54ae:	c1 14       	cp	r12, r1
    54b0:	d1 04       	cpc	r13, r1
    54b2:	21 f4       	brne	.+8      	; 0x54bc <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    54b4:	ce 01       	movw	r24, r28
    54b6:	0e 94 62 2f 	call	0x5ec4	; 0x5ec4 <vPortFree>
    54ba:	c3 c0       	rjmp	.+390    	; 0x5642 <xTaskGenericCreate+0x1ee>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    54bc:	c6 01       	movw	r24, r12
    54be:	65 ea       	ldi	r22, 0xA5	; 165
    54c0:	70 e0       	ldi	r23, 0x00	; 0
    54c2:	a5 01       	movw	r20, r10
    54c4:	0e 94 62 32 	call	0x64c4	; 0x64c4 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    54c8:	08 94       	sec
    54ca:	a1 08       	sbc	r10, r1
    54cc:	b1 08       	sbc	r11, r1
    54ce:	ef 88       	ldd	r14, Y+23	; 0x17
    54d0:	f8 8c       	ldd	r15, Y+24	; 0x18
    54d2:	ea 0c       	add	r14, r10
    54d4:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    54d6:	ce 01       	movw	r24, r28
    54d8:	49 96       	adiw	r24, 0x19	; 25
    54da:	b3 01       	movw	r22, r6
    54dc:	48 e0       	ldi	r20, 0x08	; 8
    54de:	50 e0       	ldi	r21, 0x00	; 0
    54e0:	0e 94 69 32 	call	0x64d2	; 0x64d2 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    54e4:	18 a2       	std	Y+32, r1	; 0x20
    54e6:	10 2f       	mov	r17, r16
    54e8:	04 30       	cpi	r16, 0x04	; 4
    54ea:	08 f0       	brcs	.+2      	; 0x54ee <xTaskGenericCreate+0x9a>
    54ec:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    54ee:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    54f0:	e2 e0       	ldi	r30, 0x02	; 2
    54f2:	ae 2e       	mov	r10, r30
    54f4:	b1 2c       	mov	r11, r1
    54f6:	ac 0e       	add	r10, r28
    54f8:	bd 1e       	adc	r11, r29
    54fa:	c5 01       	movw	r24, r10
    54fc:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5500:	ce 01       	movw	r24, r28
    5502:	0c 96       	adiw	r24, 0x0c	; 12
    5504:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5508:	d9 87       	std	Y+9, r29	; 0x09
    550a:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    550c:	84 e0       	ldi	r24, 0x04	; 4
    550e:	90 e0       	ldi	r25, 0x00	; 0
    5510:	81 1b       	sub	r24, r17
    5512:	91 09       	sbc	r25, r1
    5514:	9d 87       	std	Y+13, r25	; 0x0d
    5516:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5518:	db 8b       	std	Y+19, r29	; 0x13
    551a:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    551c:	c7 01       	movw	r24, r14
    551e:	b1 01       	movw	r22, r2
    5520:	a2 01       	movw	r20, r4
    5522:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <pxPortInitialiseStack>
    5526:	99 83       	std	Y+1, r25	; 0x01
    5528:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    552a:	81 14       	cp	r8, r1
    552c:	91 04       	cpc	r9, r1
    552e:	19 f0       	breq	.+6      	; 0x5536 <xTaskGenericCreate+0xe2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5530:	f4 01       	movw	r30, r8
    5532:	d1 83       	std	Z+1, r29	; 0x01
    5534:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    5536:	0f b6       	in	r0, 0x3f	; 63
    5538:	f8 94       	cli
    553a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    553c:	80 91 22 02 	lds	r24, 0x0222
    5540:	8f 5f       	subi	r24, 0xFF	; 255
    5542:	80 93 22 02 	sts	0x0222, r24
			if( pxCurrentTCB == NULL )
    5546:	80 91 e8 01 	lds	r24, 0x01E8
    554a:	90 91 e9 01 	lds	r25, 0x01E9
    554e:	00 97       	sbiw	r24, 0x00	; 0
    5550:	c9 f5       	brne	.+114    	; 0x55c4 <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5552:	d0 93 e9 01 	sts	0x01E9, r29
    5556:	c0 93 e8 01 	sts	0x01E8, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    555a:	80 91 22 02 	lds	r24, 0x0222
    555e:	81 30       	cpi	r24, 0x01	; 1
    5560:	09 f0       	breq	.+2      	; 0x5564 <xTaskGenericCreate+0x110>
    5562:	3f c0       	rjmp	.+126    	; 0x55e2 <xTaskGenericCreate+0x18e>
    5564:	ee 24       	eor	r14, r14
    5566:	ff 24       	eor	r15, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5568:	c7 01       	movw	r24, r14
    556a:	73 e0       	ldi	r23, 0x03	; 3
    556c:	88 0f       	add	r24, r24
    556e:	99 1f       	adc	r25, r25
    5570:	7a 95       	dec	r23
    5572:	e1 f7       	brne	.-8      	; 0x556c <xTaskGenericCreate+0x118>
    5574:	8e 0d       	add	r24, r14
    5576:	9f 1d       	adc	r25, r15
    5578:	80 51       	subi	r24, 0x10	; 16
    557a:	9e 4f       	sbci	r25, 0xFE	; 254
    557c:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
    5580:	08 94       	sec
    5582:	e1 1c       	adc	r14, r1
    5584:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5586:	f4 e0       	ldi	r31, 0x04	; 4
    5588:	ef 16       	cp	r14, r31
    558a:	f1 04       	cpc	r15, r1
    558c:	69 f7       	brne	.-38     	; 0x5568 <xTaskGenericCreate+0x114>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    558e:	66 e2       	ldi	r22, 0x26	; 38
    5590:	e6 2e       	mov	r14, r22
    5592:	62 e0       	ldi	r22, 0x02	; 2
    5594:	f6 2e       	mov	r15, r22
    5596:	c7 01       	movw	r24, r14
    5598:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    559c:	5f e2       	ldi	r21, 0x2F	; 47
    559e:	c5 2e       	mov	r12, r21
    55a0:	52 e0       	ldi	r21, 0x02	; 2
    55a2:	d5 2e       	mov	r13, r21
    55a4:	c6 01       	movw	r24, r12
    55a6:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    55aa:	84 e1       	ldi	r24, 0x14	; 20
    55ac:	92 e0       	ldi	r25, 0x02	; 2
    55ae:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    55b2:	f0 92 20 02 	sts	0x0220, r15
    55b6:	e0 92 1f 02 	sts	0x021F, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    55ba:	d0 92 1e 02 	sts	0x021E, r13
    55be:	c0 92 1d 02 	sts	0x021D, r12
    55c2:	0f c0       	rjmp	.+30     	; 0x55e2 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    55c4:	80 91 23 02 	lds	r24, 0x0223
    55c8:	88 23       	and	r24, r24
    55ca:	59 f4       	brne	.+22     	; 0x55e2 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    55cc:	e0 91 e8 01 	lds	r30, 0x01E8
    55d0:	f0 91 e9 01 	lds	r31, 0x01E9
    55d4:	86 89       	ldd	r24, Z+22	; 0x16
    55d6:	08 17       	cp	r16, r24
    55d8:	20 f0       	brcs	.+8      	; 0x55e2 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    55da:	d0 93 e9 01 	sts	0x01E9, r29
    55de:	c0 93 e8 01 	sts	0x01E8, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    55e2:	2e 89       	ldd	r18, Y+22	; 0x16
    55e4:	80 91 24 02 	lds	r24, 0x0224
    55e8:	82 17       	cp	r24, r18
    55ea:	10 f4       	brcc	.+4      	; 0x55f0 <xTaskGenericCreate+0x19c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    55ec:	20 93 24 02 	sts	0x0224, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    55f0:	80 91 25 02 	lds	r24, 0x0225
    55f4:	8f 5f       	subi	r24, 0xFF	; 255
    55f6:	80 93 25 02 	sts	0x0225, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    55fa:	80 91 ef 01 	lds	r24, 0x01EF
    55fe:	82 17       	cp	r24, r18
    5600:	10 f4       	brcc	.+4      	; 0x5606 <xTaskGenericCreate+0x1b2>
    5602:	20 93 ef 01 	sts	0x01EF, r18
    5606:	30 e0       	ldi	r19, 0x00	; 0
    5608:	c9 01       	movw	r24, r18
    560a:	43 e0       	ldi	r20, 0x03	; 3
    560c:	88 0f       	add	r24, r24
    560e:	99 1f       	adc	r25, r25
    5610:	4a 95       	dec	r20
    5612:	e1 f7       	brne	.-8      	; 0x560c <xTaskGenericCreate+0x1b8>
    5614:	82 0f       	add	r24, r18
    5616:	93 1f       	adc	r25, r19
    5618:	80 51       	subi	r24, 0x10	; 16
    561a:	9e 4f       	sbci	r25, 0xFE	; 254
    561c:	b5 01       	movw	r22, r10
    561e:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    5622:	0f 90       	pop	r0
    5624:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    5626:	80 91 23 02 	lds	r24, 0x0223
    562a:	88 23       	and	r24, r24
    562c:	61 f0       	breq	.+24     	; 0x5646 <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    562e:	e0 91 e8 01 	lds	r30, 0x01E8
    5632:	f0 91 e9 01 	lds	r31, 0x01E9
    5636:	86 89       	ldd	r24, Z+22	; 0x16
    5638:	80 17       	cp	r24, r16
    563a:	28 f4       	brcc	.+10     	; 0x5646 <xTaskGenericCreate+0x1f2>
			{
				portYIELD_WITHIN_API();
    563c:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
    5640:	02 c0       	rjmp	.+4      	; 0x5646 <xTaskGenericCreate+0x1f2>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5642:	8f ef       	ldi	r24, 0xFF	; 255
    5644:	01 c0       	rjmp	.+2      	; 0x5648 <xTaskGenericCreate+0x1f4>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    5646:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    5648:	df 91       	pop	r29
    564a:	cf 91       	pop	r28
    564c:	1f 91       	pop	r17
    564e:	0f 91       	pop	r16
    5650:	ff 90       	pop	r15
    5652:	ef 90       	pop	r14
    5654:	df 90       	pop	r13
    5656:	cf 90       	pop	r12
    5658:	bf 90       	pop	r11
    565a:	af 90       	pop	r10
    565c:	9f 90       	pop	r9
    565e:	8f 90       	pop	r8
    5660:	7f 90       	pop	r7
    5662:	6f 90       	pop	r6
    5664:	5f 90       	pop	r5
    5666:	4f 90       	pop	r4
    5668:	3f 90       	pop	r3
    566a:	2f 90       	pop	r2
    566c:	08 95       	ret

0000566e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    566e:	af 92       	push	r10
    5670:	bf 92       	push	r11
    5672:	cf 92       	push	r12
    5674:	df 92       	push	r13
    5676:	ef 92       	push	r14
    5678:	ff 92       	push	r15
    567a:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    567c:	83 e2       	ldi	r24, 0x23	; 35
    567e:	9a e2       	ldi	r25, 0x2A	; 42
    5680:	66 e9       	ldi	r22, 0x96	; 150
    5682:	71 e0       	ldi	r23, 0x01	; 1
    5684:	45 e5       	ldi	r20, 0x55	; 85
    5686:	50 e0       	ldi	r21, 0x00	; 0
    5688:	20 e0       	ldi	r18, 0x00	; 0
    568a:	30 e0       	ldi	r19, 0x00	; 0
    568c:	00 e0       	ldi	r16, 0x00	; 0
    568e:	ee 24       	eor	r14, r14
    5690:	ff 24       	eor	r15, r15
    5692:	cc 24       	eor	r12, r12
    5694:	dd 24       	eor	r13, r13
    5696:	aa 24       	eor	r10, r10
    5698:	bb 24       	eor	r11, r11
    569a:	0e 94 2a 2a 	call	0x5454	; 0x5454 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    569e:	81 30       	cpi	r24, 0x01	; 1
    56a0:	49 f4       	brne	.+18     	; 0x56b4 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    56a2:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    56a4:	80 93 23 02 	sts	0x0223, r24
		xTickCount = ( portTickType ) 0U;
    56a8:	10 92 ed 01 	sts	0x01ED, r1
    56ac:	10 92 ec 01 	sts	0x01EC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    56b0:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    56b4:	0f 91       	pop	r16
    56b6:	ff 90       	pop	r15
    56b8:	ef 90       	pop	r14
    56ba:	df 90       	pop	r13
    56bc:	cf 90       	pop	r12
    56be:	bf 90       	pop	r11
    56c0:	af 90       	pop	r10
    56c2:	08 95       	ret

000056c4 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    56c4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    56c6:	10 92 23 02 	sts	0x0223, r1
	vPortEndScheduler();
    56ca:	0e 94 81 2e 	call	0x5d02	; 0x5d02 <vPortEndScheduler>
}
    56ce:	08 95       	ret

000056d0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    56d0:	80 91 ee 01 	lds	r24, 0x01EE
    56d4:	8f 5f       	subi	r24, 0xFF	; 255
    56d6:	80 93 ee 01 	sts	0x01EE, r24
}
    56da:	08 95       	ret

000056dc <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    56dc:	0f b6       	in	r0, 0x3f	; 63
    56de:	f8 94       	cli
    56e0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    56e2:	20 91 ec 01 	lds	r18, 0x01EC
    56e6:	30 91 ed 01 	lds	r19, 0x01ED
	}
	taskEXIT_CRITICAL();
    56ea:	0f 90       	pop	r0
    56ec:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    56ee:	c9 01       	movw	r24, r18
    56f0:	08 95       	ret

000056f2 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    56f2:	20 91 ec 01 	lds	r18, 0x01EC
    56f6:	30 91 ed 01 	lds	r19, 0x01ED
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    56fa:	c9 01       	movw	r24, r18
    56fc:	08 95       	ret

000056fe <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    56fe:	80 91 22 02 	lds	r24, 0x0222
}
    5702:	08 95       	ret

00005704 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    5704:	0f 93       	push	r16
    5706:	1f 93       	push	r17
    5708:	cf 93       	push	r28
    570a:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    570c:	80 91 ee 01 	lds	r24, 0x01EE
    5710:	88 23       	and	r24, r24
    5712:	09 f0       	breq	.+2      	; 0x5716 <vTaskIncrementTick+0x12>
    5714:	8f c0       	rjmp	.+286    	; 0x5834 <vTaskIncrementTick+0x130>
	{
		++xTickCount;
    5716:	80 91 ec 01 	lds	r24, 0x01EC
    571a:	90 91 ed 01 	lds	r25, 0x01ED
    571e:	01 96       	adiw	r24, 0x01	; 1
    5720:	90 93 ed 01 	sts	0x01ED, r25
    5724:	80 93 ec 01 	sts	0x01EC, r24
		if( xTickCount == ( portTickType ) 0U )
    5728:	80 91 ec 01 	lds	r24, 0x01EC
    572c:	90 91 ed 01 	lds	r25, 0x01ED
    5730:	00 97       	sbiw	r24, 0x00	; 0
    5732:	79 f5       	brne	.+94     	; 0x5792 <vTaskIncrementTick+0x8e>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    5734:	80 91 1f 02 	lds	r24, 0x021F
    5738:	90 91 20 02 	lds	r25, 0x0220
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    573c:	20 91 1d 02 	lds	r18, 0x021D
    5740:	30 91 1e 02 	lds	r19, 0x021E
    5744:	30 93 20 02 	sts	0x0220, r19
    5748:	20 93 1f 02 	sts	0x021F, r18
			pxOverflowDelayedTaskList = pxTemp;
    574c:	90 93 1e 02 	sts	0x021E, r25
    5750:	80 93 1d 02 	sts	0x021D, r24
			xNumOfOverflows++;
    5754:	80 91 eb 01 	lds	r24, 0x01EB
    5758:	8f 5f       	subi	r24, 0xFF	; 255
    575a:	80 93 eb 01 	sts	0x01EB, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    575e:	e0 91 1f 02 	lds	r30, 0x021F
    5762:	f0 91 20 02 	lds	r31, 0x0220
    5766:	80 81       	ld	r24, Z
    5768:	88 23       	and	r24, r24
    576a:	19 f4       	brne	.+6      	; 0x5772 <vTaskIncrementTick+0x6e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    576c:	8f ef       	ldi	r24, 0xFF	; 255
    576e:	9f ef       	ldi	r25, 0xFF	; 255
    5770:	0c c0       	rjmp	.+24     	; 0x578a <vTaskIncrementTick+0x86>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5772:	e0 91 1f 02 	lds	r30, 0x021F
    5776:	f0 91 20 02 	lds	r31, 0x0220
    577a:	05 80       	ldd	r0, Z+5	; 0x05
    577c:	f6 81       	ldd	r31, Z+6	; 0x06
    577e:	e0 2d       	mov	r30, r0
    5780:	06 80       	ldd	r0, Z+6	; 0x06
    5782:	f7 81       	ldd	r31, Z+7	; 0x07
    5784:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5786:	82 81       	ldd	r24, Z+2	; 0x02
    5788:	93 81       	ldd	r25, Z+3	; 0x03
    578a:	90 93 9c 01 	sts	0x019C, r25
    578e:	80 93 9b 01 	sts	0x019B, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5792:	20 91 ec 01 	lds	r18, 0x01EC
    5796:	30 91 ed 01 	lds	r19, 0x01ED
    579a:	80 91 9b 01 	lds	r24, 0x019B
    579e:	90 91 9c 01 	lds	r25, 0x019C
    57a2:	28 17       	cp	r18, r24
    57a4:	39 07       	cpc	r19, r25
    57a6:	08 f4       	brcc	.+2      	; 0x57aa <vTaskIncrementTick+0xa6>
    57a8:	4a c0       	rjmp	.+148    	; 0x583e <vTaskIncrementTick+0x13a>
    57aa:	e0 91 1f 02 	lds	r30, 0x021F
    57ae:	f0 91 20 02 	lds	r31, 0x0220
    57b2:	80 81       	ld	r24, Z
    57b4:	88 23       	and	r24, r24
    57b6:	19 f4       	brne	.+6      	; 0x57be <vTaskIncrementTick+0xba>
    57b8:	8f ef       	ldi	r24, 0xFF	; 255
    57ba:	9f ef       	ldi	r25, 0xFF	; 255
    57bc:	12 c0       	rjmp	.+36     	; 0x57e2 <vTaskIncrementTick+0xde>
    57be:	e0 91 1f 02 	lds	r30, 0x021F
    57c2:	f0 91 20 02 	lds	r31, 0x0220
    57c6:	05 80       	ldd	r0, Z+5	; 0x05
    57c8:	f6 81       	ldd	r31, Z+6	; 0x06
    57ca:	e0 2d       	mov	r30, r0
    57cc:	c6 81       	ldd	r28, Z+6	; 0x06
    57ce:	d7 81       	ldd	r29, Z+7	; 0x07
    57d0:	8a 81       	ldd	r24, Y+2	; 0x02
    57d2:	9b 81       	ldd	r25, Y+3	; 0x03
    57d4:	20 91 ec 01 	lds	r18, 0x01EC
    57d8:	30 91 ed 01 	lds	r19, 0x01ED
    57dc:	28 17       	cp	r18, r24
    57de:	39 07       	cpc	r19, r25
    57e0:	28 f4       	brcc	.+10     	; 0x57ec <vTaskIncrementTick+0xe8>
    57e2:	90 93 9c 01 	sts	0x019C, r25
    57e6:	80 93 9b 01 	sts	0x019B, r24
    57ea:	29 c0       	rjmp	.+82     	; 0x583e <vTaskIncrementTick+0x13a>
    57ec:	8e 01       	movw	r16, r28
    57ee:	0e 5f       	subi	r16, 0xFE	; 254
    57f0:	1f 4f       	sbci	r17, 0xFF	; 255
    57f2:	c8 01       	movw	r24, r16
    57f4:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
    57f8:	8c 89       	ldd	r24, Y+20	; 0x14
    57fa:	9d 89       	ldd	r25, Y+21	; 0x15
    57fc:	00 97       	sbiw	r24, 0x00	; 0
    57fe:	21 f0       	breq	.+8      	; 0x5808 <vTaskIncrementTick+0x104>
    5800:	ce 01       	movw	r24, r28
    5802:	0c 96       	adiw	r24, 0x0c	; 12
    5804:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
    5808:	2e 89       	ldd	r18, Y+22	; 0x16
    580a:	80 91 ef 01 	lds	r24, 0x01EF
    580e:	82 17       	cp	r24, r18
    5810:	10 f4       	brcc	.+4      	; 0x5816 <vTaskIncrementTick+0x112>
    5812:	20 93 ef 01 	sts	0x01EF, r18
    5816:	30 e0       	ldi	r19, 0x00	; 0
    5818:	c9 01       	movw	r24, r18
    581a:	f3 e0       	ldi	r31, 0x03	; 3
    581c:	88 0f       	add	r24, r24
    581e:	99 1f       	adc	r25, r25
    5820:	fa 95       	dec	r31
    5822:	e1 f7       	brne	.-8      	; 0x581c <vTaskIncrementTick+0x118>
    5824:	82 0f       	add	r24, r18
    5826:	93 1f       	adc	r25, r19
    5828:	80 51       	subi	r24, 0x10	; 16
    582a:	9e 4f       	sbci	r25, 0xFE	; 254
    582c:	b8 01       	movw	r22, r16
    582e:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>
    5832:	bb cf       	rjmp	.-138    	; 0x57aa <vTaskIncrementTick+0xa6>
	}
	else
	{
		++uxMissedTicks;
    5834:	80 91 21 02 	lds	r24, 0x0221
    5838:	8f 5f       	subi	r24, 0xFF	; 255
    583a:	80 93 21 02 	sts	0x0221, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    583e:	df 91       	pop	r29
    5840:	cf 91       	pop	r28
    5842:	1f 91       	pop	r17
    5844:	0f 91       	pop	r16
    5846:	08 95       	ret

00005848 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    5848:	ef 92       	push	r14
    584a:	ff 92       	push	r15
    584c:	0f 93       	push	r16
    584e:	1f 93       	push	r17
    5850:	df 93       	push	r29
    5852:	cf 93       	push	r28
    5854:	0f 92       	push	r0
    5856:	cd b7       	in	r28, 0x3d	; 61
    5858:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    585a:	0f b6       	in	r0, 0x3f	; 63
    585c:	f8 94       	cli
    585e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5860:	80 91 ee 01 	lds	r24, 0x01EE
    5864:	81 50       	subi	r24, 0x01	; 1
    5866:	80 93 ee 01 	sts	0x01EE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    586a:	80 91 ee 01 	lds	r24, 0x01EE
    586e:	88 23       	and	r24, r24
    5870:	09 f0       	breq	.+2      	; 0x5874 <xTaskResumeAll+0x2c>
    5872:	5e c0       	rjmp	.+188    	; 0x5930 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    5874:	80 91 22 02 	lds	r24, 0x0222
    5878:	88 23       	and	r24, r24
    587a:	09 f4       	brne	.+2      	; 0x587e <xTaskResumeAll+0x36>
    587c:	59 c0       	rjmp	.+178    	; 0x5930 <xTaskResumeAll+0xe8>
    587e:	19 82       	std	Y+1, r1	; 0x01
    5880:	35 c0       	rjmp	.+106    	; 0x58ec <xTaskResumeAll+0xa4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    5882:	e0 91 19 02 	lds	r30, 0x0219
    5886:	f0 91 1a 02 	lds	r31, 0x021A
    588a:	e6 80       	ldd	r14, Z+6	; 0x06
    588c:	f7 80       	ldd	r15, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    588e:	c7 01       	movw	r24, r14
    5890:	0c 96       	adiw	r24, 0x0c	; 12
    5892:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    5896:	87 01       	movw	r16, r14
    5898:	0e 5f       	subi	r16, 0xFE	; 254
    589a:	1f 4f       	sbci	r17, 0xFF	; 255
    589c:	c8 01       	movw	r24, r16
    589e:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    58a2:	d7 01       	movw	r26, r14
    58a4:	56 96       	adiw	r26, 0x16	; 22
    58a6:	2c 91       	ld	r18, X
    58a8:	56 97       	sbiw	r26, 0x16	; 22
    58aa:	80 91 ef 01 	lds	r24, 0x01EF
    58ae:	82 17       	cp	r24, r18
    58b0:	10 f4       	brcc	.+4      	; 0x58b6 <xTaskResumeAll+0x6e>
    58b2:	20 93 ef 01 	sts	0x01EF, r18
    58b6:	30 e0       	ldi	r19, 0x00	; 0
    58b8:	c9 01       	movw	r24, r18
    58ba:	a3 e0       	ldi	r26, 0x03	; 3
    58bc:	88 0f       	add	r24, r24
    58be:	99 1f       	adc	r25, r25
    58c0:	aa 95       	dec	r26
    58c2:	e1 f7       	brne	.-8      	; 0x58bc <xTaskResumeAll+0x74>
    58c4:	82 0f       	add	r24, r18
    58c6:	93 1f       	adc	r25, r19
    58c8:	80 51       	subi	r24, 0x10	; 16
    58ca:	9e 4f       	sbci	r25, 0xFE	; 254
    58cc:	b8 01       	movw	r22, r16
    58ce:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    58d2:	e0 91 e8 01 	lds	r30, 0x01E8
    58d6:	f0 91 e9 01 	lds	r31, 0x01E9
    58da:	d7 01       	movw	r26, r14
    58dc:	56 96       	adiw	r26, 0x16	; 22
    58de:	9c 91       	ld	r25, X
    58e0:	56 97       	sbiw	r26, 0x16	; 22
    58e2:	86 89       	ldd	r24, Z+22	; 0x16
    58e4:	98 17       	cp	r25, r24
    58e6:	10 f0       	brcs	.+4      	; 0x58ec <xTaskResumeAll+0xa4>
					{
						xYieldRequired = pdTRUE;
    58e8:	b1 e0       	ldi	r27, 0x01	; 1
    58ea:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    58ec:	80 91 14 02 	lds	r24, 0x0214
    58f0:	88 23       	and	r24, r24
    58f2:	39 f6       	brne	.-114    	; 0x5882 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    58f4:	80 91 21 02 	lds	r24, 0x0221
    58f8:	88 23       	and	r24, r24
    58fa:	41 f4       	brne	.+16     	; 0x590c <xTaskResumeAll+0xc4>
    58fc:	0c c0       	rjmp	.+24     	; 0x5916 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    58fe:	0e 94 82 2b 	call	0x5704	; 0x5704 <vTaskIncrementTick>
						--uxMissedTicks;
    5902:	80 91 21 02 	lds	r24, 0x0221
    5906:	81 50       	subi	r24, 0x01	; 1
    5908:	80 93 21 02 	sts	0x0221, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    590c:	80 91 21 02 	lds	r24, 0x0221
    5910:	88 23       	and	r24, r24
    5912:	a9 f7       	brne	.-22     	; 0x58fe <xTaskResumeAll+0xb6>
    5914:	07 c0       	rjmp	.+14     	; 0x5924 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    5916:	e9 81       	ldd	r30, Y+1	; 0x01
    5918:	e1 30       	cpi	r30, 0x01	; 1
    591a:	21 f0       	breq	.+8      	; 0x5924 <xTaskResumeAll+0xdc>
    591c:	80 91 ea 01 	lds	r24, 0x01EA
    5920:	81 30       	cpi	r24, 0x01	; 1
    5922:	31 f4       	brne	.+12     	; 0x5930 <xTaskResumeAll+0xe8>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    5924:	10 92 ea 01 	sts	0x01EA, r1
					portYIELD_WITHIN_API();
    5928:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    592c:	81 e0       	ldi	r24, 0x01	; 1
    592e:	01 c0       	rjmp	.+2      	; 0x5932 <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5930:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5932:	0f 90       	pop	r0
    5934:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    5936:	0f 90       	pop	r0
    5938:	cf 91       	pop	r28
    593a:	df 91       	pop	r29
    593c:	1f 91       	pop	r17
    593e:	0f 91       	pop	r16
    5940:	ff 90       	pop	r15
    5942:	ef 90       	pop	r14
    5944:	08 95       	ret

00005946 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    5946:	0f 93       	push	r16
    5948:	1f 93       	push	r17
    594a:	cf 93       	push	r28
    594c:	df 93       	push	r29
    594e:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    5950:	00 97       	sbiw	r24, 0x00	; 0
    5952:	b1 f0       	breq	.+44     	; 0x5980 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    5954:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5958:	00 91 ec 01 	lds	r16, 0x01EC
    595c:	10 91 ed 01 	lds	r17, 0x01ED

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5960:	80 91 e8 01 	lds	r24, 0x01E8
    5964:	90 91 e9 01 	lds	r25, 0x01E9
    5968:	02 96       	adiw	r24, 0x02	; 2
    596a:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    596e:	ce 01       	movw	r24, r28
    5970:	80 0f       	add	r24, r16
    5972:	91 1f       	adc	r25, r17
    5974:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5978:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    597c:	88 23       	and	r24, r24
    597e:	11 f4       	brne	.+4      	; 0x5984 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    5980:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
		}
	}
    5984:	df 91       	pop	r29
    5986:	cf 91       	pop	r28
    5988:	1f 91       	pop	r17
    598a:	0f 91       	pop	r16
    598c:	08 95       	ret

0000598e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    598e:	0f 93       	push	r16
    5990:	1f 93       	push	r17
    5992:	cf 93       	push	r28
    5994:	df 93       	push	r29
    5996:	8c 01       	movw	r16, r24
    5998:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    599a:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    599e:	f8 01       	movw	r30, r16
    59a0:	80 81       	ld	r24, Z
    59a2:	91 81       	ldd	r25, Z+1	; 0x01
    59a4:	c8 0f       	add	r28, r24
    59a6:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    59a8:	20 91 ec 01 	lds	r18, 0x01EC
    59ac:	30 91 ed 01 	lds	r19, 0x01ED
    59b0:	28 17       	cp	r18, r24
    59b2:	39 07       	cpc	r19, r25
    59b4:	20 f4       	brcc	.+8      	; 0x59be <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    59b6:	c8 17       	cp	r28, r24
    59b8:	d9 07       	cpc	r29, r25
    59ba:	60 f4       	brcc	.+24     	; 0x59d4 <vTaskDelayUntil+0x46>
    59bc:	03 c0       	rjmp	.+6      	; 0x59c4 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    59be:	c8 17       	cp	r28, r24
    59c0:	d9 07       	cpc	r29, r25
    59c2:	50 f0       	brcs	.+20     	; 0x59d8 <vTaskDelayUntil+0x4a>
    59c4:	80 91 ec 01 	lds	r24, 0x01EC
    59c8:	90 91 ed 01 	lds	r25, 0x01ED
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    59cc:	21 e0       	ldi	r18, 0x01	; 1
    59ce:	8c 17       	cp	r24, r28
    59d0:	9d 07       	cpc	r25, r29
    59d2:	18 f0       	brcs	.+6      	; 0x59da <vTaskDelayUntil+0x4c>
    59d4:	20 e0       	ldi	r18, 0x00	; 0
    59d6:	01 c0       	rjmp	.+2      	; 0x59da <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    59d8:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    59da:	f8 01       	movw	r30, r16
    59dc:	d1 83       	std	Z+1, r29	; 0x01
    59de:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    59e0:	22 23       	and	r18, r18
    59e2:	51 f0       	breq	.+20     	; 0x59f8 <vTaskDelayUntil+0x6a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    59e4:	80 91 e8 01 	lds	r24, 0x01E8
    59e8:	90 91 e9 01 	lds	r25, 0x01E9
    59ec:	02 96       	adiw	r24, 0x02	; 2
    59ee:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    59f2:	ce 01       	movw	r24, r28
    59f4:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    59f8:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    59fc:	88 23       	and	r24, r24
    59fe:	11 f4       	brne	.+4      	; 0x5a04 <vTaskDelayUntil+0x76>
		{
			portYIELD_WITHIN_API();
    5a00:	0e 94 82 2e 	call	0x5d04	; 0x5d04 <vPortYield>
		}
	}
    5a04:	df 91       	pop	r29
    5a06:	cf 91       	pop	r28
    5a08:	1f 91       	pop	r17
    5a0a:	0f 91       	pop	r16
    5a0c:	08 95       	ret

00005a0e <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    5a0e:	80 91 ee 01 	lds	r24, 0x01EE
    5a12:	88 23       	and	r24, r24
    5a14:	49 f0       	breq	.+18     	; 0x5a28 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5a16:	81 e0       	ldi	r24, 0x01	; 1
    5a18:	80 93 ea 01 	sts	0x01EA, r24
    5a1c:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    5a1e:	80 91 ef 01 	lds	r24, 0x01EF
    5a22:	81 50       	subi	r24, 0x01	; 1
    5a24:	80 93 ef 01 	sts	0x01EF, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    5a28:	80 91 ef 01 	lds	r24, 0x01EF
    5a2c:	90 e0       	ldi	r25, 0x00	; 0
    5a2e:	fc 01       	movw	r30, r24
    5a30:	53 e0       	ldi	r21, 0x03	; 3
    5a32:	ee 0f       	add	r30, r30
    5a34:	ff 1f       	adc	r31, r31
    5a36:	5a 95       	dec	r21
    5a38:	e1 f7       	brne	.-8      	; 0x5a32 <vTaskSwitchContext+0x24>
    5a3a:	e8 0f       	add	r30, r24
    5a3c:	f9 1f       	adc	r31, r25
    5a3e:	e0 51       	subi	r30, 0x10	; 16
    5a40:	fe 4f       	sbci	r31, 0xFE	; 254
    5a42:	80 81       	ld	r24, Z
    5a44:	88 23       	and	r24, r24
    5a46:	59 f3       	breq	.-42     	; 0x5a1e <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5a48:	80 91 ef 01 	lds	r24, 0x01EF
    5a4c:	90 e0       	ldi	r25, 0x00	; 0
    5a4e:	9c 01       	movw	r18, r24
    5a50:	43 e0       	ldi	r20, 0x03	; 3
    5a52:	22 0f       	add	r18, r18
    5a54:	33 1f       	adc	r19, r19
    5a56:	4a 95       	dec	r20
    5a58:	e1 f7       	brne	.-8      	; 0x5a52 <vTaskSwitchContext+0x44>
    5a5a:	28 0f       	add	r18, r24
    5a5c:	39 1f       	adc	r19, r25
    5a5e:	f9 01       	movw	r30, r18
    5a60:	e0 51       	subi	r30, 0x10	; 16
    5a62:	fe 4f       	sbci	r31, 0xFE	; 254
    5a64:	a1 81       	ldd	r26, Z+1	; 0x01
    5a66:	b2 81       	ldd	r27, Z+2	; 0x02
    5a68:	12 96       	adiw	r26, 0x02	; 2
    5a6a:	0d 90       	ld	r0, X+
    5a6c:	bc 91       	ld	r27, X
    5a6e:	a0 2d       	mov	r26, r0
    5a70:	b2 83       	std	Z+2, r27	; 0x02
    5a72:	a1 83       	std	Z+1, r26	; 0x01
    5a74:	2d 50       	subi	r18, 0x0D	; 13
    5a76:	3e 4f       	sbci	r19, 0xFE	; 254
    5a78:	a2 17       	cp	r26, r18
    5a7a:	b3 07       	cpc	r27, r19
    5a7c:	31 f4       	brne	.+12     	; 0x5a8a <vTaskSwitchContext+0x7c>
    5a7e:	12 96       	adiw	r26, 0x02	; 2
    5a80:	2d 91       	ld	r18, X+
    5a82:	3c 91       	ld	r19, X
    5a84:	13 97       	sbiw	r26, 0x03	; 3
    5a86:	32 83       	std	Z+2, r19	; 0x02
    5a88:	21 83       	std	Z+1, r18	; 0x01
    5a8a:	fc 01       	movw	r30, r24
    5a8c:	b3 e0       	ldi	r27, 0x03	; 3
    5a8e:	ee 0f       	add	r30, r30
    5a90:	ff 1f       	adc	r31, r31
    5a92:	ba 95       	dec	r27
    5a94:	e1 f7       	brne	.-8      	; 0x5a8e <vTaskSwitchContext+0x80>
    5a96:	e8 0f       	add	r30, r24
    5a98:	f9 1f       	adc	r31, r25
    5a9a:	e0 51       	subi	r30, 0x10	; 16
    5a9c:	fe 4f       	sbci	r31, 0xFE	; 254
    5a9e:	01 80       	ldd	r0, Z+1	; 0x01
    5aa0:	f2 81       	ldd	r31, Z+2	; 0x02
    5aa2:	e0 2d       	mov	r30, r0
    5aa4:	86 81       	ldd	r24, Z+6	; 0x06
    5aa6:	97 81       	ldd	r25, Z+7	; 0x07
    5aa8:	90 93 e9 01 	sts	0x01E9, r25
    5aac:	80 93 e8 01 	sts	0x01E8, r24
    5ab0:	08 95       	ret

00005ab2 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5ab2:	cf 93       	push	r28
    5ab4:	df 93       	push	r29
    5ab6:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5ab8:	60 91 e8 01 	lds	r22, 0x01E8
    5abc:	70 91 e9 01 	lds	r23, 0x01E9
    5ac0:	64 5f       	subi	r22, 0xF4	; 244
    5ac2:	7f 4f       	sbci	r23, 0xFF	; 255
    5ac4:	0e 94 84 26 	call	0x4d08	; 0x4d08 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5ac8:	80 91 e8 01 	lds	r24, 0x01E8
    5acc:	90 91 e9 01 	lds	r25, 0x01E9
    5ad0:	02 96       	adiw	r24, 0x02	; 2
    5ad2:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    5ad6:	80 91 ec 01 	lds	r24, 0x01EC
    5ada:	90 91 ed 01 	lds	r25, 0x01ED
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5ade:	8c 0f       	add	r24, r28
    5ae0:	9d 1f       	adc	r25, r29
    5ae2:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    5ae6:	df 91       	pop	r29
    5ae8:	cf 91       	pop	r28
    5aea:	08 95       	ret

00005aec <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    5aec:	0f 93       	push	r16
    5aee:	1f 93       	push	r17
    5af0:	cf 93       	push	r28
    5af2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5af4:	dc 01       	movw	r26, r24
    5af6:	15 96       	adiw	r26, 0x05	; 5
    5af8:	ed 91       	ld	r30, X+
    5afa:	fc 91       	ld	r31, X
    5afc:	16 97       	sbiw	r26, 0x06	; 6
    5afe:	c6 81       	ldd	r28, Z+6	; 0x06
    5b00:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5b02:	8e 01       	movw	r16, r28
    5b04:	04 5f       	subi	r16, 0xF4	; 244
    5b06:	1f 4f       	sbci	r17, 0xFF	; 255
    5b08:	c8 01       	movw	r24, r16
    5b0a:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5b0e:	80 91 ee 01 	lds	r24, 0x01EE
    5b12:	88 23       	and	r24, r24
    5b14:	c9 f4       	brne	.+50     	; 0x5b48 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5b16:	8e 01       	movw	r16, r28
    5b18:	0e 5f       	subi	r16, 0xFE	; 254
    5b1a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b1c:	c8 01       	movw	r24, r16
    5b1e:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    5b22:	2e 89       	ldd	r18, Y+22	; 0x16
    5b24:	80 91 ef 01 	lds	r24, 0x01EF
    5b28:	82 17       	cp	r24, r18
    5b2a:	10 f4       	brcc	.+4      	; 0x5b30 <xTaskRemoveFromEventList+0x44>
    5b2c:	20 93 ef 01 	sts	0x01EF, r18
    5b30:	30 e0       	ldi	r19, 0x00	; 0
    5b32:	c9 01       	movw	r24, r18
    5b34:	63 e0       	ldi	r22, 0x03	; 3
    5b36:	88 0f       	add	r24, r24
    5b38:	99 1f       	adc	r25, r25
    5b3a:	6a 95       	dec	r22
    5b3c:	e1 f7       	brne	.-8      	; 0x5b36 <xTaskRemoveFromEventList+0x4a>
    5b3e:	82 0f       	add	r24, r18
    5b40:	93 1f       	adc	r25, r19
    5b42:	80 51       	subi	r24, 0x10	; 16
    5b44:	9e 4f       	sbci	r25, 0xFE	; 254
    5b46:	02 c0       	rjmp	.+4      	; 0x5b4c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5b48:	84 e1       	ldi	r24, 0x14	; 20
    5b4a:	92 e0       	ldi	r25, 0x02	; 2
    5b4c:	b8 01       	movw	r22, r16
    5b4e:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5b52:	e0 91 e8 01 	lds	r30, 0x01E8
    5b56:	f0 91 e9 01 	lds	r31, 0x01E9
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    5b5a:	81 e0       	ldi	r24, 0x01	; 1
    5b5c:	2e 89       	ldd	r18, Y+22	; 0x16
    5b5e:	96 89       	ldd	r25, Z+22	; 0x16
    5b60:	29 17       	cp	r18, r25
    5b62:	08 f4       	brcc	.+2      	; 0x5b66 <xTaskRemoveFromEventList+0x7a>
    5b64:	80 e0       	ldi	r24, 0x00	; 0
}
    5b66:	df 91       	pop	r29
    5b68:	cf 91       	pop	r28
    5b6a:	1f 91       	pop	r17
    5b6c:	0f 91       	pop	r16
    5b6e:	08 95       	ret

00005b70 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5b70:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5b72:	80 91 eb 01 	lds	r24, 0x01EB
    5b76:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5b78:	80 91 ec 01 	lds	r24, 0x01EC
    5b7c:	90 91 ed 01 	lds	r25, 0x01ED
    5b80:	92 83       	std	Z+2, r25	; 0x02
    5b82:	81 83       	std	Z+1, r24	; 0x01
}
    5b84:	08 95       	ret

00005b86 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5b86:	fc 01       	movw	r30, r24
    5b88:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5b8a:	0f b6       	in	r0, 0x3f	; 63
    5b8c:	f8 94       	cli
    5b8e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    5b90:	90 91 eb 01 	lds	r25, 0x01EB
    5b94:	80 81       	ld	r24, Z
    5b96:	98 17       	cp	r25, r24
    5b98:	49 f0       	breq	.+18     	; 0x5bac <xTaskCheckForTimeOut+0x26>
    5b9a:	20 91 ec 01 	lds	r18, 0x01EC
    5b9e:	30 91 ed 01 	lds	r19, 0x01ED
    5ba2:	81 81       	ldd	r24, Z+1	; 0x01
    5ba4:	92 81       	ldd	r25, Z+2	; 0x02
    5ba6:	28 17       	cp	r18, r24
    5ba8:	39 07       	cpc	r19, r25
    5baa:	20 f5       	brcc	.+72     	; 0x5bf4 <xTaskCheckForTimeOut+0x6e>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5bac:	20 91 ec 01 	lds	r18, 0x01EC
    5bb0:	30 91 ed 01 	lds	r19, 0x01ED
    5bb4:	81 81       	ldd	r24, Z+1	; 0x01
    5bb6:	92 81       	ldd	r25, Z+2	; 0x02
    5bb8:	4d 91       	ld	r20, X+
    5bba:	5c 91       	ld	r21, X
    5bbc:	11 97       	sbiw	r26, 0x01	; 1
    5bbe:	28 1b       	sub	r18, r24
    5bc0:	39 0b       	sbc	r19, r25
    5bc2:	24 17       	cp	r18, r20
    5bc4:	35 07       	cpc	r19, r21
    5bc6:	b0 f4       	brcc	.+44     	; 0x5bf4 <xTaskCheckForTimeOut+0x6e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5bc8:	20 91 ec 01 	lds	r18, 0x01EC
    5bcc:	30 91 ed 01 	lds	r19, 0x01ED
    5bd0:	82 1b       	sub	r24, r18
    5bd2:	93 0b       	sbc	r25, r19
    5bd4:	84 0f       	add	r24, r20
    5bd6:	95 1f       	adc	r25, r21
    5bd8:	11 96       	adiw	r26, 0x01	; 1
    5bda:	9c 93       	st	X, r25
    5bdc:	8e 93       	st	-X, r24
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5bde:	80 91 eb 01 	lds	r24, 0x01EB
    5be2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5be4:	80 91 ec 01 	lds	r24, 0x01EC
    5be8:	90 91 ed 01 	lds	r25, 0x01ED
    5bec:	92 83       	std	Z+2, r25	; 0x02
    5bee:	81 83       	std	Z+1, r24	; 0x01
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    5bf0:	80 e0       	ldi	r24, 0x00	; 0
    5bf2:	01 c0       	rjmp	.+2      	; 0x5bf6 <xTaskCheckForTimeOut+0x70>
		}
		else
		{
			xReturn = pdTRUE;
    5bf4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    5bf6:	0f 90       	pop	r0
    5bf8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    5bfa:	08 95       	ret

00005bfc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    5bfc:	81 e0       	ldi	r24, 0x01	; 1
    5bfe:	80 93 ea 01 	sts	0x01EA, r24
}
    5c02:	08 95       	ret

00005c04 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    5c04:	21 e1       	ldi	r18, 0x11	; 17
    5c06:	fc 01       	movw	r30, r24
    5c08:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    5c0a:	92 e2       	ldi	r25, 0x22	; 34
    5c0c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    5c0e:	83 e3       	ldi	r24, 0x33	; 51
    5c10:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c12:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c14:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    5c16:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    5c18:	80 e8       	ldi	r24, 0x80	; 128
    5c1a:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    5c1c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    5c1e:	82 e0       	ldi	r24, 0x02	; 2
    5c20:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    5c22:	83 e0       	ldi	r24, 0x03	; 3
    5c24:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    5c26:	84 e0       	ldi	r24, 0x04	; 4
    5c28:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    5c2a:	85 e0       	ldi	r24, 0x05	; 5
    5c2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    5c2e:	86 e0       	ldi	r24, 0x06	; 6
    5c30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    5c32:	87 e0       	ldi	r24, 0x07	; 7
    5c34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    5c36:	88 e0       	ldi	r24, 0x08	; 8
    5c38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    5c3a:	89 e0       	ldi	r24, 0x09	; 9
    5c3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    5c3e:	80 e1       	ldi	r24, 0x10	; 16
    5c40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    5c42:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    5c44:	82 e1       	ldi	r24, 0x12	; 18
    5c46:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    5c48:	83 e1       	ldi	r24, 0x13	; 19
    5c4a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    5c4c:	84 e1       	ldi	r24, 0x14	; 20
    5c4e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    5c50:	85 e1       	ldi	r24, 0x15	; 21
    5c52:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5c54:	86 e1       	ldi	r24, 0x16	; 22
    5c56:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    5c58:	87 e1       	ldi	r24, 0x17	; 23
    5c5a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5c5c:	88 e1       	ldi	r24, 0x18	; 24
    5c5e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    5c60:	89 e1       	ldi	r24, 0x19	; 25
    5c62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    5c64:	80 e2       	ldi	r24, 0x20	; 32
    5c66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    5c68:	81 e2       	ldi	r24, 0x21	; 33
    5c6a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    5c6c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    5c6e:	83 e2       	ldi	r24, 0x23	; 35
    5c70:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c72:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5c74:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    5c76:	86 e2       	ldi	r24, 0x26	; 38
    5c78:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    5c7a:	87 e2       	ldi	r24, 0x27	; 39
    5c7c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    5c7e:	88 e2       	ldi	r24, 0x28	; 40
    5c80:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5c82:	89 e2       	ldi	r24, 0x29	; 41
    5c84:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5c86:	80 e3       	ldi	r24, 0x30	; 48
    5c88:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5c8a:	81 e3       	ldi	r24, 0x31	; 49
    5c8c:	82 93       	st	-Z, r24
	pxTopOfStack--;
    5c8e:	9f 01       	movw	r18, r30
    5c90:	21 50       	subi	r18, 0x01	; 1
    5c92:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    5c94:	c9 01       	movw	r24, r18
    5c96:	08 95       	ret

00005c98 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    5c98:	89 e0       	ldi	r24, 0x09	; 9
    5c9a:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    5c9c:	9f e5       	ldi	r25, 0x5F	; 95
    5c9e:	9a bd       	out	0x2a, r25	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    5ca0:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5ca2:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5ca4:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    5ca6:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5ca8:	a0 91 e8 01 	lds	r26, 0x01E8
    5cac:	b0 91 e9 01 	lds	r27, 0x01E9
    5cb0:	cd 91       	ld	r28, X+
    5cb2:	cd bf       	out	0x3d, r28	; 61
    5cb4:	dd 91       	ld	r29, X+
    5cb6:	de bf       	out	0x3e, r29	; 62
    5cb8:	ff 91       	pop	r31
    5cba:	ef 91       	pop	r30
    5cbc:	df 91       	pop	r29
    5cbe:	cf 91       	pop	r28
    5cc0:	bf 91       	pop	r27
    5cc2:	af 91       	pop	r26
    5cc4:	9f 91       	pop	r25
    5cc6:	8f 91       	pop	r24
    5cc8:	7f 91       	pop	r23
    5cca:	6f 91       	pop	r22
    5ccc:	5f 91       	pop	r21
    5cce:	4f 91       	pop	r20
    5cd0:	3f 91       	pop	r19
    5cd2:	2f 91       	pop	r18
    5cd4:	1f 91       	pop	r17
    5cd6:	0f 91       	pop	r16
    5cd8:	ff 90       	pop	r15
    5cda:	ef 90       	pop	r14
    5cdc:	df 90       	pop	r13
    5cde:	cf 90       	pop	r12
    5ce0:	bf 90       	pop	r11
    5ce2:	af 90       	pop	r10
    5ce4:	9f 90       	pop	r9
    5ce6:	8f 90       	pop	r8
    5ce8:	7f 90       	pop	r7
    5cea:	6f 90       	pop	r6
    5cec:	5f 90       	pop	r5
    5cee:	4f 90       	pop	r4
    5cf0:	3f 90       	pop	r3
    5cf2:	2f 90       	pop	r2
    5cf4:	1f 90       	pop	r1
    5cf6:	0f 90       	pop	r0
    5cf8:	0f be       	out	0x3f, r0	; 63
    5cfa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5cfc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    5cfe:	81 e0       	ldi	r24, 0x01	; 1
    5d00:	08 95       	ret

00005d02 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5d02:	08 95       	ret

00005d04 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5d04:	0f 92       	push	r0
    5d06:	0f b6       	in	r0, 0x3f	; 63
    5d08:	f8 94       	cli
    5d0a:	0f 92       	push	r0
    5d0c:	1f 92       	push	r1
    5d0e:	11 24       	eor	r1, r1
    5d10:	2f 92       	push	r2
    5d12:	3f 92       	push	r3
    5d14:	4f 92       	push	r4
    5d16:	5f 92       	push	r5
    5d18:	6f 92       	push	r6
    5d1a:	7f 92       	push	r7
    5d1c:	8f 92       	push	r8
    5d1e:	9f 92       	push	r9
    5d20:	af 92       	push	r10
    5d22:	bf 92       	push	r11
    5d24:	cf 92       	push	r12
    5d26:	df 92       	push	r13
    5d28:	ef 92       	push	r14
    5d2a:	ff 92       	push	r15
    5d2c:	0f 93       	push	r16
    5d2e:	1f 93       	push	r17
    5d30:	2f 93       	push	r18
    5d32:	3f 93       	push	r19
    5d34:	4f 93       	push	r20
    5d36:	5f 93       	push	r21
    5d38:	6f 93       	push	r22
    5d3a:	7f 93       	push	r23
    5d3c:	8f 93       	push	r24
    5d3e:	9f 93       	push	r25
    5d40:	af 93       	push	r26
    5d42:	bf 93       	push	r27
    5d44:	cf 93       	push	r28
    5d46:	df 93       	push	r29
    5d48:	ef 93       	push	r30
    5d4a:	ff 93       	push	r31
    5d4c:	a0 91 e8 01 	lds	r26, 0x01E8
    5d50:	b0 91 e9 01 	lds	r27, 0x01E9
    5d54:	0d b6       	in	r0, 0x3d	; 61
    5d56:	0d 92       	st	X+, r0
    5d58:	0e b6       	in	r0, 0x3e	; 62
    5d5a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5d5c:	0e 94 07 2d 	call	0x5a0e	; 0x5a0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5d60:	a0 91 e8 01 	lds	r26, 0x01E8
    5d64:	b0 91 e9 01 	lds	r27, 0x01E9
    5d68:	cd 91       	ld	r28, X+
    5d6a:	cd bf       	out	0x3d, r28	; 61
    5d6c:	dd 91       	ld	r29, X+
    5d6e:	de bf       	out	0x3e, r29	; 62
    5d70:	ff 91       	pop	r31
    5d72:	ef 91       	pop	r30
    5d74:	df 91       	pop	r29
    5d76:	cf 91       	pop	r28
    5d78:	bf 91       	pop	r27
    5d7a:	af 91       	pop	r26
    5d7c:	9f 91       	pop	r25
    5d7e:	8f 91       	pop	r24
    5d80:	7f 91       	pop	r23
    5d82:	6f 91       	pop	r22
    5d84:	5f 91       	pop	r21
    5d86:	4f 91       	pop	r20
    5d88:	3f 91       	pop	r19
    5d8a:	2f 91       	pop	r18
    5d8c:	1f 91       	pop	r17
    5d8e:	0f 91       	pop	r16
    5d90:	ff 90       	pop	r15
    5d92:	ef 90       	pop	r14
    5d94:	df 90       	pop	r13
    5d96:	cf 90       	pop	r12
    5d98:	bf 90       	pop	r11
    5d9a:	af 90       	pop	r10
    5d9c:	9f 90       	pop	r9
    5d9e:	8f 90       	pop	r8
    5da0:	7f 90       	pop	r7
    5da2:	6f 90       	pop	r6
    5da4:	5f 90       	pop	r5
    5da6:	4f 90       	pop	r4
    5da8:	3f 90       	pop	r3
    5daa:	2f 90       	pop	r2
    5dac:	1f 90       	pop	r1
    5dae:	0f 90       	pop	r0
    5db0:	0f be       	out	0x3f, r0	; 63
    5db2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5db4:	08 95       	ret

00005db6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    5db6:	0f 92       	push	r0
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	f8 94       	cli
    5dbc:	0f 92       	push	r0
    5dbe:	1f 92       	push	r1
    5dc0:	11 24       	eor	r1, r1
    5dc2:	2f 92       	push	r2
    5dc4:	3f 92       	push	r3
    5dc6:	4f 92       	push	r4
    5dc8:	5f 92       	push	r5
    5dca:	6f 92       	push	r6
    5dcc:	7f 92       	push	r7
    5dce:	8f 92       	push	r8
    5dd0:	9f 92       	push	r9
    5dd2:	af 92       	push	r10
    5dd4:	bf 92       	push	r11
    5dd6:	cf 92       	push	r12
    5dd8:	df 92       	push	r13
    5dda:	ef 92       	push	r14
    5ddc:	ff 92       	push	r15
    5dde:	0f 93       	push	r16
    5de0:	1f 93       	push	r17
    5de2:	2f 93       	push	r18
    5de4:	3f 93       	push	r19
    5de6:	4f 93       	push	r20
    5de8:	5f 93       	push	r21
    5dea:	6f 93       	push	r22
    5dec:	7f 93       	push	r23
    5dee:	8f 93       	push	r24
    5df0:	9f 93       	push	r25
    5df2:	af 93       	push	r26
    5df4:	bf 93       	push	r27
    5df6:	cf 93       	push	r28
    5df8:	df 93       	push	r29
    5dfa:	ef 93       	push	r30
    5dfc:	ff 93       	push	r31
    5dfe:	a0 91 e8 01 	lds	r26, 0x01E8
    5e02:	b0 91 e9 01 	lds	r27, 0x01E9
    5e06:	0d b6       	in	r0, 0x3d	; 61
    5e08:	0d 92       	st	X+, r0
    5e0a:	0e b6       	in	r0, 0x3e	; 62
    5e0c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    5e0e:	0e 94 82 2b 	call	0x5704	; 0x5704 <vTaskIncrementTick>
	vTaskSwitchContext();
    5e12:	0e 94 07 2d 	call	0x5a0e	; 0x5a0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5e16:	a0 91 e8 01 	lds	r26, 0x01E8
    5e1a:	b0 91 e9 01 	lds	r27, 0x01E9
    5e1e:	cd 91       	ld	r28, X+
    5e20:	cd bf       	out	0x3d, r28	; 61
    5e22:	dd 91       	ld	r29, X+
    5e24:	de bf       	out	0x3e, r29	; 62
    5e26:	ff 91       	pop	r31
    5e28:	ef 91       	pop	r30
    5e2a:	df 91       	pop	r29
    5e2c:	cf 91       	pop	r28
    5e2e:	bf 91       	pop	r27
    5e30:	af 91       	pop	r26
    5e32:	9f 91       	pop	r25
    5e34:	8f 91       	pop	r24
    5e36:	7f 91       	pop	r23
    5e38:	6f 91       	pop	r22
    5e3a:	5f 91       	pop	r21
    5e3c:	4f 91       	pop	r20
    5e3e:	3f 91       	pop	r19
    5e40:	2f 91       	pop	r18
    5e42:	1f 91       	pop	r17
    5e44:	0f 91       	pop	r16
    5e46:	ff 90       	pop	r15
    5e48:	ef 90       	pop	r14
    5e4a:	df 90       	pop	r13
    5e4c:	cf 90       	pop	r12
    5e4e:	bf 90       	pop	r11
    5e50:	af 90       	pop	r10
    5e52:	9f 90       	pop	r9
    5e54:	8f 90       	pop	r8
    5e56:	7f 90       	pop	r7
    5e58:	6f 90       	pop	r6
    5e5a:	5f 90       	pop	r5
    5e5c:	4f 90       	pop	r4
    5e5e:	3f 90       	pop	r3
    5e60:	2f 90       	pop	r2
    5e62:	1f 90       	pop	r1
    5e64:	0f 90       	pop	r0
    5e66:	0f be       	out	0x3f, r0	; 63
    5e68:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5e6a:	08 95       	ret

00005e6c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5e6c:	0e 94 db 2e 	call	0x5db6	; 0x5db6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    5e70:	18 95       	reti

00005e72 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5e72:	ef 92       	push	r14
    5e74:	ff 92       	push	r15
    5e76:	0f 93       	push	r16
    5e78:	1f 93       	push	r17
    5e7a:	cf 93       	push	r28
    5e7c:	df 93       	push	r29
    5e7e:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    5e80:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    5e84:	c0 91 38 02 	lds	r28, 0x0238
    5e88:	d0 91 39 02 	lds	r29, 0x0239
    5e8c:	0c 0f       	add	r16, r28
    5e8e:	1d 1f       	adc	r17, r29
    5e90:	25 e0       	ldi	r18, 0x05	; 5
    5e92:	0c 3d       	cpi	r16, 0xDC	; 220
    5e94:	12 07       	cpc	r17, r18
    5e96:	50 f4       	brcc	.+20     	; 0x5eac <pvPortMalloc+0x3a>
    5e98:	c0 17       	cp	r28, r16
    5e9a:	d1 07       	cpc	r29, r17
    5e9c:	38 f4       	brcc	.+14     	; 0x5eac <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    5e9e:	c6 5c       	subi	r28, 0xC6	; 198
    5ea0:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    5ea2:	10 93 39 02 	sts	0x0239, r17
    5ea6:	00 93 38 02 	sts	0x0238, r16
    5eaa:	02 c0       	rjmp	.+4      	; 0x5eb0 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    5eac:	c0 e0       	ldi	r28, 0x00	; 0
    5eae:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    5eb0:	0e 94 24 2c 	call	0x5848	; 0x5848 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    5eb4:	ce 01       	movw	r24, r28
    5eb6:	df 91       	pop	r29
    5eb8:	cf 91       	pop	r28
    5eba:	1f 91       	pop	r17
    5ebc:	0f 91       	pop	r16
    5ebe:	ff 90       	pop	r15
    5ec0:	ef 90       	pop	r14
    5ec2:	08 95       	ret

00005ec4 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    5ec4:	08 95       	ret

00005ec6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    5ec6:	10 92 39 02 	sts	0x0239, r1
    5eca:	10 92 38 02 	sts	0x0238, r1
}
    5ece:	08 95       	ret

00005ed0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    5ed0:	2c ed       	ldi	r18, 0xDC	; 220
    5ed2:	35 e0       	ldi	r19, 0x05	; 5
    5ed4:	80 91 38 02 	lds	r24, 0x0238
    5ed8:	90 91 39 02 	lds	r25, 0x0239
    5edc:	28 1b       	sub	r18, r24
    5ede:	39 0b       	sbc	r19, r25
}
    5ee0:	c9 01       	movw	r24, r18
    5ee2:	08 95       	ret

00005ee4 <i2c_transmit>:
#include <util/twi.h>

void i2c_transmit(char address, char reg, char data)
{
	TWCR = 0xA4;                                                  // send a start bit on i2c bus
    5ee4:	94 ea       	ldi	r25, 0xA4	; 164
    5ee6:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5ee8:	06 b6       	in	r0, 0x36	; 54
    5eea:	07 fe       	sbrs	r0, 7
    5eec:	fd cf       	rjmp	.-6      	; 0x5ee8 <i2c_transmit+0x4>
	TWDR = address;                                               // load address of i2c device
    5eee:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                  // transmit
    5ef0:	84 e8       	ldi	r24, 0x84	; 132
    5ef2:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5ef4:	06 b6       	in	r0, 0x36	; 54
    5ef6:	07 fe       	sbrs	r0, 7
    5ef8:	fd cf       	rjmp	.-6      	; 0x5ef4 <i2c_transmit+0x10>
	TWDR = reg;
    5efa:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                                                  // transmit
    5efc:	84 e8       	ldi	r24, 0x84	; 132
    5efe:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f00:	06 b6       	in	r0, 0x36	; 54
    5f02:	07 fe       	sbrs	r0, 7
    5f04:	fd cf       	rjmp	.-6      	; 0x5f00 <i2c_transmit+0x1c>
	TWDR = data;
    5f06:	43 b9       	out	0x03, r20	; 3
	TWCR = 0x84;                                                  // transmit
    5f08:	84 e8       	ldi	r24, 0x84	; 132
    5f0a:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f0c:	06 b6       	in	r0, 0x36	; 54
    5f0e:	07 fe       	sbrs	r0, 7
    5f10:	fd cf       	rjmp	.-6      	; 0x5f0c <i2c_transmit+0x28>
	TWCR = 0x94;                                                  // stop bit
    5f12:	84 e9       	ldi	r24, 0x94	; 148
    5f14:	86 bf       	out	0x36, r24	; 54
}
    5f16:	08 95       	ret

00005f18 <i2cRead>:

unsigned char i2cRead(char address, char reg)
{
   char read_data = 0;

   TWCR = 0xA4;                                                  // send a start bit on i2c bus
    5f18:	94 ea       	ldi	r25, 0xA4	; 164
    5f1a:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit  
    5f1c:	06 b6       	in	r0, 0x36	; 54
    5f1e:	07 fe       	sbrs	r0, 7
    5f20:	fd cf       	rjmp	.-6      	; 0x5f1c <i2cRead+0x4>
   TWDR = address;                                               // load address of i2c device
    5f22:	83 b9       	out	0x03, r24	; 3
   TWCR = 0x84;                                                  // transmit 
    5f24:	94 e8       	ldi	r25, 0x84	; 132
    5f26:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f28:	06 b6       	in	r0, 0x36	; 54
    5f2a:	07 fe       	sbrs	r0, 7
    5f2c:	fd cf       	rjmp	.-6      	; 0x5f28 <i2cRead+0x10>
   TWDR = reg;                                                   // send register number to read from
    5f2e:	63 b9       	out	0x03, r22	; 3
   TWCR = 0x84;                                                  // transmit
    5f30:	94 e8       	ldi	r25, 0x84	; 132
    5f32:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f34:	06 b6       	in	r0, 0x36	; 54
    5f36:	07 fe       	sbrs	r0, 7
    5f38:	fd cf       	rjmp	.-6      	; 0x5f34 <i2cRead+0x1c>

   TWCR = 0xA4;                                                  // send repeated start bit
    5f3a:	94 ea       	ldi	r25, 0xA4	; 164
    5f3c:	96 bf       	out	0x36, r25	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5f3e:	06 b6       	in	r0, 0x36	; 54
    5f40:	07 fe       	sbrs	r0, 7
    5f42:	fd cf       	rjmp	.-6      	; 0x5f3e <i2cRead+0x26>
   TWDR = address+1;                                             // transmit address of i2c device with readbit set
    5f44:	8f 5f       	subi	r24, 0xFF	; 255
    5f46:	83 b9       	out	0x03, r24	; 3
   TWCR = 0xC4;                                                  // clear transmit interupt flag
    5f48:	84 ec       	ldi	r24, 0xC4	; 196
    5f4a:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit
    5f4c:	06 b6       	in	r0, 0x36	; 54
    5f4e:	07 fe       	sbrs	r0, 7
    5f50:	fd cf       	rjmp	.-6      	; 0x5f4c <i2cRead+0x34>
   TWCR = 0x84;                                                  // transmit, nack (last byte request)
    5f52:	84 e8       	ldi	r24, 0x84	; 132
    5f54:	86 bf       	out	0x36, r24	; 54
   while(!(TWCR & 0x80));                                        // wait for confirmation of transmit 
    5f56:	06 b6       	in	r0, 0x36	; 54
    5f58:	07 fe       	sbrs	r0, 7
    5f5a:	fd cf       	rjmp	.-6      	; 0x5f56 <i2cRead+0x3e>
   read_data = TWDR;                                             // and grab the target data
    5f5c:	83 b1       	in	r24, 0x03	; 3
   TWCR = 0x94;                                                  // send a stop bit on i2c bus
    5f5e:	94 e9       	ldi	r25, 0x94	; 148
    5f60:	96 bf       	out	0x36, r25	; 54
   return read_data;
}
    5f62:	08 95       	ret

00005f64 <lcdSiap>:


unsigned char lcdSiap(){
	unsigned char busyFlag;

	LCD_DATA_DDR = 0x00;					// Set PORT DATA sebagai input
    5f64:	1a ba       	out	0x1a, r1	; 26
	LCD_DATA_PORT = 0x00;					// Matikan pull-up
    5f66:	1b ba       	out	0x1b, r1	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    5f68:	ad 98       	cbi	0x15, 5	; 21
	LCD_CONTROL_PORT |= _BV(LCD_RW_BIT);	// RW = 1
    5f6a:	ae 9a       	sbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    5f6c:	af 9a       	sbi	0x15, 7	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5f6e:	84 e0       	ldi	r24, 0x04	; 4
    5f70:	8a 95       	dec	r24
    5f72:	f1 f7       	brne	.-4      	; 0x5f70 <lcdSiap+0xc>

	_delay_us(1);							// Beri jeda untuk menunggu input stabil

	busyFlag = (LCD_DATA_PIN & _BV(7));		// Check busy flag bit
    5f74:	89 b3       	in	r24, 0x19	; 25
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0
    5f76:	af 98       	cbi	0x15, 7	; 21

	return busyFlag;
}
    5f78:	80 78       	andi	r24, 0x80	; 128
    5f7a:	08 95       	ret

00005f7c <lcdWait>:

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
		busyFlag = lcdSiap();
    5f7c:	0e 94 b2 2f 	call	0x5f64	; 0x5f64 <lcdSiap>
}

void lcdWait(){
	unsigned char busyFlag = 1;

	while(busyFlag != 0){					// Tunggu hingga busy flag == 0
    5f80:	88 23       	and	r24, r24
    5f82:	e1 f7       	brne	.-8      	; 0x5f7c <lcdWait>
		busyFlag = lcdSiap();
	}
}
    5f84:	08 95       	ret

00005f86 <kirim_perintah_lcd>:

void kirim_perintah_lcd(unsigned char perintah){
    5f86:	df 93       	push	r29
    5f88:	cf 93       	push	r28
    5f8a:	0f 92       	push	r0
    5f8c:	cd b7       	in	r28, 0x3d	; 61
    5f8e:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    5f90:	89 83       	std	Y+1, r24	; 0x01
    5f92:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    5f96:	9f ef       	ldi	r25, 0xFF	; 255
    5f98:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT &= ~_BV(LCD_RS_BIT);	// RS = 0
    5f9a:	ad 98       	cbi	0x15, 5	; 21
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    5f9c:	ae 98       	cbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    5f9e:	af 9a       	sbi	0x15, 7	; 21
	LCD_DATA_PORT = perintah;				// Set perintah yang ingin dikirim	
    5fa0:	89 81       	ldd	r24, Y+1	; 0x01
    5fa2:	8b bb       	out	0x1b, r24	; 27
	
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    5fa4:	af 98       	cbi	0x15, 7	; 21
}
    5fa6:	0f 90       	pop	r0
    5fa8:	cf 91       	pop	r28
    5faa:	df 91       	pop	r29
    5fac:	08 95       	ret

00005fae <init_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5fae:	8f e5       	ldi	r24, 0x5F	; 95
    5fb0:	9a ee       	ldi	r25, 0xEA	; 234
    5fb2:	01 97       	sbiw	r24, 0x01	; 1
    5fb4:	f1 f7       	brne	.-4      	; 0x5fb2 <init_lcd+0x4>
    5fb6:	00 c0       	rjmp	.+0      	; 0x5fb8 <init_lcd+0xa>
    5fb8:	00 00       	nop
//Inisialisasi LCD
void init_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							
    kirim_perintah_lcd(0x38);  				//Function set: Interface is 8 bit long,
    5fba:	88 e3       	ldi	r24, 0x38	; 56
    5fbc:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5fc0:	98 ec       	ldi	r25, 0xC8	; 200
    5fc2:	9a 95       	dec	r25
    5fc4:	f1 f7       	brne	.-4      	; 0x5fc2 <init_lcd+0x14>
    _delay_us(50);  						// 2lines, 5x7 dots (N=1, F=0)
											//Execution time 39 us
    
    kirim_perintah_lcd(0x04);				//Display Off
    5fc6:	84 e0       	ldi	r24, 0x04	; 4
    5fc8:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x01);				//Display Clear
    5fcc:	81 e0       	ldi	r24, 0x01	; 1
    5fce:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x06);				//Entry mode set: increment & no display shift
    5fd2:	86 e0       	ldi	r24, 0x06	; 6
    5fd4:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
    
    kirim_perintah_lcd(0x0E);				//Display ON,Cursor OFF & Blink OFF
    5fd8:	8e e0       	ldi	r24, 0x0E	; 14
    5fda:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
}
    5fde:	08 95       	ret

00005fe0 <clear_lcd>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5fe0:	8f e5       	ldi	r24, 0x5F	; 95
    5fe2:	9a ee       	ldi	r25, 0xEA	; 234
    5fe4:	01 97       	sbiw	r24, 0x01	; 1
    5fe6:	f1 f7       	brne	.-4      	; 0x5fe4 <clear_lcd+0x4>
    5fe8:	00 c0       	rjmp	.+0      	; 0x5fea <clear_lcd+0xa>
    5fea:	00 00       	nop
//Clear LCD
void clear_lcd (void)
{
    _delay_ms(20);  						//Wait for more than 15 ms
    							  
    kirim_perintah_lcd(0x01);				//Display Clear
    5fec:	81 e0       	ldi	r24, 0x01	; 1
    5fee:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
    
}
    5ff2:	08 95       	ret

00005ff4 <set_cursor>:

void set_cursor(int x,int y){
	int address = 0b10000000;
	char ddram = address ^ x;
    5ff4:	80 58       	subi	r24, 0x80	; 128
	if (y==1){
    5ff6:	61 30       	cpi	r22, 0x01	; 1
    5ff8:	71 05       	cpc	r23, r1
    5ffa:	11 f4       	brne	.+4      	; 0x6000 <set_cursor+0xc>
		ddram = ddram ^ 0b01000000;
    5ffc:	90 e4       	ldi	r25, 0x40	; 64
    5ffe:	89 27       	eor	r24, r25
	}
	kirim_perintah_lcd(ddram);
    6000:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <kirim_perintah_lcd>
}
    6004:	08 95       	ret

00006006 <tulis_data_ram_lcd>:
		tulis_data_ram_lcd(data[ii]);
	}

}

void tulis_data_ram_lcd(unsigned char data){
    6006:	df 93       	push	r29
    6008:	cf 93       	push	r28
    600a:	0f 92       	push	r0
    600c:	cd b7       	in	r28, 0x3d	; 61
    600e:	de b7       	in	r29, 0x3e	; 62
	lcdWait();								// Tunggu hingga lcd siap
    6010:	89 83       	std	Y+1, r24	; 0x01
    6012:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <lcdWait>

	LCD_DATA_DDR = 0xFF;					// Set Data sebagai output
    6016:	9f ef       	ldi	r25, 0xFF	; 255
    6018:	9a bb       	out	0x1a, r25	; 26
	LCD_CONTROL_PORT |= _BV(LCD_RS_BIT);	// RS = 1
    601a:	ad 9a       	sbi	0x15, 5	; 21
	LCD_CONTROL_PORT &= ~_BV(LCD_RW_BIT);	// RW = 0
    601c:	ae 98       	cbi	0x15, 6	; 21
	LCD_CONTROL_PORT |= _BV(LCD_EN_BIT);	// EN = 1
    601e:	af 9a       	sbi	0x15, 7	; 21
	
	LCD_DATA_PORT = data;					// Set data yang ingin dikirim
    6020:	89 81       	ldd	r24, Y+1	; 0x01
    6022:	8b bb       	out	0x1b, r24	; 27
	LCD_CONTROL_PORT &= ~_BV(LCD_EN_BIT);	// EN = 0		
    6024:	af 98       	cbi	0x15, 7	; 21
}
    6026:	0f 90       	pop	r0
    6028:	cf 91       	pop	r28
    602a:	df 91       	pop	r29
    602c:	08 95       	ret

0000602e <tulis_string>:
void tulis_data_at(unsigned char data, int x, int y){
	set_cursor(x,y);
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
    602e:	ef 92       	push	r14
    6030:	ff 92       	push	r15
    6032:	0f 93       	push	r16
    6034:	1f 93       	push	r17
    6036:	cf 93       	push	r28
    6038:	df 93       	push	r29
    603a:	7c 01       	movw	r14, r24
    603c:	cb 01       	movw	r24, r22
	set_cursor(x,y);
    603e:	ba 01       	movw	r22, r20
    6040:	0e 94 fa 2f 	call	0x5ff4	; 0x5ff4 <set_cursor>
    6044:	0e 2d       	mov	r16, r14
    6046:	1f 2d       	mov	r17, r15
	for(int ii=0; ii<strlen(data); ii++){
    6048:	c0 e0       	ldi	r28, 0x00	; 0
    604a:	d0 e0       	ldi	r29, 0x00	; 0
    604c:	06 c0       	rjmp	.+12     	; 0x605a <tulis_string+0x2c>
		tulis_data_ram_lcd(data[ii]);
    604e:	f8 01       	movw	r30, r16
    6050:	81 91       	ld	r24, Z+
    6052:	8f 01       	movw	r16, r30
    6054:	0e 94 03 30 	call	0x6006	; 0x6006 <tulis_data_ram_lcd>
	tulis_data_ram_lcd(data);
}

void tulis_string(unsigned char* data, int x, int y){
	set_cursor(x,y);
	for(int ii=0; ii<strlen(data); ii++){
    6058:	21 96       	adiw	r28, 0x01	; 1
    605a:	f7 01       	movw	r30, r14
    605c:	01 90       	ld	r0, Z+
    605e:	00 20       	and	r0, r0
    6060:	e9 f7       	brne	.-6      	; 0x605c <tulis_string+0x2e>
    6062:	31 97       	sbiw	r30, 0x01	; 1
    6064:	ee 19       	sub	r30, r14
    6066:	ff 09       	sbc	r31, r15
    6068:	ce 17       	cp	r28, r30
    606a:	df 07       	cpc	r29, r31
    606c:	80 f3       	brcs	.-32     	; 0x604e <tulis_string+0x20>
		tulis_data_ram_lcd(data[ii]);
	}

}
    606e:	df 91       	pop	r29
    6070:	cf 91       	pop	r28
    6072:	1f 91       	pop	r17
    6074:	0f 91       	pop	r16
    6076:	ff 90       	pop	r15
    6078:	ef 90       	pop	r14
    607a:	08 95       	ret

0000607c <tulis_data_at>:
		ddram = ddram ^ 0b01000000;
	}
	kirim_perintah_lcd(ddram);
}

void tulis_data_at(unsigned char data, int x, int y){
    607c:	1f 93       	push	r17
    607e:	18 2f       	mov	r17, r24
	set_cursor(x,y);
    6080:	cb 01       	movw	r24, r22
    6082:	ba 01       	movw	r22, r20
    6084:	0e 94 fa 2f 	call	0x5ff4	; 0x5ff4 <set_cursor>
	tulis_data_ram_lcd(data);
    6088:	81 2f       	mov	r24, r17
    608a:	0e 94 03 30 	call	0x6006	; 0x6006 <tulis_data_ram_lcd>
}
    608e:	1f 91       	pop	r17
    6090:	08 95       	ret

00006092 <setup_seed>:
static int play_state=0;
//state mode
static int mode = SLOW_MODE;


void setup_seed(){
    6092:	1f 93       	push	r17
	 unsigned char oldADMUX = ADMUX;
    6094:	17 b1       	in	r17, 0x07	; 7
	 ADMUX |=  _BV(MUX0); //choose ADC1 on PB2
    6096:	38 9a       	sbi	0x07, 0	; 7
	 ADCSRA |= _BV(ADPS2) |_BV(ADPS1) |_BV(ADPS0); //set prescaler to max value, 128
    6098:	86 b1       	in	r24, 0x06	; 6
    609a:	87 60       	ori	r24, 0x07	; 7
    609c:	86 b9       	out	0x06, r24	; 6
	 ADCSRA |= _BV(ADEN); //enable the ADC
    609e:	37 9a       	sbi	0x06, 7	; 6
	 ADCSRA |= _BV(ADSC);//start conversion
    60a0:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait until the hardware clears the flag. Note semicolon!
    60a2:	36 99       	sbic	0x06, 6	; 6
    60a4:	fe cf       	rjmp	.-4      	; 0x60a2 <setup_seed+0x10>
	 unsigned char byte1 = ADCL;
    60a6:	94 b1       	in	r25, 0x04	; 4
	 ADCSRA |= _BV(ADSC);//start conversion
    60a8:	36 9a       	sbi	0x06, 6	; 6
	 while (ADCSRA & _BV(ADSC)); //wait again note semicolon!
    60aa:	36 99       	sbic	0x06, 6	; 6
    60ac:	fe cf       	rjmp	.-4      	; 0x60aa <setup_seed+0x18>
	 unsigned char byte2 = ADCL;
    60ae:	84 b1       	in	r24, 0x04	; 4
	 unsigned int seed = byte1 << 8 | byte2;
    60b0:	39 2f       	mov	r19, r25
    60b2:	20 e0       	ldi	r18, 0x00	; 0
    60b4:	90 e0       	ldi	r25, 0x00	; 0
	 srand(seed);
    60b6:	82 2b       	or	r24, r18
    60b8:	93 2b       	or	r25, r19
    60ba:	0e 94 4e 32 	call	0x649c	; 0x649c <srand>
	 ADCSRA &= ~_BV(ADEN); //disable ADC
    60be:	37 98       	cbi	0x06, 7	; 6
	 ADMUX = oldADMUX;
    60c0:	17 b9       	out	0x07, r17	; 7
}
    60c2:	1f 91       	pop	r17
    60c4:	08 95       	ret

000060c6 <init_game>:



void init_game(){
	setup_seed();
    60c6:	0e 94 49 30 	call	0x6092	; 0x6092 <setup_seed>
	mario = 0;
    60ca:	10 92 1b 08 	sts	0x081B, r1
    60ce:	10 92 1a 08 	sts	0x081A, r1
	pass = 0;
    60d2:	10 92 17 08 	sts	0x0817, r1
    60d6:	10 92 16 08 	sts	0x0816, r1
	speed = 0;
    60da:	10 92 3d 08 	sts	0x083D, r1
    60de:	10 92 3c 08 	sts	0x083C, r1
	summon_time = 2*TIME_INTERVAL;
    60e2:	84 e0       	ldi	r24, 0x04	; 4
    60e4:	90 e0       	ldi	r25, 0x00	; 0
    60e6:	90 93 a0 01 	sts	0x01A0, r25
    60ea:	80 93 9f 01 	sts	0x019F, r24
	play_state = GAME_PLAY;
    60ee:	10 92 19 08 	sts	0x0819, r1
    60f2:	10 92 18 08 	sts	0x0818, r1
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			obstacle[ii][jj] = 0;
    60f6:	10 92 1d 08 	sts	0x081D, r1
    60fa:	10 92 1c 08 	sts	0x081C, r1
    60fe:	10 92 1f 08 	sts	0x081F, r1
    6102:	10 92 1e 08 	sts	0x081E, r1
    6106:	10 92 21 08 	sts	0x0821, r1
    610a:	10 92 20 08 	sts	0x0820, r1
    610e:	10 92 23 08 	sts	0x0823, r1
    6112:	10 92 22 08 	sts	0x0822, r1
    6116:	10 92 25 08 	sts	0x0825, r1
    611a:	10 92 24 08 	sts	0x0824, r1
    611e:	10 92 27 08 	sts	0x0827, r1
    6122:	10 92 26 08 	sts	0x0826, r1
    6126:	10 92 29 08 	sts	0x0829, r1
    612a:	10 92 28 08 	sts	0x0828, r1
    612e:	10 92 2b 08 	sts	0x082B, r1
    6132:	10 92 2a 08 	sts	0x082A, r1
    6136:	10 92 2d 08 	sts	0x082D, r1
    613a:	10 92 2c 08 	sts	0x082C, r1
    613e:	10 92 2f 08 	sts	0x082F, r1
    6142:	10 92 2e 08 	sts	0x082E, r1
    6146:	10 92 31 08 	sts	0x0831, r1
    614a:	10 92 30 08 	sts	0x0830, r1
    614e:	10 92 33 08 	sts	0x0833, r1
    6152:	10 92 32 08 	sts	0x0832, r1
    6156:	10 92 35 08 	sts	0x0835, r1
    615a:	10 92 34 08 	sts	0x0834, r1
    615e:	10 92 37 08 	sts	0x0837, r1
    6162:	10 92 36 08 	sts	0x0836, r1
    6166:	10 92 39 08 	sts	0x0839, r1
    616a:	10 92 38 08 	sts	0x0838, r1
    616e:	10 92 3b 08 	sts	0x083B, r1
    6172:	10 92 3a 08 	sts	0x083A, r1
		}
	}
	obstacle[rand()%2][7] = 1;
    6176:	0e 94 49 32 	call	0x6492	; 0x6492 <rand>
    617a:	62 e0       	ldi	r22, 0x02	; 2
    617c:	70 e0       	ldi	r23, 0x00	; 0
    617e:	0e 94 de 31 	call	0x63bc	; 0x63bc <__divmodhi4>
    6182:	24 e0       	ldi	r18, 0x04	; 4
    6184:	88 0f       	add	r24, r24
    6186:	99 1f       	adc	r25, r25
    6188:	2a 95       	dec	r18
    618a:	e1 f7       	brne	.-8      	; 0x6184 <init_game+0xbe>
    618c:	84 5e       	subi	r24, 0xE4	; 228
    618e:	97 4f       	sbci	r25, 0xF7	; 247
    6190:	21 e0       	ldi	r18, 0x01	; 1
    6192:	30 e0       	ldi	r19, 0x00	; 0
    6194:	fc 01       	movw	r30, r24
    6196:	37 87       	std	Z+15, r19	; 0x0f
    6198:	26 87       	std	Z+14, r18	; 0x0e
}
    619a:	08 95       	ret

0000619c <update_game>:


void update_game(){
    619c:	cf 93       	push	r28
    619e:	df 93       	push	r29
	if(play_state==GAME_PLAY){
    61a0:	80 91 18 08 	lds	r24, 0x0818
    61a4:	90 91 19 08 	lds	r25, 0x0819
    61a8:	00 97       	sbiw	r24, 0x00	; 0
    61aa:	09 f0       	breq	.+2      	; 0x61ae <update_game+0x12>
    61ac:	94 c0       	rjmp	.+296    	; 0x62d6 <update_game+0x13a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
    61ae:	83 e0       	ldi	r24, 0x03	; 3
    61b0:	90 e0       	ldi	r25, 0x00	; 0
    61b2:	60 91 9d 01 	lds	r22, 0x019D
    61b6:	70 91 9e 01 	lds	r23, 0x019E
    61ba:	86 1b       	sub	r24, r22
    61bc:	97 0b       	sbc	r25, r23
    61be:	20 91 3c 08 	lds	r18, 0x083C
    61c2:	30 91 3d 08 	lds	r19, 0x083D
    61c6:	82 17       	cp	r24, r18
    61c8:	93 07       	cpc	r25, r19
    61ca:	ec f5       	brge	.+122    	; 0x6246 <update_game+0xaa>
			speed = 0;
    61cc:	10 92 3d 08 	sts	0x083D, r1
    61d0:	10 92 3c 08 	sts	0x083C, r1
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
						}else{
							pass+=mode;
    61d4:	40 91 16 08 	lds	r20, 0x0816
    61d8:	50 91 17 08 	lds	r21, 0x0817
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    61dc:	80 e0       	ldi	r24, 0x00	; 0
    61de:	90 e0       	ldi	r25, 0x00	; 0
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
						obstacle[ii][jj] = 0;
						if(jj>=1) {
							obstacle[ii][jj-1] = 1;
    61e0:	a1 e0       	ldi	r26, 0x01	; 1
    61e2:	b0 e0       	ldi	r27, 0x00	; 0
    61e4:	18 c0       	rjmp	.+48     	; 0x6216 <update_game+0x7a>
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
					if(obstacle[ii][jj]){
    61e6:	c2 81       	ldd	r28, Z+2	; 0x02
    61e8:	d3 81       	ldd	r29, Z+3	; 0x03
    61ea:	20 97       	sbiw	r28, 0x00	; 0
    61ec:	51 f0       	breq	.+20     	; 0x6202 <update_game+0x66>
						obstacle[ii][jj] = 0;
    61ee:	13 82       	std	Z+3, r1	; 0x03
    61f0:	12 82       	std	Z+2, r1	; 0x02
						if(jj>=1) {
    61f2:	21 15       	cp	r18, r1
    61f4:	31 05       	cpc	r19, r1
    61f6:	19 f0       	breq	.+6      	; 0x61fe <update_game+0x62>
							obstacle[ii][jj-1] = 1;
    61f8:	b1 83       	std	Z+1, r27	; 0x01
    61fa:	a0 83       	st	Z, r26
    61fc:	02 c0       	rjmp	.+4      	; 0x6202 <update_game+0x66>
						}else{
							pass+=mode;
    61fe:	46 0f       	add	r20, r22
    6200:	57 1f       	adc	r21, r23
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
				for (int jj=0; jj<8; jj++){
    6202:	2f 5f       	subi	r18, 0xFF	; 255
    6204:	3f 4f       	sbci	r19, 0xFF	; 255
    6206:	32 96       	adiw	r30, 0x02	; 2
    6208:	28 30       	cpi	r18, 0x08	; 8
    620a:	31 05       	cpc	r19, r1
    620c:	61 f7       	brne	.-40     	; 0x61e6 <update_game+0x4a>
void update_game(){
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    620e:	01 96       	adiw	r24, 0x01	; 1
    6210:	82 30       	cpi	r24, 0x02	; 2
    6212:	91 05       	cpc	r25, r1
    6214:	59 f0       	breq	.+22     	; 0x622c <update_game+0x90>
	}
	obstacle[rand()%2][7] = 1;
}


void update_game(){
    6216:	fc 01       	movw	r30, r24
    6218:	24 e0       	ldi	r18, 0x04	; 4
    621a:	ee 0f       	add	r30, r30
    621c:	ff 1f       	adc	r31, r31
    621e:	2a 95       	dec	r18
    6220:	e1 f7       	brne	.-8      	; 0x621a <update_game+0x7e>
    6222:	e6 5e       	subi	r30, 0xE6	; 230
    6224:	f7 4f       	sbci	r31, 0xF7	; 247
    6226:	20 e0       	ldi	r18, 0x00	; 0
    6228:	30 e0       	ldi	r19, 0x00	; 0
    622a:	dd cf       	rjmp	.-70     	; 0x61e6 <update_game+0x4a>
	if(play_state==GAME_PLAY){
		//menggerakan mario ketika time> time_interval
		if(speed>TIME_INTERVAL-(mode-1)){
			speed = 0;
			for (int ii=0; ii<2; ii++){
    622c:	50 93 17 08 	sts	0x0817, r21
    6230:	40 93 16 08 	sts	0x0816, r20
						}				
					}

				}
			}
			summon_time--;	
    6234:	80 91 9f 01 	lds	r24, 0x019F
    6238:	90 91 a0 01 	lds	r25, 0x01A0
    623c:	01 97       	sbiw	r24, 0x01	; 1
    623e:	90 93 a0 01 	sts	0x01A0, r25
    6242:	80 93 9f 01 	sts	0x019F, r24
		}	

		

		if(obstacle[mario][0]){
    6246:	e0 91 1a 08 	lds	r30, 0x081A
    624a:	f0 91 1b 08 	lds	r31, 0x081B
    624e:	44 e0       	ldi	r20, 0x04	; 4
    6250:	ee 0f       	add	r30, r30
    6252:	ff 1f       	adc	r31, r31
    6254:	4a 95       	dec	r20
    6256:	e1 f7       	brne	.-8      	; 0x6250 <update_game+0xb4>
    6258:	e4 5e       	subi	r30, 0xE4	; 228
    625a:	f7 4f       	sbci	r31, 0xF7	; 247
    625c:	80 81       	ld	r24, Z
    625e:	91 81       	ldd	r25, Z+1	; 0x01
    6260:	00 97       	sbiw	r24, 0x00	; 0
    6262:	31 f0       	breq	.+12     	; 0x6270 <update_game+0xd4>
			play_state = GAME_FINAL;
    6264:	81 e0       	ldi	r24, 0x01	; 1
    6266:	90 e0       	ldi	r25, 0x00	; 0
    6268:	90 93 19 08 	sts	0x0819, r25
    626c:	80 93 18 08 	sts	0x0818, r24
		}


		if(summon_time<=0){
    6270:	80 91 9f 01 	lds	r24, 0x019F
    6274:	90 91 a0 01 	lds	r25, 0x01A0
    6278:	18 16       	cp	r1, r24
    627a:	19 06       	cpc	r1, r25
    627c:	1c f1       	brlt	.+70     	; 0x62c4 <update_game+0x128>
			int yy =  rand()%2;
    627e:	0e 94 49 32 	call	0x6492	; 0x6492 <rand>
    6282:	62 e0       	ldi	r22, 0x02	; 2
    6284:	70 e0       	ldi	r23, 0x00	; 0
    6286:	0e 94 de 31 	call	0x63bc	; 0x63bc <__divmodhi4>
			obstacle[yy][7] = 1;
    628a:	34 e0       	ldi	r19, 0x04	; 4
    628c:	88 0f       	add	r24, r24
    628e:	99 1f       	adc	r25, r25
    6290:	3a 95       	dec	r19
    6292:	e1 f7       	brne	.-8      	; 0x628c <update_game+0xf0>
    6294:	84 5e       	subi	r24, 0xE4	; 228
    6296:	97 4f       	sbci	r25, 0xF7	; 247
    6298:	21 e0       	ldi	r18, 0x01	; 1
    629a:	30 e0       	ldi	r19, 0x00	; 0
    629c:	fc 01       	movw	r30, r24
    629e:	37 87       	std	Z+15, r19	; 0x0f
    62a0:	26 87       	std	Z+14, r18	; 0x0e
			summon_time = rand()%(3-(mode-1))+2;	
    62a2:	0e 94 49 32 	call	0x6492	; 0x6492 <rand>
    62a6:	64 e0       	ldi	r22, 0x04	; 4
    62a8:	70 e0       	ldi	r23, 0x00	; 0
    62aa:	20 91 9d 01 	lds	r18, 0x019D
    62ae:	30 91 9e 01 	lds	r19, 0x019E
    62b2:	62 1b       	sub	r22, r18
    62b4:	73 0b       	sbc	r23, r19
    62b6:	0e 94 de 31 	call	0x63bc	; 0x63bc <__divmodhi4>
    62ba:	02 96       	adiw	r24, 0x02	; 2
    62bc:	90 93 a0 01 	sts	0x01A0, r25
    62c0:	80 93 9f 01 	sts	0x019F, r24
		}

		speed++;
    62c4:	80 91 3c 08 	lds	r24, 0x083C
    62c8:	90 91 3d 08 	lds	r25, 0x083D
    62cc:	01 96       	adiw	r24, 0x01	; 1
    62ce:	90 93 3d 08 	sts	0x083D, r25
    62d2:	80 93 3c 08 	sts	0x083C, r24
	}
}
    62d6:	df 91       	pop	r29
    62d8:	cf 91       	pop	r28
    62da:	08 95       	ret

000062dc <draw_game>:



void draw_game(){
    62dc:	ef 92       	push	r14
    62de:	ff 92       	push	r15
    62e0:	0f 93       	push	r16
    62e2:	1f 93       	push	r17
    62e4:	cf 93       	push	r28
    62e6:	df 93       	push	r29
	tulis_data_at('M',0,mario);
    62e8:	40 91 1a 08 	lds	r20, 0x081A
    62ec:	50 91 1b 08 	lds	r21, 0x081B
    62f0:	8d e4       	ldi	r24, 0x4D	; 77
    62f2:	60 e0       	ldi	r22, 0x00	; 0
    62f4:	70 e0       	ldi	r23, 0x00	; 0
    62f6:	0e 94 3e 30 	call	0x607c	; 0x607c <tulis_data_at>
	if(mario==1){
    62fa:	80 91 1a 08 	lds	r24, 0x081A
    62fe:	90 91 1b 08 	lds	r25, 0x081B
    6302:	81 30       	cpi	r24, 0x01	; 1
    6304:	91 05       	cpc	r25, r1
    6306:	31 f4       	brne	.+12     	; 0x6314 <draw_game+0x38>
		tulis_data_at(' ',0,0);
    6308:	80 e2       	ldi	r24, 0x20	; 32
    630a:	60 e0       	ldi	r22, 0x00	; 0
    630c:	70 e0       	ldi	r23, 0x00	; 0
    630e:	40 e0       	ldi	r20, 0x00	; 0
    6310:	50 e0       	ldi	r21, 0x00	; 0
    6312:	05 c0       	rjmp	.+10     	; 0x631e <draw_game+0x42>
	}else{
		tulis_data_at(' ',0,1);
    6314:	80 e2       	ldi	r24, 0x20	; 32
    6316:	60 e0       	ldi	r22, 0x00	; 0
    6318:	70 e0       	ldi	r23, 0x00	; 0
    631a:	41 e0       	ldi	r20, 0x01	; 1
    631c:	50 e0       	ldi	r21, 0x00	; 0
    631e:	0e 94 3e 30 	call	0x607c	; 0x607c <tulis_data_at>
	}
}



void draw_game(){
    6322:	c0 e0       	ldi	r28, 0x00	; 0
    6324:	d0 e0       	ldi	r29, 0x00	; 0
    6326:	16 c0       	rjmp	.+44     	; 0x6354 <draw_game+0x78>
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
			if(obstacle[ii][jj]){
    6328:	f8 01       	movw	r30, r16
    632a:	81 91       	ld	r24, Z+
    632c:	91 91       	ld	r25, Z+
    632e:	8f 01       	movw	r16, r30
    6330:	00 97       	sbiw	r24, 0x00	; 0
    6332:	29 f0       	breq	.+10     	; 0x633e <draw_game+0x62>
				tulis_data_at('#',jj,ii);			
    6334:	83 e2       	ldi	r24, 0x23	; 35
    6336:	b7 01       	movw	r22, r14
    6338:	ae 01       	movw	r20, r28
    633a:	0e 94 3e 30 	call	0x607c	; 0x607c <tulis_data_at>
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
		for (int jj=0; jj<8; jj++){
    633e:	08 94       	sec
    6340:	e1 1c       	adc	r14, r1
    6342:	f1 1c       	adc	r15, r1
    6344:	f8 e0       	ldi	r31, 0x08	; 8
    6346:	ef 16       	cp	r14, r31
    6348:	f1 04       	cpc	r15, r1
    634a:	71 f7       	brne	.-36     	; 0x6328 <draw_game+0x4c>
	if(mario==1){
		tulis_data_at(' ',0,0);
	}else{
		tulis_data_at(' ',0,1);
	}
	for (int ii=0; ii<2; ii++){
    634c:	21 96       	adiw	r28, 0x01	; 1
    634e:	c2 30       	cpi	r28, 0x02	; 2
    6350:	d1 05       	cpc	r29, r1
    6352:	59 f0       	breq	.+22     	; 0x636a <draw_game+0x8e>
	}
}



void draw_game(){
    6354:	8e 01       	movw	r16, r28
    6356:	34 e0       	ldi	r19, 0x04	; 4
    6358:	00 0f       	add	r16, r16
    635a:	11 1f       	adc	r17, r17
    635c:	3a 95       	dec	r19
    635e:	e1 f7       	brne	.-8      	; 0x6358 <draw_game+0x7c>
    6360:	04 5e       	subi	r16, 0xE4	; 228
    6362:	17 4f       	sbci	r17, 0xF7	; 247
    6364:	ee 24       	eor	r14, r14
    6366:	ff 24       	eor	r15, r15
    6368:	df cf       	rjmp	.-66     	; 0x6328 <draw_game+0x4c>
				tulis_data_at('#',jj,ii);			
			}
		}
	}
	
}
    636a:	df 91       	pop	r29
    636c:	cf 91       	pop	r28
    636e:	1f 91       	pop	r17
    6370:	0f 91       	pop	r16
    6372:	ff 90       	pop	r15
    6374:	ef 90       	pop	r14
    6376:	08 95       	ret

00006378 <set_mario>:

void set_mario(int loc){
	if(loc==0){
    6378:	00 97       	sbiw	r24, 0x00	; 0
    637a:	29 f4       	brne	.+10     	; 0x6386 <set_mario+0xe>
		mario = 0;
    637c:	10 92 1b 08 	sts	0x081B, r1
    6380:	10 92 1a 08 	sts	0x081A, r1
    6384:	08 95       	ret
	}else{
		mario = 1;
    6386:	81 e0       	ldi	r24, 0x01	; 1
    6388:	90 e0       	ldi	r25, 0x00	; 0
    638a:	90 93 1b 08 	sts	0x081B, r25
    638e:	80 93 1a 08 	sts	0x081A, r24
    6392:	08 95       	ret

00006394 <get_mario>:
	}
}

int get_mario(){
	return mario;
}
    6394:	80 91 1a 08 	lds	r24, 0x081A
    6398:	90 91 1b 08 	lds	r25, 0x081B
    639c:	08 95       	ret

0000639e <get_state>:


int get_state(){
	return play_state;
}
    639e:	80 91 18 08 	lds	r24, 0x0818
    63a2:	90 91 19 08 	lds	r25, 0x0819
    63a6:	08 95       	ret

000063a8 <getpass>:

int getpass(){
	return pass;
}
    63a8:	80 91 16 08 	lds	r24, 0x0816
    63ac:	90 91 17 08 	lds	r25, 0x0817
    63b0:	08 95       	ret

000063b2 <set_mode>:

void set_mode(int mod){
	mode = mod;
    63b2:	90 93 9e 01 	sts	0x019E, r25
    63b6:	80 93 9d 01 	sts	0x019D, r24
}
    63ba:	08 95       	ret

000063bc <__divmodhi4>:
    63bc:	97 fb       	bst	r25, 7
    63be:	09 2e       	mov	r0, r25
    63c0:	07 26       	eor	r0, r23
    63c2:	0a d0       	rcall	.+20     	; 0x63d8 <__divmodhi4_neg1>
    63c4:	77 fd       	sbrc	r23, 7
    63c6:	04 d0       	rcall	.+8      	; 0x63d0 <__divmodhi4_neg2>
    63c8:	0c d0       	rcall	.+24     	; 0x63e2 <__udivmodhi4>
    63ca:	06 d0       	rcall	.+12     	; 0x63d8 <__divmodhi4_neg1>
    63cc:	00 20       	and	r0, r0
    63ce:	1a f4       	brpl	.+6      	; 0x63d6 <__divmodhi4_exit>

000063d0 <__divmodhi4_neg2>:
    63d0:	70 95       	com	r23
    63d2:	61 95       	neg	r22
    63d4:	7f 4f       	sbci	r23, 0xFF	; 255

000063d6 <__divmodhi4_exit>:
    63d6:	08 95       	ret

000063d8 <__divmodhi4_neg1>:
    63d8:	f6 f7       	brtc	.-4      	; 0x63d6 <__divmodhi4_exit>
    63da:	90 95       	com	r25
    63dc:	81 95       	neg	r24
    63de:	9f 4f       	sbci	r25, 0xFF	; 255
    63e0:	08 95       	ret

000063e2 <__udivmodhi4>:
    63e2:	aa 1b       	sub	r26, r26
    63e4:	bb 1b       	sub	r27, r27
    63e6:	51 e1       	ldi	r21, 0x11	; 17
    63e8:	07 c0       	rjmp	.+14     	; 0x63f8 <__udivmodhi4_ep>

000063ea <__udivmodhi4_loop>:
    63ea:	aa 1f       	adc	r26, r26
    63ec:	bb 1f       	adc	r27, r27
    63ee:	a6 17       	cp	r26, r22
    63f0:	b7 07       	cpc	r27, r23
    63f2:	10 f0       	brcs	.+4      	; 0x63f8 <__udivmodhi4_ep>
    63f4:	a6 1b       	sub	r26, r22
    63f6:	b7 0b       	sbc	r27, r23

000063f8 <__udivmodhi4_ep>:
    63f8:	88 1f       	adc	r24, r24
    63fa:	99 1f       	adc	r25, r25
    63fc:	5a 95       	dec	r21
    63fe:	a9 f7       	brne	.-22     	; 0x63ea <__udivmodhi4_loop>
    6400:	80 95       	com	r24
    6402:	90 95       	com	r25
    6404:	bc 01       	movw	r22, r24
    6406:	cd 01       	movw	r24, r26
    6408:	08 95       	ret

0000640a <do_rand>:
    640a:	a0 e0       	ldi	r26, 0x00	; 0
    640c:	b0 e0       	ldi	r27, 0x00	; 0
    640e:	eb e0       	ldi	r30, 0x0B	; 11
    6410:	f2 e3       	ldi	r31, 0x32	; 50
    6412:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x10>
    6416:	ec 01       	movw	r28, r24
    6418:	68 81       	ld	r22, Y
    641a:	79 81       	ldd	r23, Y+1	; 0x01
    641c:	8a 81       	ldd	r24, Y+2	; 0x02
    641e:	9b 81       	ldd	r25, Y+3	; 0x03
    6420:	61 15       	cp	r22, r1
    6422:	71 05       	cpc	r23, r1
    6424:	81 05       	cpc	r24, r1
    6426:	91 05       	cpc	r25, r1
    6428:	21 f4       	brne	.+8      	; 0x6432 <do_rand+0x28>
    642a:	64 e2       	ldi	r22, 0x24	; 36
    642c:	79 ed       	ldi	r23, 0xD9	; 217
    642e:	8b e5       	ldi	r24, 0x5B	; 91
    6430:	97 e0       	ldi	r25, 0x07	; 7
    6432:	2d e1       	ldi	r18, 0x1D	; 29
    6434:	33 ef       	ldi	r19, 0xF3	; 243
    6436:	41 e0       	ldi	r20, 0x01	; 1
    6438:	50 e0       	ldi	r21, 0x00	; 0
    643a:	0e 94 2a 33 	call	0x6654	; 0x6654 <__divmodsi4>
    643e:	79 01       	movw	r14, r18
    6440:	8a 01       	movw	r16, r20
    6442:	27 ea       	ldi	r18, 0xA7	; 167
    6444:	31 e4       	ldi	r19, 0x41	; 65
    6446:	40 e0       	ldi	r20, 0x00	; 0
    6448:	50 e0       	ldi	r21, 0x00	; 0
    644a:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <__mulsi3>
    644e:	5b 01       	movw	r10, r22
    6450:	6c 01       	movw	r12, r24
    6452:	c8 01       	movw	r24, r16
    6454:	b7 01       	movw	r22, r14
    6456:	2c ee       	ldi	r18, 0xEC	; 236
    6458:	34 ef       	ldi	r19, 0xF4	; 244
    645a:	4f ef       	ldi	r20, 0xFF	; 255
    645c:	5f ef       	ldi	r21, 0xFF	; 255
    645e:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <__mulsi3>
    6462:	6a 0d       	add	r22, r10
    6464:	7b 1d       	adc	r23, r11
    6466:	8c 1d       	adc	r24, r12
    6468:	9d 1d       	adc	r25, r13
    646a:	97 ff       	sbrs	r25, 7
    646c:	04 c0       	rjmp	.+8      	; 0x6476 <do_rand+0x6c>
    646e:	61 50       	subi	r22, 0x01	; 1
    6470:	70 40       	sbci	r23, 0x00	; 0
    6472:	80 40       	sbci	r24, 0x00	; 0
    6474:	90 48       	sbci	r25, 0x80	; 128
    6476:	68 83       	st	Y, r22
    6478:	79 83       	std	Y+1, r23	; 0x01
    647a:	8a 83       	std	Y+2, r24	; 0x02
    647c:	9b 83       	std	Y+3, r25	; 0x03
    647e:	7f 77       	andi	r23, 0x7F	; 127
    6480:	cb 01       	movw	r24, r22
    6482:	cd b7       	in	r28, 0x3d	; 61
    6484:	de b7       	in	r29, 0x3e	; 62
    6486:	ea e0       	ldi	r30, 0x0A	; 10
    6488:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x10>

0000648c <rand_r>:
    648c:	0e 94 05 32 	call	0x640a	; 0x640a <do_rand>
    6490:	08 95       	ret

00006492 <rand>:
    6492:	81 ea       	ldi	r24, 0xA1	; 161
    6494:	91 e0       	ldi	r25, 0x01	; 1
    6496:	0e 94 05 32 	call	0x640a	; 0x640a <do_rand>
    649a:	08 95       	ret

0000649c <srand>:
    649c:	a0 e0       	ldi	r26, 0x00	; 0
    649e:	b0 e0       	ldi	r27, 0x00	; 0
    64a0:	80 93 a1 01 	sts	0x01A1, r24
    64a4:	90 93 a2 01 	sts	0x01A2, r25
    64a8:	a0 93 a3 01 	sts	0x01A3, r26
    64ac:	b0 93 a4 01 	sts	0x01A4, r27
    64b0:	08 95       	ret

000064b2 <memcpy>:
    64b2:	fb 01       	movw	r30, r22
    64b4:	dc 01       	movw	r26, r24
    64b6:	02 c0       	rjmp	.+4      	; 0x64bc <memcpy+0xa>
    64b8:	01 90       	ld	r0, Z+
    64ba:	0d 92       	st	X+, r0
    64bc:	41 50       	subi	r20, 0x01	; 1
    64be:	50 40       	sbci	r21, 0x00	; 0
    64c0:	d8 f7       	brcc	.-10     	; 0x64b8 <memcpy+0x6>
    64c2:	08 95       	ret

000064c4 <memset>:
    64c4:	dc 01       	movw	r26, r24
    64c6:	01 c0       	rjmp	.+2      	; 0x64ca <memset+0x6>
    64c8:	6d 93       	st	X+, r22
    64ca:	41 50       	subi	r20, 0x01	; 1
    64cc:	50 40       	sbci	r21, 0x00	; 0
    64ce:	e0 f7       	brcc	.-8      	; 0x64c8 <memset+0x4>
    64d0:	08 95       	ret

000064d2 <strncpy>:
    64d2:	fb 01       	movw	r30, r22
    64d4:	dc 01       	movw	r26, r24
    64d6:	41 50       	subi	r20, 0x01	; 1
    64d8:	50 40       	sbci	r21, 0x00	; 0
    64da:	48 f0       	brcs	.+18     	; 0x64ee <strncpy+0x1c>
    64dc:	01 90       	ld	r0, Z+
    64de:	0d 92       	st	X+, r0
    64e0:	00 20       	and	r0, r0
    64e2:	c9 f7       	brne	.-14     	; 0x64d6 <strncpy+0x4>
    64e4:	01 c0       	rjmp	.+2      	; 0x64e8 <strncpy+0x16>
    64e6:	1d 92       	st	X+, r1
    64e8:	41 50       	subi	r20, 0x01	; 1
    64ea:	50 40       	sbci	r21, 0x00	; 0
    64ec:	e0 f7       	brcc	.-8      	; 0x64e6 <strncpy+0x14>
    64ee:	08 95       	ret

000064f0 <ltoa>:
    64f0:	fa 01       	movw	r30, r20
    64f2:	cf 93       	push	r28
    64f4:	ff 93       	push	r31
    64f6:	ef 93       	push	r30
    64f8:	22 30       	cpi	r18, 0x02	; 2
    64fa:	44 f1       	brlt	.+80     	; 0x654c <ltoa+0x5c>
    64fc:	25 32       	cpi	r18, 0x25	; 37
    64fe:	34 f5       	brge	.+76     	; 0x654c <ltoa+0x5c>
    6500:	c2 2f       	mov	r28, r18
    6502:	e8 94       	clt
    6504:	ca 30       	cpi	r28, 0x0A	; 10
    6506:	49 f4       	brne	.+18     	; 0x651a <ltoa+0x2a>
    6508:	97 fb       	bst	r25, 7
    650a:	3e f4       	brtc	.+14     	; 0x651a <ltoa+0x2a>
    650c:	90 95       	com	r25
    650e:	80 95       	com	r24
    6510:	70 95       	com	r23
    6512:	61 95       	neg	r22
    6514:	7f 4f       	sbci	r23, 0xFF	; 255
    6516:	8f 4f       	sbci	r24, 0xFF	; 255
    6518:	9f 4f       	sbci	r25, 0xFF	; 255
    651a:	2c 2f       	mov	r18, r28
    651c:	33 27       	eor	r19, r19
    651e:	44 27       	eor	r20, r20
    6520:	55 27       	eor	r21, r21
    6522:	ff 93       	push	r31
    6524:	ef 93       	push	r30
    6526:	0e 94 08 33 	call	0x6610	; 0x6610 <__udivmodsi4>
    652a:	ef 91       	pop	r30
    652c:	ff 91       	pop	r31
    652e:	60 5d       	subi	r22, 0xD0	; 208
    6530:	6a 33       	cpi	r22, 0x3A	; 58
    6532:	0c f0       	brlt	.+2      	; 0x6536 <ltoa+0x46>
    6534:	69 5d       	subi	r22, 0xD9	; 217
    6536:	61 93       	st	Z+, r22
    6538:	b9 01       	movw	r22, r18
    653a:	ca 01       	movw	r24, r20
    653c:	60 50       	subi	r22, 0x00	; 0
    653e:	70 40       	sbci	r23, 0x00	; 0
    6540:	80 40       	sbci	r24, 0x00	; 0
    6542:	90 40       	sbci	r25, 0x00	; 0
    6544:	51 f7       	brne	.-44     	; 0x651a <ltoa+0x2a>
    6546:	16 f4       	brtc	.+4      	; 0x654c <ltoa+0x5c>
    6548:	cd e2       	ldi	r28, 0x2D	; 45
    654a:	c1 93       	st	Z+, r28
    654c:	10 82       	st	Z, r1
    654e:	8f 91       	pop	r24
    6550:	9f 91       	pop	r25
    6552:	cf 91       	pop	r28
    6554:	0c 94 b8 32 	jmp	0x6570	; 0x6570 <strrev>

00006558 <__eerd_word_m32>:
    6558:	a8 e1       	ldi	r26, 0x18	; 24
    655a:	b0 e0       	ldi	r27, 0x00	; 0
    655c:	42 e0       	ldi	r20, 0x02	; 2
    655e:	50 e0       	ldi	r21, 0x00	; 0
    6560:	0c 94 ca 32 	jmp	0x6594	; 0x6594 <__eerd_blraw_m32>

00006564 <__eeupd_word_m32>:
    6564:	01 96       	adiw	r24, 0x01	; 1
    6566:	27 2f       	mov	r18, r23
    6568:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <__eeupd_r18_m32>
    656c:	0c 94 d8 32 	jmp	0x65b0	; 0x65b0 <__eeupd_byte_m32>

00006570 <strrev>:
    6570:	dc 01       	movw	r26, r24
    6572:	fc 01       	movw	r30, r24
    6574:	67 2f       	mov	r22, r23
    6576:	71 91       	ld	r23, Z+
    6578:	77 23       	and	r23, r23
    657a:	e1 f7       	brne	.-8      	; 0x6574 <strrev+0x4>
    657c:	32 97       	sbiw	r30, 0x02	; 2
    657e:	04 c0       	rjmp	.+8      	; 0x6588 <strrev+0x18>
    6580:	7c 91       	ld	r23, X
    6582:	6d 93       	st	X+, r22
    6584:	70 83       	st	Z, r23
    6586:	62 91       	ld	r22, -Z
    6588:	ae 17       	cp	r26, r30
    658a:	bf 07       	cpc	r27, r31
    658c:	c8 f3       	brcs	.-14     	; 0x6580 <strrev+0x10>
    658e:	08 95       	ret

00006590 <__eerd_block_m32>:
    6590:	dc 01       	movw	r26, r24
    6592:	cb 01       	movw	r24, r22

00006594 <__eerd_blraw_m32>:
    6594:	fc 01       	movw	r30, r24
    6596:	e1 99       	sbic	0x1c, 1	; 28
    6598:	fe cf       	rjmp	.-4      	; 0x6596 <__eerd_blraw_m32+0x2>
    659a:	06 c0       	rjmp	.+12     	; 0x65a8 <__eerd_blraw_m32+0x14>
    659c:	ff bb       	out	0x1f, r31	; 31
    659e:	ee bb       	out	0x1e, r30	; 30
    65a0:	e0 9a       	sbi	0x1c, 0	; 28
    65a2:	31 96       	adiw	r30, 0x01	; 1
    65a4:	0d b2       	in	r0, 0x1d	; 29
    65a6:	0d 92       	st	X+, r0
    65a8:	41 50       	subi	r20, 0x01	; 1
    65aa:	50 40       	sbci	r21, 0x00	; 0
    65ac:	b8 f7       	brcc	.-18     	; 0x659c <__eerd_blraw_m32+0x8>
    65ae:	08 95       	ret

000065b0 <__eeupd_byte_m32>:
    65b0:	26 2f       	mov	r18, r22

000065b2 <__eeupd_r18_m32>:
    65b2:	e1 99       	sbic	0x1c, 1	; 28
    65b4:	fe cf       	rjmp	.-4      	; 0x65b2 <__eeupd_r18_m32>
    65b6:	9f bb       	out	0x1f, r25	; 31
    65b8:	8e bb       	out	0x1e, r24	; 30
    65ba:	e0 9a       	sbi	0x1c, 0	; 28
    65bc:	01 97       	sbiw	r24, 0x01	; 1
    65be:	0d b2       	in	r0, 0x1d	; 29
    65c0:	02 16       	cp	r0, r18
    65c2:	31 f0       	breq	.+12     	; 0x65d0 <__eeupd_r18_m32+0x1e>
    65c4:	2d bb       	out	0x1d, r18	; 29
    65c6:	0f b6       	in	r0, 0x3f	; 63
    65c8:	f8 94       	cli
    65ca:	e2 9a       	sbi	0x1c, 2	; 28
    65cc:	e1 9a       	sbi	0x1c, 1	; 28
    65ce:	0f be       	out	0x3f, r0	; 63
    65d0:	08 95       	ret

000065d2 <__mulsi3>:
    65d2:	62 9f       	mul	r22, r18
    65d4:	d0 01       	movw	r26, r0
    65d6:	73 9f       	mul	r23, r19
    65d8:	f0 01       	movw	r30, r0
    65da:	82 9f       	mul	r24, r18
    65dc:	e0 0d       	add	r30, r0
    65de:	f1 1d       	adc	r31, r1
    65e0:	64 9f       	mul	r22, r20
    65e2:	e0 0d       	add	r30, r0
    65e4:	f1 1d       	adc	r31, r1
    65e6:	92 9f       	mul	r25, r18
    65e8:	f0 0d       	add	r31, r0
    65ea:	83 9f       	mul	r24, r19
    65ec:	f0 0d       	add	r31, r0
    65ee:	74 9f       	mul	r23, r20
    65f0:	f0 0d       	add	r31, r0
    65f2:	65 9f       	mul	r22, r21
    65f4:	f0 0d       	add	r31, r0
    65f6:	99 27       	eor	r25, r25
    65f8:	72 9f       	mul	r23, r18
    65fa:	b0 0d       	add	r27, r0
    65fc:	e1 1d       	adc	r30, r1
    65fe:	f9 1f       	adc	r31, r25
    6600:	63 9f       	mul	r22, r19
    6602:	b0 0d       	add	r27, r0
    6604:	e1 1d       	adc	r30, r1
    6606:	f9 1f       	adc	r31, r25
    6608:	bd 01       	movw	r22, r26
    660a:	cf 01       	movw	r24, r30
    660c:	11 24       	eor	r1, r1
    660e:	08 95       	ret

00006610 <__udivmodsi4>:
    6610:	a1 e2       	ldi	r26, 0x21	; 33
    6612:	1a 2e       	mov	r1, r26
    6614:	aa 1b       	sub	r26, r26
    6616:	bb 1b       	sub	r27, r27
    6618:	fd 01       	movw	r30, r26
    661a:	0d c0       	rjmp	.+26     	; 0x6636 <__udivmodsi4_ep>

0000661c <__udivmodsi4_loop>:
    661c:	aa 1f       	adc	r26, r26
    661e:	bb 1f       	adc	r27, r27
    6620:	ee 1f       	adc	r30, r30
    6622:	ff 1f       	adc	r31, r31
    6624:	a2 17       	cp	r26, r18
    6626:	b3 07       	cpc	r27, r19
    6628:	e4 07       	cpc	r30, r20
    662a:	f5 07       	cpc	r31, r21
    662c:	20 f0       	brcs	.+8      	; 0x6636 <__udivmodsi4_ep>
    662e:	a2 1b       	sub	r26, r18
    6630:	b3 0b       	sbc	r27, r19
    6632:	e4 0b       	sbc	r30, r20
    6634:	f5 0b       	sbc	r31, r21

00006636 <__udivmodsi4_ep>:
    6636:	66 1f       	adc	r22, r22
    6638:	77 1f       	adc	r23, r23
    663a:	88 1f       	adc	r24, r24
    663c:	99 1f       	adc	r25, r25
    663e:	1a 94       	dec	r1
    6640:	69 f7       	brne	.-38     	; 0x661c <__udivmodsi4_loop>
    6642:	60 95       	com	r22
    6644:	70 95       	com	r23
    6646:	80 95       	com	r24
    6648:	90 95       	com	r25
    664a:	9b 01       	movw	r18, r22
    664c:	ac 01       	movw	r20, r24
    664e:	bd 01       	movw	r22, r26
    6650:	cf 01       	movw	r24, r30
    6652:	08 95       	ret

00006654 <__divmodsi4>:
    6654:	97 fb       	bst	r25, 7
    6656:	09 2e       	mov	r0, r25
    6658:	05 26       	eor	r0, r21
    665a:	0e d0       	rcall	.+28     	; 0x6678 <__divmodsi4_neg1>
    665c:	57 fd       	sbrc	r21, 7
    665e:	04 d0       	rcall	.+8      	; 0x6668 <__divmodsi4_neg2>
    6660:	d7 df       	rcall	.-82     	; 0x6610 <__udivmodsi4>
    6662:	0a d0       	rcall	.+20     	; 0x6678 <__divmodsi4_neg1>
    6664:	00 1c       	adc	r0, r0
    6666:	38 f4       	brcc	.+14     	; 0x6676 <__divmodsi4_exit>

00006668 <__divmodsi4_neg2>:
    6668:	50 95       	com	r21
    666a:	40 95       	com	r20
    666c:	30 95       	com	r19
    666e:	21 95       	neg	r18
    6670:	3f 4f       	sbci	r19, 0xFF	; 255
    6672:	4f 4f       	sbci	r20, 0xFF	; 255
    6674:	5f 4f       	sbci	r21, 0xFF	; 255

00006676 <__divmodsi4_exit>:
    6676:	08 95       	ret

00006678 <__divmodsi4_neg1>:
    6678:	f6 f7       	brtc	.-4      	; 0x6676 <__divmodsi4_exit>
    667a:	90 95       	com	r25
    667c:	80 95       	com	r24
    667e:	70 95       	com	r23
    6680:	61 95       	neg	r22
    6682:	7f 4f       	sbci	r23, 0xFF	; 255
    6684:	8f 4f       	sbci	r24, 0xFF	; 255
    6686:	9f 4f       	sbci	r25, 0xFF	; 255
    6688:	08 95       	ret

0000668a <__prologue_saves__>:
    668a:	2f 92       	push	r2
    668c:	3f 92       	push	r3
    668e:	4f 92       	push	r4
    6690:	5f 92       	push	r5
    6692:	6f 92       	push	r6
    6694:	7f 92       	push	r7
    6696:	8f 92       	push	r8
    6698:	9f 92       	push	r9
    669a:	af 92       	push	r10
    669c:	bf 92       	push	r11
    669e:	cf 92       	push	r12
    66a0:	df 92       	push	r13
    66a2:	ef 92       	push	r14
    66a4:	ff 92       	push	r15
    66a6:	0f 93       	push	r16
    66a8:	1f 93       	push	r17
    66aa:	cf 93       	push	r28
    66ac:	df 93       	push	r29
    66ae:	cd b7       	in	r28, 0x3d	; 61
    66b0:	de b7       	in	r29, 0x3e	; 62
    66b2:	ca 1b       	sub	r28, r26
    66b4:	db 0b       	sbc	r29, r27
    66b6:	0f b6       	in	r0, 0x3f	; 63
    66b8:	f8 94       	cli
    66ba:	de bf       	out	0x3e, r29	; 62
    66bc:	0f be       	out	0x3f, r0	; 63
    66be:	cd bf       	out	0x3d, r28	; 61
    66c0:	09 94       	ijmp

000066c2 <__epilogue_restores__>:
    66c2:	2a 88       	ldd	r2, Y+18	; 0x12
    66c4:	39 88       	ldd	r3, Y+17	; 0x11
    66c6:	48 88       	ldd	r4, Y+16	; 0x10
    66c8:	5f 84       	ldd	r5, Y+15	; 0x0f
    66ca:	6e 84       	ldd	r6, Y+14	; 0x0e
    66cc:	7d 84       	ldd	r7, Y+13	; 0x0d
    66ce:	8c 84       	ldd	r8, Y+12	; 0x0c
    66d0:	9b 84       	ldd	r9, Y+11	; 0x0b
    66d2:	aa 84       	ldd	r10, Y+10	; 0x0a
    66d4:	b9 84       	ldd	r11, Y+9	; 0x09
    66d6:	c8 84       	ldd	r12, Y+8	; 0x08
    66d8:	df 80       	ldd	r13, Y+7	; 0x07
    66da:	ee 80       	ldd	r14, Y+6	; 0x06
    66dc:	fd 80       	ldd	r15, Y+5	; 0x05
    66de:	0c 81       	ldd	r16, Y+4	; 0x04
    66e0:	1b 81       	ldd	r17, Y+3	; 0x03
    66e2:	aa 81       	ldd	r26, Y+2	; 0x02
    66e4:	b9 81       	ldd	r27, Y+1	; 0x01
    66e6:	ce 0f       	add	r28, r30
    66e8:	d1 1d       	adc	r29, r1
    66ea:	0f b6       	in	r0, 0x3f	; 63
    66ec:	f8 94       	cli
    66ee:	de bf       	out	0x3e, r29	; 62
    66f0:	0f be       	out	0x3f, r0	; 63
    66f2:	cd bf       	out	0x3d, r28	; 61
    66f4:	ed 01       	movw	r28, r26
    66f6:	08 95       	ret

000066f8 <_exit>:
    66f8:	f8 94       	cli

000066fa <__stop_program>:
    66fa:	ff cf       	rjmp	.-2      	; 0x66fa <__stop_program>
